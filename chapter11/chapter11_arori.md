## 11.1 개별 접촉

- HTTP: 익명, 상태 없음(stateless), 요청/응답으로 통신하는 프로토콜
- 현대의 웹 사이트는 개인화된 서비스를 제공.
    - **개별 인사**: 사용자에게 특화된 환영 메시지, 페이지 내용 만듦.
    - **사용자 맞춤 추천**: 고객의 흥미를 학습해서 좋아할 것으로 예상되는 제품 추천, 생일 등의 중요한 일정에 특별한 제품 제시
    - **저장된 사용자 정보**: 복잡한 주소, 신용 카드 정보를 데이터 베이스에 저장.
    - **세션 추적**: 사용자와 사이트가 상호작용할 수 있게, 상태를 남김(HTTP 트랜잭션은 상태가 없어, 각 요청/응답이 독립적으로 발생.)
- 이 장에서는 HTTP가 사용자를 식별하는데 사용하는 기술 정리
## 11.2 HTTP 헤더

- 사용자 정보를 전달하는 가장 일반적인 일곱가지 HTTP 요청 헤더
    - `Form`: 요청 헤더. 사용자의 이메일 주소
        - 악의적인 서버가 이메일 주소를 모아 스팸을 발생하는 문제가 있어서, 해당 헤더를 브라우저를 보내는 브라우저가 많지 않음
        - 로봇/스파이더가 데이터 수집 중에 웹 사이트에 문제를 일으켰을 때, 항의 메일을 보내도록 Form 헤더에 이메일 주소를 기술하기도 함
    - `User-Agent`: 요청 헤더. 사용자의 브라우저
        - 사용자가 쓰고있는 브라우저 이름, 버전 정보, 혹은 운영체제 정보를 포함
        - 특정 브라우저에서 잘 동작하도록 콘텐츠 최적화에는 유용하지만, 사용자 식별에는 도움이 되지 않음

        ```html
        크롬 38.0.2125.111 User-Agent
        Mozilla/5.0 (Windows NT 6.1) AppleWebkit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.111 Safari/537.36

        인터넥 익스플로러 9.0.29 User-Agent
        Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; Trident/5.0; SLCC@; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E
        ```

    - `Referer`: 요청 헤더. 사용자가 현재 링크를 타고 온 근원 페이지
        - 해당 헤더 자체만으로는 사용자 식별불가. 이전에 어떤 페이지를 방문했는지는 알 수 있어, 웹 사용행태나 취향 파악 가능.
    - `Authorization`: 요청 헤더. 사용자 이름, 비밀번호
    - `Client-ip`: 확장(요청) 헤더. 클라이언트 IP 주소
    - `X-Forwarded-For`: 확장(요청) 헤더. 클라이언트 IP 주소
    - `Cookie`: 확장(요청) 헤더. 서버가 생성한 ID 라벨

## 11.3 클라이언트 IP 주소

- 초기에는 사용자 식별을 IP주소로 하려고 함
    - 사용자가 확실한 IP 주소를 갖고 있고, 주소가 변경되지 않고, 매 요청시에 IP를 알 수 있다면 문제 없음
- HTTP 헤더에 IP는 없지만, HTTP 요청을 보내는 반대쪽 TCP 커넥션의 IP주소를 알아낼 수 있음

    ```html
    // 예: 유닉스 시스템에서 getpeername을 이용한 클라이언트 IP 주소 받기
    status = getpeername(tcp_connection_socket, ...);
    ```

- 하지만 IP주소로 사용자를 식별하는 방법은 다음과 같은 약점이 있음
    - IP주소는 사용자가 아닌 컴퓨터를 가리키므로, 여러 사용자가 사용시 식별 ㅂ루가능
    - 많은 ISP는 사용자가 로그인하면 동적으로 IP주소 할당. 로그인 시간에 따라 매번 다른 주소를 받으므로 식별 불가.
    - 보안 강화 및 부족한 주소 관리를 위해 많은 사용자가 네트워크 주소 변환(Network Address Translation, NAT) 방화벽을 통해 인터넷 사용. 이 NAT 장비들은 실제 IP주소를 방화벽 뒤로 숨기고, 실제 IP주소를 내부에서 사용하는 하나의 방화벽 IP주소(및 다른 포트 번호)로 변환
    - 보통, HTTP 프락시와 게이트웨이는 원 서버에 새로운 TCP 연결. 웹 서버는 클라이언트 IP주소 대신 프락시 서버 IP주소를 보게 됨. 일부 프락시는 원본 IP 주소를 보존하지만, 모든 프락시가 그러지는 않음.

## 11.4 사용자 로그인

- 사용자 이름 및 비밀번호로 인증(로그인)을 요구하여 명시적 식별 요청을 할 숫 있음.
- HTTP는 웹 사이트 로그인이 쉽도록 웹 사이트에 사용자 이름을 전달하는 자체적인 체계가 있음
    - `WWW-Authenciate` , `Authorization` 헤더 사용
- 서버에서 사용자가 사이트 접근 전에 로그인을 시키고자 한다면 HTTP `401 Login Required` 를 브라우저애 보낼 수 있으며, 브라우저는 로그인 대화 상자를 보여주고, 다음 요청에 `Authorization` 헤더에 그 정보를 기술하여 전송
    1. 브라우저가 `[www.joes-hardware.com](http://www.joes-hardware.com)` 사이트로 요청
    2. 사이트는 사용자의 식별정보를 알지 못하므로, `401 Login Required` 응답 코드와 `WWW-Authenciate` 헤더 반환하여 로그인을 요청. 브라우저는 로그인 대화상자 띄움. 
    3. 사용자가 사용자 이름, 비밀번호를 입력하고 브라우저는 기존 요청을 다시보내서 사용자 식별을 시도
    4. 서버는 사용자의 식별정보를 알게됨
    5. 이 시점 이후에 요청에 대해서 브라우저는 서버로부터 사용자 식별정보를 요청받으면, 자동으로 사용자 이름, 비밀번호를 전달하고, 요청하지 않았을 때도 전달함. 이는 사이트에서 한번만 로그인 하면 브라우저는 요청마다 `Authorization` 헤더에 담아 서버로 전송해 세션 진행 내내 식별을 유지.

## 11.5 뚱뚱한 URL

- 어떤 웹 사이트는 사용자의 URL 마다 버전을 포함해, 사용자 식별 및 추적
    - URL 경로의 처음이나 끝에 상태 정보를 추가해 확장
    - 사용자가 사이트를 탐색하면, 웹 서버는 URL에 있는 상태 정보를 유지하는 하이퍼링크를 동적으로 생성
- 사용자의 상태 정보를 포함하는 URL을 뚱뚱한 URL(fat URL)이라고 함
    - 아마존에서 사용하는 뚱뚱한 URL의 예(사용자 식별번호 002-145265-801683):

    ```html
    <a href="/exec/obidos/tg/browse/-/2290220/ref=gr_gifts/002-145265-801683">All Gifts</a>
    <a href="/exec/obidos/wishlist/ref=gr_pl1_/002-145265-801683">Wish List</a>
    ...
    ```

- 뚱뚱한 URL 동작 방식
    1. 사용자가 웹 사이트에 처음 방문하면 유일 ID가 생성
    2. 유일 ID 값은 서버가 인식할 수 있는 방식으로 URL에 추가되며, 서버는 이 뚱뚱한 URL로 리다이렉트 시킴
    3. 서버가 뚱뚱한 URL을 포함한 요청을 받으면, 사용자 아이디와 관련 정보를 찾아서 밖으로 향하는 모든 하이퍼링크를 뚱뚱한 URL로 바꿈 
- 뚱뚱한 URL의 단점
    - **못생긴 URL**: 브라우저에 보이는 URL이 혼란을 줌
    - **공유하지 못하는 URL**: 특정 사용자의 정보를 포함하여, 누군가에게 공유하면 개인정보도 공유하게 됨
    - **캐시를 사용할 수 없음**: URL이 바뀌므로 기존 캐시에 접근 불가
    - **서버 부하 가증**: 서버는 뚱뚱한 URL에 해당하는 HTML 페이지를 다시 그려야 함.
    - **이탈**: 링크를 타고 다른 사이트를 이동하거나, 특정 URL을 요청하여 뚱뚱한 URL 세션에서 이탈하기 쉬움.
    - **세션 간 지속성 부재**: 특정 뚱뚱한 URL을 북마킹하지 않는 이상, 로그아웃시에 모든 정보를 잃음

## 11.6 쿠키

- 사용자 식별 및 세션 유지 방식 중 제일 널리 사용하는 방식
    - 앞선 기술들의 문제점을 겪지 않지만, 쿠키만으로 불가능한 경우는 앞선 기술과 같이 사용하기도 함
- 넷스케이프가 최초로 개발했고, 현재는 모든 브라우저에서 지원.
- 쿠키는 캐시와 충돌할 수 있어서, 대부분의 캐시, 브라우저는 쿠키를 캐싱하지 않음

### 11.6.1 쿠키의 타입

- 세션 쿠키 session cookie:
    - 사이트 탐색할 때, 관련 설정및 선호 사항을 저장하는 임시 쿠키
    - 브라우저를 닫으면 삭제됨
- 지속 쿠키 peristent cookie:
    - 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름 유지에 사용
    - 브라우저를 닫거나 컴퓨터를 재시작하더라도 남음
- 세션쿠키와 지속 쿠키는 파기시점만 다름

### 11.6.2 쿠키는 어떻게 동작하는가

1. 처음에 사용자가 웹 사이트 방문시, 서버는 사용자에 대해 아무것도 모름
2. 웹 서버는 사용자가 다시 돌아 왔을 때에 사용자를 식별하기 위한 유일한 값을 쿠키에 할당
    - key=value 형태의 리스트를 가지고, `Set-Cookie` 같은 HTTP 응답 헤더에 포함
    - 어떤 정보든 포함할 수 있지만, 사용자 추적용 ID를 주로 사용하며 그 외에 많은 정보를 유지할 수 있음
3. 브라우저는 서버로 온 `Set-Cookie` 헤더의 쿠키 콘텐츠를 브라우저 쿠키 데이터베이스에 저장
4. 사용자가 미래에 같은 사이트를 방문 시 서버가 사용자에게 할당했던 쿠키를 Cookie 요청헤더에 기술해 전송 

### 11.6.3 쿠키 상자: 클라이언트 측 상태

- 쿠키의 기본 발상은 브라우저가 서버 관련 정보를 저장하고 사용자가 해당 서버에 접근할 때마다 그 정보를 함께 정보하는 것.
- 즉 브라우저는 쿠키 정보를 저장할 책임이 있고, 이를 '**클리아언트 측 상태(client-side state)**' 라고 함.
    - 쿠키 명세에서 공식적인 이름은 '**HTTP 상태 관리 체계(HTTP State Management Mechanism)**'

***구글 크롬 쿠키***

- Cookies라는 SQLite 파일에 쿠키를 저장.
- 총 15개의 필드가 있으며, 그 중 몇 필드는 다음과 같음(크롬 87.0.4280.88 기준):

    ```sql
    CREATE TABLE cookies
    	( 
    		creation_utc    INTEGER NOT NULL, 
    		host_key        TEXT NOT NULL, 
    		name            TEXT NOT NULL, 
    		value           TEXT NOT NULL, 
    		path            TEXT NOT NULL, 
    		expires_utc     INTEGER NOT NULL, 
    		is_secure       INTEGER NOT NULL, 
    		is_httponly     INTEGER NOT NULL, 
    		last_access_utc INTEGER NOT NULL, 
    		has_expires     INTEGER NOT NULL DEFAULT 1, 
    		is_persistent   INTEGER NOT NULL DEFAULT 1, 
    		priority        INTEGER NOT NULL DEFAULT 1, 
    		encrypted_value BLOB DEFAULT '', 
    		samesite        INTEGER NOT NULL DEFAULT -1, 
    		source_scheme   INTEGER NOT NULL DEFAULT 0, 
    		UNIQUE (host_key, name, path) 
    	);
    ```

    - `creation_utc`: 쿠키가 생성된 시점. UNIX 시간
    - `host_key`: 쿠키의 도메인
    - `name`: 쿠키의 이름
    - `value`: 쿠키의 값
    - `path`: 쿠키와 관련된 도메인에 있는 경로
    - `expires_utc`: 쿠키의 파기 시점. UNIX 시간
    - `is_secure`: SSL 커넥션인 경우에만 보낼지 여부

***마이크로소프트 인터넷 익스플로러 쿠키***

- 캐시 디렉터리에 각각 개별 파일로 쿠키를 저장 했었음.
    - Internet options > Browsing history - Settings > View files
- 인터넷 익스플로러 자체 형식을 가지고 기술되지만, 이해할 수 있게 쉽게 되어있음.
    - 과거에는 일반 IDE로 열어서 확인 가능했지만, 현재는 모든 쿠키 파일이 `deprecated.cookie` 파일에 심링크 되어있음

    ```
    // deprecated.cookie 파일 내용
    Cookies are no longer stored in files. Please use Internet*Cookie* APIs to access cookies.
    ```

### 11.6.4 사이트마다 각기 다른 쿠키들

- 브라우저는 수천개의 쿠키를 가지고 있을 수 있지만, 브라우저가 쿠키 전부를 모든 사이트에 보내지 않음
    - 쿠키를 모두 전달하면 성능이 크게 저하되기 때문. 실제 콘텐츠보다도 더 많아질 수 있음
    - 쿠키는 대부분 각 서버에 특화된 key/value 이므로, 다른 사이트에서는 인식하지 않는 무의미한 값이기 때문
    - 모든 사이트에 쿠키 전체를 전달하는 것은, 신뢰하지 않는 사이트에 잠재적인 개인정보를 전달할 수 있기때문
- 브라우저는 보통 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달.
- 많은 웹 사이트는 광고 관리 업체와 계약하여, 광고들이 웹 사이트의 일부인거처럼 제작하고 지속쿠키를 만들어 냄.
    - 같은 광고사에서 서로 다른 웹 사이트에 사용자가 방문하면, 브라우저는 앞서 만든 지속 쿠키를 다시 광고사로 서버 전송.(지속 쿠키 도메인이 같으므로)
    - 이 기술에 `Referer` 헤더를 접목하여, 사용자의 프로필가 웹 사용 습관 데이터를 구축
    - 최신 브라우저는 개인정보 설정 기능을 통해 쿠키 사용 방식에 제약을 가할 수 있음

***쿠키 Domain 속성***

- 서버는 쿠키 생성 시 `Set-Cookie` 응답 헤더에 `Domain` 속성을 기술해, 어떤 사이트가 그 쿠키를 읽을수 있는지 제어 가능.

    ```
    Set-cookie: user="mari17"; domain="airtravelbargains.com"
    ```

- 사용자가 해당 도메인, 혹은 서브 도메인을 방문하면 `Cookie: user="mari17"` 가 항상 적용될 것임

***쿠키 Path 속성***

- URL 경로의 앞부분을 가리키는 `Path` 속성을 기술해 웹 사이트 일부에만 쿠키 적용 가능.

    ```
    Set-cookie: pref=compact; domain="airtravelbargain.com"; path=/autos/
    ```

- `http://www.airtravelbargains.com/autos/...` 로 접속시에는 pref 도 쿠키로 받게 됨.

### 11.6.5 쿠키 구성 요소

- 쿠키의 버전
    - Version 0 쿠키(a.k.a 넷프케이 쿠키) Version 1 쿠키([RFC 2965](https://tools.ietf.org/html/rfc2965)) 쿠키가 있으며, Version 1은 Version 0 쿠키의 확장. RFC 2965는 [RFC 6265](https://tools.ietf.org/html/rfc6265)에 의해 폐기됨.
    - Version 0, 1쿠키 명세는 HTTP/1.1 명세로 기술되어있지 않음.
- 아래의 헤더 내용은 책 내용과 MDN 내용을 포함하여 현대의 방식으로 기술하였음.

***Set-Cookie 헤더 [[참고]](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Set-Cookie)*** 

```
Set-Cookie: name=value [; expires=date] [; path=path] [; domain=domain] [; secure]
Cookie: name1=value1 [; name2=value2] ...
```

- **이름=값**: 필수 속성. 이름과 값은 모두 큰 따옴표로 감싸지 않은 세미콜론, 쉼표, 등호, 공백을 포함하지 않는 문자열
- **Expires**: 선택 속성. 쿠키의 생명주기를 가리키는 문자열로, 타임존은 GMT. 명시하지 않으면 사용자 세션이 끝날 때 파기 됨.
- **Max-Age**: 선택 속성. 쿠키가 만료될 때 까지의 시간(초 단위). 0, 음수 값이면 쿠키는 즉시 만료. 오래된 브라우저는 지원하지 않으며, 지원하는 브라우저는 `Expires` 와 `Max-Age` 둘 다 있으면 `Max-Age` 를 우선시
- **Domain**: 선택 속성. 브라우저는 이 속성이 기술된 도메인(및 서브도메인)을 사용하는 서버 호스트명으로만 쿠키를 전송. 명시하지 않으면 응답을 생성한 서버의 호스트 명(서브 도메인을 미포함)을 기본 값으로 사용.
- **Path**: 선택 속성. 서버에 있는 특정 문서에만 쿠키를 할당할 수 있음. URL의 경로의 앞부분과 일치하면 쿠키 전달.
- **Secure**: 선택 속성. 이 속성이 포함되면 HTTP가 SSL 보안 연결을 사용할 때만 쿠키 전송

***Cookie 헤더 [[참고]](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Cookie)***

- 클라이언트가 서버에 요청을 보낼 때는, `Domain`, `Path`, `Secure` 필터가 맞는 경우에 파기되지 않은 쿠키들을 함께 보낸다. 모든 쿠키는 한 `Cookie` 헤더에 이어 붙여서 보낸다.

```
Cookie: session-id=002-1145265-0816838; session-id-time=1007884800
```

### 11.6.6 Version 0(넷스케이프) 쿠키

- 최초의 쿠키 명세로, `Set-Cookie` 응답 헤더, `Cookie` 요청 헤더, 쿠키를 조작하는데 필요한 필드를 정의

### 11.6.7 Version 1(RFC 2965) 쿠키

- 확장된 버전은 Version 0 시스템과 호환되며, `Set-Cookie2`, `Cookie2` 헤더를 소개 함
- 현재 미사용 되고 있으며 필요시에는 원본 책을 참고

### 11.6.8 쿠키와 세션 추적

1. 브라우저가 [Amazon.com](http://amazon.com) 의 루트 페이지를 처음 요청
2. 서버는 클라이언트를 전자상거래 소프트웨어 URL로 리다이렉트
3. 클라이언트는 리다이렉트 URL 로 요청 보냄
4. 서버는 응답에 세션 쿠키를 기술하고, 사용자를 다른 URL로 리다이렉트, 클라이언트는 다시 이 쿠키를 첨부하여 요청. 
5. 클라이언트는 새로운 URL 요청을 앞서 받은 쿠키와 함께 전송
6. 서버는 hoem.html 페이지로 리다이렉트 시키고, 쿠키를 더 첨부
7. 클라이언트는 home.html 페이지를 가져오고 더 첨부된 쿠키를 포함하여 전달
8. 서버는 콘텐츠를 전송 

### 11.6.9 쿠키와 캐싱

- 쿠키 트랜잭션과 관련된 문서를 캐싱하는 것을 주의해야함.
    - 다른 사용자의 쿠키가 할당되거나, 다른 사람에게 개인정보가 노출될 수 있음.
- 쿠키와 캐싱에 관련된 규칙은 잘 정리되어있지 않지않음.

***캐시를 다루는 기본 원칙***

- **캐시되지 말아야할 문서가 있다면 표시하라**
    - `Cache-Control: nocache="SetCookie"` 를 기술하여 명확히 표시
    - 캐시해도 되는 문서라면 `Cache-Control: public` 을 사용하면 대역폭 절약 가능
- **Set-Cookie 헤더를 캐시하는것에 유의하라**
    - `Set-Cookie` 헤더를 포함하는 응답의 본문은 캐시할 수 있지만, `Set-Cookie` 헤더를 캐시하는것은 주의해야함.
    - 캐시가 모든 요청마다 원 서버와 재검사 시킴(`Cache-Control: must-revalidate, max-age=0`)으로 문제 개선 가능
- **Cookie 헤더를 가지고 있는 요청을 주의하라**
    - 요청이 `Cookie` 헤더와 함께 오면, 개인정보를 담을수도 있다는 힌트.
    - 동일하게 원 서버와 재검사하여 해결할 수 있음.

### 11.6.10 쿠키, 보안 그리고 개인정보

- 쿠키를 미사용하거나, 로그 분석같은 방법으로 대체 가능하므로 그 자체로 보안상으로 위험한 것은 아님
    - 원격 데이터베이스에 개인정보를 저장하고 해당 데이터의 키값을 쿠키에 저장하면 예민한 데이터가 오가는 것을 줄일 수 있음
- 개인 정보 정책에만 유의한다면, 쿠키에 관련한 위험성보다 세션 조작이나 트랜잭션상의 편리함이 큼
