# 11. 클라이언트 식별과 쿠키

* 웹 서버는 서로 다른 수천 개의 클라이언트와 동시에 통신한다.
* 익명의 클라이언트로부터 받은 요청을 처리하는 것 뿐 아니라 서버와 통신하는 클라이언트를 추적해야 할 수도 있다.
* 서버가 통신하는 대상을 식별하는 기술을 알아본다.

## 11.1 개별 접촉

* HTTP는 익명으로 사용하며 상태가 없고 요청과 응답으로 통신하는 프로토콜이다.
  * 연결 자체에 대한 정보를 가지지 않으며 매 요청은 일회성이고 독립적으로 처리된다: HTTP는 '상태가 없다', 무상태(stateless)라 부른다.
* 웹 서버는 요청을 보낸 사용자를 식별하거나 방문자가 보낸 연속 요청을 추적하기 위해 약간의 정보를 이용할 수 있다.

#### 개별 인사

* 온라인 쇼핑이 개인에게 맞춰져 있는 것 처럼 느끼게 하려고 사용자 특화 메시지나 페이지 내용을 만든다.

#### 사용자 맞춤 추천

* 고객의 흥미를 학습하여 고객이 좋아할 것이라 예상하는 제품을 추천하거나, 고객의 생일 등 특별한 날이 다가올 때 맞품 제품을 제시하기도 한다.

#### 저장된 사용자 정보

* 주소와 신용카드 정보를 매번 입력하는 것이 번거롭기 때문에 데이터베이스에 정보를 저장한다.
* 한 번 사용자를 식별하고 나면 저장된 정보를 사용하여 더 편하게 쇼핑할 수 있게 한다.

#### 세션 추적

* HTTP 트랜잭션은 상태가 없으며 각 요청과 응답은 독립적으로 일어난다.
* 많은 웹사이트는 사용자가 사이트와 상호작용할 수 있게 사용자 상태(ex. 장바구니)를 남기는데, 이런 상태를 유지하려면 각 사용자에게서 오는 HTTP 트랜잭션 식별 방법이 필요하다.

---

* HTTP가 사용자를 식별하는 데 사용하는 기술들
  * 사용자 식별 관련 정보를 전달하는 HTTP 헤더들
  * 클라이언트 IP 주소 추적으로 알아낸 IP 주소로 사용자를 식별
  * 사용자 로그인 인증을 통한 사용자 식별
  * URL에 식별자를 포함하는 기술인 뚱뚱한(fat) URL
  * 식별 정보를 지속해서 유지하는 강력하면서도 효율적인 기술인 쿠키

## 11.2 HTTP 헤더

* `From`
  * 요청 헤더. 사용자 이메일 주소.
  * 이상적으로 각 사용자는 서로 다른 이메일 주소를 가지므로 From 헤더로 식별할 수 있다.
  * 악의적인 서버가 이메일 주소를 모아서 스팸 메일을 발송하는 문제가 있어서 이를 사용하는 브라우저는 많지 않다.
  * 실제로 로봇, 스파이더는 데이터 수집 과정에서 본의 아니게 웹사이트에 문제를 일으켰을 때 해당 사이트의 웹마스터가 항의 메일을 보낼 수 있도록 From 헤더에 이메일 주소를 기술한다.
* `User-Agent`
  * 요청 헤더. 사용자 브라우저
  * 사용자가 쓰고 있는 브라우저의 이름과 버전 정보, 어떤 경우 운영체제에 대한 정보까지 서버에 알려준다.
  * 특정 브라우저에서 제대로 동작하도록 그 속성에 맞춰 콘텐츠를 최적화하는 데 유용하나, 특정 사용자를 식별하는 데는 큰 도움이 되지는 않는다.
* `Referer`
  * 요청 헤더. 사용자가 현재 링크를 타고 온 근원 페이지
  * 사용자가 현재 페이지로 유입하게 한 웹페이지의 URL을 가리킨다. 이 헤더 자체만으로 사용자 식별을 할 수는 없으나, 사용자가 이전에 어디를 방문했는지 알려준다.
  * 이를 통해 사용자의 웹 사용 행태나 취향을 더 잘 파악할 수 있다.
* `Authorization`
  * 요청 헤더. 사용자 이름과 비밀번호
* `Client-ip`
  * 확장(요청) 헤더. 클라이언트의 IP 주소
* `X-Forwarded-For`
  * 확장(요청) 헤더. 클라이언트의 IP 주소
* `Cookie`
  * 확장(요청) 헤더. 서버가 생성한 ID 라벨

## 11.3 클라이언트 IP 주소

* 클라이언트의 IP로 사용자 식별을 하는 것은, 사용자가 확실한 IP 주소를 가지고 있고, 그 주소가 바뀌지 않고, 웹 서버가 요청마다 클라이언트 IP를 알 수 있다면 문제가 없다.
* 클라이언트의 IP 주소는 보통 HTTP 헤더에 없지만, 웹 서버는 HTTP 요청을 보내는 반대편 TCP 커넥션의 IP 주소를 알아낼 수 있다.
* 클라이언트 IP 주소로 사용자 식별하는 방법의약점
  * 클라이언트 IP 주소는 사용자가 아닌 사용자가 사용하는 컴퓨터를 가리킨다. 여러 사요앚가 같은 컴퓨터를 사용하다면 식별할 수 없다.
  * 많은 인터넷 서비스 제공자(ISP)는 사용자가 로그인하면 동적으로 IP 주소를 할당한다. 로그인 시간에 따라 사용자는 매번 다른 주소를 받으므로 식별할 수 없다.
  * 보안 강화와 부족한 주소 관리를 위해 많은 사용자가 네트워크 주소 변환(Network Address Translation, NAT) 방화벽을 통해 인터넷을 사용한다. 이 장비들은 클라이언트 실제 IP 주소를 방화벽 뒤로 숨기고 내부에서 사용하는 하나의 방화벽 IP 주소(그리고 다른 포트 번호)로 변환한다.
  * 보통 HTTP 프락시와 게이트웨이는 원 서버에 새로운 TCP 연결을 한다. 웹 서버는 클라이언트 IP 주소 대신 프락시 서버의 IP 주소를 본다. 일부 프락시는 원본 IP 주소를 보존하기 위해 Client-ip나 `X-Forwarded-For` HTTP 같은 확장 헤더를 추가해 이 문제를 해결하려 했으나 모든 프락시가 이렇게 동작하지 않는다.
* 어떤 사이트는 보안 기능으로 IP 주소를 사용하여 특정 IP 주소로부터 오는 사용자에게만 문서를 전달하기도 하는데, 이런 방식은 인트라넷 같이 제한된 영역에서는 적절할 수 잇으나, 인터넷에서는 IP 주소를 임의 변경 할 수 있기 때문에 문제가 발생할 수 있다. 또 클라이언트와 서버 사이의 프락시도 문제를 발생시킬 수 있다.

## 11.4 사용자 로그인

* 웹 서버는 사용자 이름과 비밀번호로 인증(로그인)할 것을 요구해 사용자에게 명시적으로 식별 요청을 할 수 있다.
* 웹사이트 로그인이 더 쉽도록 HTTP는 `WWW-Authenticate`와 `Authorization` 헤더를 사용해 웹 사이트에 사용자 이름을 전달하는 자체적 체계를 갖고 있다.
* 한번 로그인 하면 브라우저는 사이트로 보내는 모든 요청에 이 로그인 정보를 함께 보내므로 웹 서버는 그 정보를 항상 확인할 수 있다.
* 서버에서 사용자가 사이트 접근 전에 로그인하도록 하려면 HTTP 401 Login Required 응답 코드와 `WWW-Authenticate `헤더를 브라우저에 보낸다.
  * 브라우저는 로그인 대화상자를 보여주고 사용자가 사용자 이름과 비밀번호를 입력하면 브라우저는 기존 요청을 다시 보내서 사용자 식별을 시도한다.
  * 다음 요청부터는 자동으로 `Authorization` 헤더에 그 정보를 기술하여 서버로 전송해서, 한 세션이 진행되는 동안 사용자 식별을 유지한다.

## 11.5 뚱뚱한 URL

* 사용자의 URL마다 버전을 기술하여 사용자를 식별하고 추적할 수 있다.
  * URL 경로의 처음이나 끝에 어떤 상태 정보를 추가해 확장하고, 웹 서버는 URL에 있는 상태 정보를 유지하는 하이퍼링크를 동적으로 생성한다.
* 사용자 상태정보를 포함하는 URL을 뚱뚱한(fat) URL이라고 한다.
  * 예) 사용자에게 할당된 식별번호(`002-1145265-801638`)를 URL 뒤에 붙여서 추적: `<a href="/exec/obidos/fg/browse/-/229220/ref=gr_gifts/002-1145265-801638">All gifts</a>`
* 웹 서버와 통신하는 독립적인 HTTP 트랜잭션을 하나의 '세션' 혹은 '방문' 으로 묶는 용도로 뚱똥한 URL을 사용할 수 있다.
  * 사용자가 웹사이트에 처음 방문하면 유일한 ID를 생성하여 이를 서버가 인식할 수 있는 방식으로 URL에 추가하고, 서버는 클라이언트를 이 뚱뚱한 URL로 리다이렉트 시킨다.
  * 서버가 뚱뚱한 URL을 포함한 요청을 받으면 밖으로 향하는 모든 하이퍼링크를 뚱뚱한 URL로 변환한다.
* 뚱뚱한 URL의 문제점
  * 못생긴 URL: 브라우저에 노출되는 URL은 새로운 사용자들에게 혼란을 준다.
  * 공유하지 못하는 URL: 특정 사용자와 세션에 대한 정보를 포함하므로 이 주소를 누군가에게 공유한다면, 특정 사용자의 개인정보를 공유하는 셈이다.
  * 캐시를 사용할 수 없음: URL이 달라지기 때문에 기존 캐시에 접근할 수 없다.
  * 서버 부하 가중: 서버는 뚱뚱한 URL에 해당하는 HTML 페이지를 다시 그려야 한다.
  * 이탈: 사용자가 링크를 타고 다른 사이트로 이동하거나 특정 URL을 요청하여 의도치 않게 뚱뚱한 URL 세션에서 '이탈'하기 쉽다.
  * 세션 간 지속성의 부재: 사용자가 특정 뚱뚱한 URL을 북마킹하지 않는 이상 로그아웃하면 모든 정보를 잃는다.

## 11.6 쿠키

* 쿠키는 사용자를 식별하고 세션을 유지하는 방식 중 현재까지 가장 널리 사용하는 방식이다.
* 쿠키는 넷스케이프가 최초로 개발했으나 지금은 모든 브라우저에서 지원한다.
* 쿠키는 캐시와 충돌할 수 있어서 대부분의 캐시나 브라우저는 쿠키에 있는 내용물을 캐싱하지 않는다.

### 11.6.1 쿠키의 타입

* 세션 쿠키(session cookie)
  * 사용자가 사이트를 탐색할 때, 관련 설정과 선호 사항을 저장하는 임시 쿠키다.
  * 사용자가 브라우저를 닫으면 삭제된다.
* 지속 쿠키(persistent cookie)
  * 디스크에 저장되어 브라우저를 닫거나 컴퓨터를 재시작해도 삭제되지 않고 더 길게 유지될 수 있다.
  * 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용한다.
* 세션 쿠키와 지속 쿠키의 차이는 파기되는 시점 뿐이다.
* 쿠키는 `Discard` 파라미터가 설정되어 있거나 파기되기까지 남은 시간을 가리키는 `Expires`, `Max-Age` 파라미터가 없으면 세션 쿠키가 된다.

### 11.6.2 쿠키는 어떻게 동작하는가

* 쿠키는 서버가 사용자에게 붙인 스티커와 같다. 사용자가 웹사이트에 방문하면 웹 사이트는 서버가 사용자에게 붙인 모든 스티커를 읽을 수 있다.
* 사용자가 웹사이트에 방문하면 웹 서버는 사용자에 대해 아무것도 모른다.
* 사용자가 다시 돌아왔을 때, 웹 서버는 해당 사용자를 식별하기 위한 유일한 값을 쿠키에 할당한다.
* 쿠키는 임의의 이름=값 형태의 리스트를 가지고, 그 리스트는 `Set-Cookie` 혹은 `Set-Cookie2`(확장헤더) 같은 HTTP 응답 헤더에 기술되어 사용자에게 전달한다.
* 쿠키는 어떤 정보든 포함할 수 있으나 서버가 사용자 추적 용도로 생성한 유일한 단순 식별 번호만 포함하기도 한다.
* 브라우저는 서버로 온 `Set-Cookie`/`Set-Cookie2` 헤더에 있는 쿠키 콘텐츠를 브라우저 쿠키 데이터베이스에 저장한다.
* 브라우저는 서버가 이 사용자에게 할당했던 쿠키를 Cookie 요청 헤더에 기술해 전송한다.

### 11.6.3 쿠키 상자: 클라이언트 측 상태

* 쿠키의 기본적인 발상은 브라우저가 서버 관련 정보를 저장했다가 사용자가 해당 서버에 접근할 떄마다 그 정보를 함께 전송하게 하는 것이다.
* 브라우저는 쿠키 정보를 저장할 책임이 있는데, 이 시스템을 '클라이언트 측 상태'라고 한다: HTTP 상태 관리 체계(HTTP State Management Mechanism)

#### 구글 크롬 쿠키

* 브라우저마다 각기 다른 방식으로 쿠키를 저장한다. 구글 크롬은 `Cookies`라는 SQLite 파일에 쿠키를 저장한다.

##### `creation_utc`

쿠키가 생성된 시점을 알려준다. `Jan 1, 1970 00:00:00 GMT`로부터 생성된 시간을 초 단위로 기술한다.

##### `host_key`

쿠키의 도메인이다.

##### `name`

쿠키의 이름이다.

##### `value`

쿠키의 값이다.

##### `path`

쿠키와 관련된 도메인에 있는 경로다.

##### `expire_utc`

쿠키 파기 시점을 알려준다. `Jan 1, 1970 00:00:00 GMT`로부터 파기될 시간을 초 단위로 기술한다.

##### `is_secure`

이 쿠키를 SSL 커넥션일 경우에만 보낼지를 가리킨다.

#### 마이크로소프트 인터넷 익스플로러 쿠키

* IE는 캐시 디렉터리에 각각 개별 파일로 쿠키를 저장한다. 쿠키 파일은 자체적인 형식을 가지고 기술되지만, 필드 대부분은 이해하기 쉽게 되어있다.
* 각 쿠키는 각 파일에 개별 저장되며 각 쿠키는 여러 행으로 기술되어 있다.
* 파일에 있는 각 쿠키의 첫 번째 줄은 쿠키의 이름, 다음 줄은 쿠키의 값이다. 세 번째 줄에는 도메인과 경로가 있다.
* 나머지 줄에는 인터넷 익스플로러만을 위한 데이터가 있고 날짜나 표식같이 이 쿠키에 대한 정보들이 추가적으로 들어갈 수 있다.

### 11.6.4 사이트마다 각기 다른 쿠키들

* 브라우저는 수백 수천 개의 쿠키를 가지고 있을 수 있지만, 브라우저가 쿠키 전부를 모든 사이트에 보내지는 않는다. 보통 각 사이트에 2~3개 쿠키만을 보낸다.
  * 쿠키를 모두 전달하면 성능이 크게 저하되며, 실제 콘텐츠의 바이트보다 더 많은 쿠키 바이트를 전달하게 될 것이다.
  * 대부분 쿠키가 서버에 특화된 이름/값 쌍을 포함하기 때문에 대부분 사이트에서는 인식하지 않는 무의미한 값이다.
  * 특정 사이트에서 제공한 정보를 신뢰하지 않는 사이트에서 가져갈 수 있어서 잠재적인 개인정보 문제를 일으킬 수 있다.
* 보통 브라우저는 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달한다.
  * 광고는 웹 사이트 자체의 일부인 것처럼 제작되고 지속 쿠키를 만들어 낸다. 같은 광고사에서 제공하는 서로 다른 웹 사이트에 사용자가 방문하면 브라우저는 앞서 만든 지속쿠키를 다시 광고사 서버로 전송한다. 지속 쿠키의 도메인이 같기 때문이다.
  * 광고사는 이 기술에 Referer 헤더를 접목해 사용자의 프로필과 웹 사이트를 사용하는 습관에 대한 방대한 데이터를 구축할 수 있다.
  * 최신 브라우저는 개인정보 설정 기능을 통해 협력 업체의 쿠키 사용 방식에 제약을 가할 수 있게 한다.

### 쿠키 Domain 속성

* 서버는 쿠키를 생성할 때 `Set-Cookie` 응답 헤더에 Domain 속성을 기술해서 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어한다.
* ex) `Set-Cookie: user="mary17"; domain="abcd.com"` : `user="mary17"` 이라는 쿠키를 `.abcd.com` 도메인을 가진 모든 사이트에 전달한다.

### 쿠키 Path 속성

* 웹 사이트 일부에만 쿠키를 적용할 수도 있다. URL 경로 앞부분을 가리키는 Path 속성을 기술해서 해당 경로에 속하는 페이지에만 쿠키를 전달한다.
* ex) `Set-Cookie: pref=compact; domain="abcd.com"; path=/autos/`
  * 사용자가 `http://abcd.com/list.html` 에 접근하면 `Cookie: user="mary17"` 쿠키만 얻게 된다.
  * 사용자가 `http://abcd.com/autos/index.html` 에 접근하면 `Cookie: user="mary17"`, `Cookie: pref=compact` 두 가지 쿠키를 받는다.
* 쿠키는 일종의 상태 정보라고 할 수 있다.

### 11.6.5 쿠키 구성요소

* 쿠키 명세에는 Version 0 쿠키(넷스케이프 쿠키)와 Version 1 쿠키('RFC 2965')가 있다.
* Version 1 쿠키는 Version 0 쿠키의 확장으로 2011년 RFC 6265에 의해 폐기되어 현재 사용되지 않는 HISTORIC 상태다.
* Version 0, Version 1 쿠키 명세는 HTTP/1.1 명세 일부로 기술되어 있지는 않다.

### 11.6.6 Version 0(넷스케이프) 쿠키

* `Set-Cookie` 응답 헤더와 `Cookie` 요청 헤더, 쿠키를 조작하는 데 필요한 필드들이 정의되어 있다.
```
Set-Cookie: name=value [; expires=date] [; path=path] [; domain=domain] [; secure]
```
```
Cookie: name1=value1 [; name2=value2] ...
```

#### Version 0 Set-Cookie 헤더

* `이름=값`: 필수 속성. 이름과 값 모두 큰따옴표로 감싸지 않는 세미콜론, 쉼표, 등호, 공백을 포함하지 않는 문자열이다.
* `Expires`: 선택 속성. 쿠키의 생명주기를 가리키는 날짜 문자열을 기술한다. 파기 일자에 다다르면 쿠키는 삭제되어 전달되지 않는다.
  * 타임존은 GMT이며 날짜 요소 간 구분자는 대시(-)여야 한다.
  * 쿠키에 Expires를 명시하지 않으면 사용자 세션이 끝날 때 파기된다.
* `Domain`: 선택 속성. 이 속성에 기술된 도메인을 사용하는 서버 호스트 명으로만 쿠키를 전송한다.
  * 도메인을 명시하지 않으면 Set-Cookie 응답을 생성한 서버의 호스트 명을 기본값으로 사용한다.
* `Path`: 선택 속성. 서버에 있는 특정 문서에만 쿠키를 할당한다. URL 경로의 앞부분과 Path 값이 일치하면 쿠키를 전달한다.
  * 경로를 명시하지 않으면 Set-Cookie 응답을 전달하는 URL 경로가 사용된다.
* `Secure`: 선택 속성. HTTP가 SSL 보안 연결을 사용할 때만 쿠키를 전송한다.

#### Version 0 Cookie 헤더

* 클라이언트가 서버에 요청을 보낼 때는, `Domain`, `Path`, `Secure` 필터가 현재 요청하려는 사이트에 맞고 아직 파기되지 않은 쿠키들을 함께 보낸다.
* 모든 쿠키는 하나의 `Cookie` 헤더에 이어 붙여 보낸다.

### 11.6.7 Version 1(RFC 2965) 쿠키

* Version 1은 `Set-Cookie2`, `Cookie2` 헤더를 소개하며 Verion 0 시스템과도 호환된다.
* 현재는 사용하지 않는다.

### 11.6.8 쿠키와 세션 추적

1. 브라우저가 Amazon.com의 루트 페이지를 처음 요청한다.
2. 서버는 클라이언트를 전자상거라 소프트웨어 URL로 리다이렉트한다.
3. 클라이언트는 리다이렉트 URL로 요청을 보낸다.
4. 서버는 응답에 두 개의 세션 쿠키를 기술하고 사용자를 다른 URL로 리다이렉트 시키며, 클라이언트는 다시 이 쿠키를 첨부해 요청을 보낸다.
    * 새로운 URL은 자체에 상태 정보를 가지고 있어 뚱뚱한 URL이라고 할 수 있다.
5. 클라이언트는 새로운 URL 요청을 앞서 받은 두 개의 쿠키(`session-id`, `session-id-time`)와 함께 보낸다.
6. 서버는 home.html 페이지로 리다이렉트하고 쿠키 두 개(`ubid-main`, `x-main`)를 더 첨부한다.
7. 클라이언트는 home.html 페이지를 가져오고 총 네 개의 쿠키를 전달한다.
8. 서버는 콘텐츠를 보낸다.

### 11.6.9 쿠키와 캐싱

* 쿠키 트랜잭션과 관련된 문서를 캐싱하는 것은 주의해야 한다.
  * 이전 사용자의 쿠키가 다른 사용자에게 할당되거나 누군가의 개인정보가 다른 이에게 노출될 수 있다.
* 캐시를 다루는 기본 원칙
  * 캐시되지 말아야할 문서가 있다면 표시하라
    * 문서의 소유자는 문서를 캐시할지 말아야할지 가장 잘 알고 있다.
    * 문서가 `Set-Cookie` 헤더를 제외하고 캐시를 해도 된다면 명시적으로 `Cache-Control: no-cache="Set-Cookie"`를 표시한다. 캐시를 해도 되는 문서에 `Cache-Control: public`을 사용하면 웹 대역폭을 더 절약시켜준다.
  * `Set-Cookie` 헤더를 캐시 하는 것이 유의하라
    * `Set-Cookie` 헤더를 가진 응답의 본문은 캐시할 수 있으나 `Set-Cookie` 헤더를 캐시하는 것은 주의해야 한다. 같은 `Set-Cookie` 헤더를 여러 사용자에게 보내면 사용자 추적에 실패한다.
    * 어떤 캐시는 응답 저장 전에 `Set-Cookie` 헤더를 제거하기 때문에 그 캐시 데이터를 받는 클라이언트는 `Set-Cookie` 헤더 정보 없이 데이터를 받게 되어 문제가 생길 수 있다.
    * 캐시가 모든 요청마다 원 서버와 재검사시켜 클라이언트로 가는 응답에 `Set-Cookie` 헤더 값을 기술하여 문제를 개선할 수 있다. `Cache-Control: must-revalidate, max-age=0`
  * `Cookie` 헤더를 가지고 있는 요청을 주의하라
    * 요청에 `Cookie` 헤더가 함께 오면 콘텐츠에 개인정보를 담고 있을 수 있다는 힌트다.
    * 파기 시간이 0인 `Cookie` 헤더를 설정해 매번 재검사하도록 강제하여 해결할 수 있다.

### 11.6.10 쿠키, 보안, 그리고 개인정보

* 쿠키를 비활성화 하거나 로그분석 같은 다른 방법으로 대체할 수 있으므로 그 자체가 보안상 엄청나게 위험한 것은 아니다.
* 원격 데이터베이스에 개인 정보를 저장하고 해당 데이터의 키 값을 쿠키에 저장하는 방식을 표준으로 하용하면, 클라이언트-서버 간 예민한 데이터가 오가는 것을 줄일 수 있다.
* 개인정보를 다루거나 사용자를 추적하는 기술은 잘못된 의도로 사용될 수 있으므로 항상 조심하는 것이 좋다.
  * 가장 큰 오용 중 하나는 협력업체 웹사이트가 사용자 추적을 위해 지속쿠키를 사용하는 것이다. IP 주소와 `Referer` 헤더의 정보와 함께 사용하면 꽤 정확한 사용자 데이터를 수집할 수 있다.
* 사이트 개인 정보 정책에 유의하면 쿠키 관련 위험성보다 세션 조작이나 트랜잭션상의 편리함이 더 크다.

## 11.7 추가 정보

* [MDN - Set-Cookie](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Set-Cookie)
* [MDN - Cookie](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Cookie)