## 8장 통합점: 게이트웨이, 터널, 릴레이

### 8.1 게이트웨이
: 서로 다른 프로토콜/어플레이션 간의 HTTP 인터페이스

+ 기능
  - 어플리케이션이 요청한 리소스 경로 안내
  - 동적 콘텐츠 생성 및 DB에 쿼리 전송 가능
  - HTTP 프로토콜을 다른 프로토콜로 자동 변환 가능
+ 동작 예시
  - 클라이언트가 서버에 질의 요청
  - 서버가 게이트웨이에 질의 전달
  - 게이트웨이가 DB에 질의 전송해 결과 서버로 전달
  - 서버가 클라이언트에게 결과 응답 
+ 표시
  - 웹 게이트웨이는 클라이언트와 서버 측 프로토콜을 빗금으로 구분해 기술
  - ex) 
    * HTTP/FTP 서버 측 FTP 게이트웨이
    * HTTP/CGI 서버 측 어플리케이션 게이트웨이
    * HTTP/NNTP 서버 측 게이트웨이 
    * HTTPS/HTTP 클라이언트 측 보안 게이트웨이

### 8.2 프로토콜 게이트웨이
+ 설정
  - 특정 프로토콜에 대해 설정 시 자동변환 처리 가능
  - HTTP 프로토콜도 게이트웨이 거치도록 설정 가능
    * 브라우저에서 명시적으로 게이트웨이 거치도록 설정 가능
    * 게이트웨이를 대리서버(리버스 프록시)로 설정 가능
+ HTTP/* 서버 측 웹 게이트웨이
  - 클라이언트에서 HTTP 요청이 원 서버로 들어오는 시점에 해당 요청을 다른 프로토콜로 변환
  - ex) `HTTP/FTP` 서버 측 예시
    * `USER` + `PASS` 명령 전송해 서버에 로그인
    * `CWD` 명령으로 적절한 서버 내 디렉터리로 변경 
    * 다운로드 형식을 `ASCII`로 설정
    * `MDTM` 명령으로 문서의 최근 수정시간 취득
    * `PASV` 명령으로 서버에 수동형 데이터 검색 예정 알림
    * `RETR` 명령으로 객체 검색 및 파일전송 요청
    * 제어 채널에서 반환된 포트로 FTP 데이터 커넥션 맺고 
    * 데이터 채널이 열리면 객체가 게이트웨이로 전송됨
+ **HTTP/HTTPS** 서버 측 보안 게이트웨이
  - 사용자의 모든 세션을 암호화 하여 개인정보 보호 및 보안 제공
  - ex) 클라이언트 --HTTP--> 보안게이트웨이 --HTTPS--> 서버
+ **HTTPS/HTTP** 클라이언트 측 가속 게이트웨이
  - 웹 서버의 앞단에서 보이지 않는 인터셉트 게이트웨이나 리버스 프록시 역할 맡음
  - 보안 HTTPS 트래픽 수신 및 복호화해 서버로 HTTP 요청 전송
  - 효율적인 복호화 S/W 내장해 서버 부하 절감 가능 
    * 최근에는 인프라 대부분 SSL 암/복호화 모듈 내장
    * 로드밸런스가 SSL 모듈 내장해 `HTTPS/HTTP` 게이트웨이 역할 하기도
  - but) 게이트웨이-서버 간 네트워크가 안전해야

### 8.3 리소스 게이트웨이
+ 애플리케이션 서버
  - 가장 일반적인 게이트웨이 형태 
  - 목적지 서버와 게이트웨이를 하나의 서버로 결합
  - 클라이언트의 HTTP 요청을 API를 통해 서버 상의 여러 애플리케이션으로 전달
+ CGI 
  - Common Gateway Interface
  - 최초의 서버 확장이자 가장 널리 쓰인 서버 확장 API
  - HTTP 요청에 따라 프로그램 실행, 출력수집, 응답 회신하기 위한 표준 인터페이스 집합
  - 서버와 분리되며 사용자가 내부 처리 알 수 없음 
    * 다양한 언어로 구현 가능
    * 문제가 많은 확장으로부터 서버를 보호
    * 모든 CGI 요청마다 새로운 프로세스를 만들어 부하 발생   
      => `Fast CGI`는 데몬으로 동작해 프로세스 생성/제거로 인한 부하 없음
+ 서버 확장 API
  - Application Programming Interface
  - 웹 개발자가 자신의 모듈/코드를 HTTP와 직접 연결하게 하는 인터페이스
  - ex) MS의 FPSE(FrontPage Server Extension)  
       : 클라이언트에서 전송되는 RPC(원격 프로시져 호출) 명령 인식해 웹 출판 서비스 지원  

### 8.4 애플리케이션 인터페이스
+ 특성
  - 서로 다른 형식의 웹 어플리케이션 통신에 이용
  - HTTP 헤더로 표현 어려운 정보 교환 가능 
+ 웹서비스
  - 각 웹 애플리케이션이 서로 통신하는데 사용할 표준/프로토콜 집합
  - 애플리케이션이 정보 공유하는데 사용하는 새로운 메커니즘 의미
  - HTTP 등 표준 웹 기술 위에서 개발 
  - 과거엔 SOAP 통해 XML로 정보를 교환
  - **현재는 REST 방식 및 JSON 데이터를 주로 사용**
+ [SOAP](https://www.w3.org/TR/soap12/)
  - Simple Object Access Protocol
  - HTTP 메세지에 XML 데이터 담는 방식에 관한 표준
  - W3C에서 유지/관리하는 공식 프로토콜 
+ REST
  - Representational State Transfer
  - Roy Fielding이 제안한 유연하고 가벼운 API 구조

    |조건|상세|
    |---|---|
    |Client-Server| 클라이언트, 서버, 리소스로 구성된 아키텍처 구조|
    |Stateless| 서버에 클라이언트 콘텐츠/상태 저장 안 함|
    |Cache| HTTP의 캐싱 기능 사용 가능해야|
    |Uniform Interface| 애플리케이션 종류와 무관하게 통합적 이용 가능한 표준화된 인터페이스 (핵심사항)|
    |Layered System| 클라이언트-서버 간 상호작용 계층적 조작 가능한 시스템|
    |Code on Demand | 실행 가능한 코드 전송해 클라이언트 기능 확장 가능 (선택사항)|

+ JSON vs XML

  |명칭|공통점|차이점|
  |---|---|---|
  |JSON <br>(JavaScript Object Notation)|- 자기묘사(self describing)적 <br> - 인간/기계 모두 읽을 수 있음| - 엔드태그 불필요 => 더 짧고 처리 빠름 <br> - Array 배열 사용 가능 <br> - 표준 Javascript 함수로 파싱 가능 <br> => 바로 객체화 됨|
  |XML <br> (eXtensible Markup Langugage)|- 계층적 구조 <br> - 여러 프로그래밍 언어 및 <br> XMLHttpRequest 에서 파싱 가능| - 파싱에 XML 파서 필요|

+ 참조
  - [REST API 제대로 알고 사용하기](https://meetup.toast.com/posts/92)
  - [REST와 SOAP 비교](https://www.redhat.com/ko/topics/integration/whats-the-difference-between-soap-rest)
  - [REST by Roy Fielding](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)
  - [MDN: JSON으로 작업하기](https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/JSON)
  - [JSON vs XML](https://www.w3schools.com/js/js_json_xml.asp)

### 8.5 터널
+ 특성 
  - 다른 프로토콜을 HTTP 위에 올릴 수 있음  
    * => 웹 트래픽만 허용하는 방화벽에 다른 트래픽 접근 가능 
  - HTTP가 아닌 트래픽을 HTTP 커넥션으로 전송 시 사용   
    * => HTTP 프로토콜 미지원 애플리케이션에 HTTP 애플리케이션이 접근 가능
  - HTTP의 `CONNECT` 메스드를 사용해 커넥션을 맺음
+ HTTP CONNECT 메소드  
  - 특성
    * 터널 게이트웨이가 목적 서버와 포트에 TCP 커넥션 맺고 
    * 클라이언트-서버 간 데이터를 무조건 전달하도록 요청
    * 모든 서버/프로토콜에 TCP 커넥션 맺기 가능
  - 동작 예시
    1) 클라이언트가 게이트웨이에 `CONNECT` 요청 전송
    2) 게이트웨이는 서버와 TCP 커넥션 생성
    3) 게이트웨이가 HTTP 커넥션 준비 메세지 반환
    4) 클라이언트-게이트웨이 사이에 터널 생성돼 데이터 양방향 전달 (커넥션 종료 시까지)  
  - CONNECT 요청
    * 요청 URI는 호스트 명으로 대체하고 콜론(:)에 이어 포트를 기술
    * 시작줄 다음에는 타 HTTP와 동일하게 요청 헤더 필드 존재 가능
    * 보통 각 행은 CRLF로 종료
    * 헤더 목록 끝은 빈 줄의 CRLF로 종료 
    * ex)
      ```
      CONNECT mysite.co.kr:443 HTTP/1.0
      User-agent: Mozilla/5.0
      ``` 
  - CONNECT 응답
    * `200 응답코드`는 성공을 의미
    * 편의상 응답 사유구절은 `Connection Established`로 기술
    * 일반 HTTP 응답과 달리 `Content-Type` 헤더 불필요 (Byte 그대로 전달)
    * ex) 
      ```
      HTTP/1.0 200 Connection Established
      Proxy-agent: Netscape-Proxy/1.1
      ``` 
+ 데이터 터널링
  - 터널링된 데이터는 게이트웨이에게 비가시적   
    * 패킷 순서/흐름 가정 불가  
    * 게이트웨이는 커넥션 맺는 대로 헤더 포함 모든 데이터를 서버로 전송해야
  - 터널 양 끝단은 언제든 패킷 수신하고 데이터 즉시 전달해야
    * 터널링된 프로토콜이 데이터 의존성 포함하는 경우 문제 발생
    * 터널 한쪽 끝단이 입력 데이터 무시할 수 있음 
    * 터널 한쪽 끝단이 데이터 미소비 시 다른 쪽에서 행/교착상태 발생
  - 클라이언트가 `CONNECT` 요청 후 응답 받기 전에 터널데이터 전송 가능
    * but) 게이트웨이의 처리능력 확인 필요
  - 클라이언트는 인증요구나 200 외의 응답 수신 시 요청 재전송할 수 있어야    
    * TCP 요청의 패킷 외 나머지 영역보다 큰 데이터를 파이프라인으로 전달 금지
    * 파이프라인으로 패킷 받다가 커넥션 끊기는 경우 TCP 리셋 발생 가능
    * TCP 리셋은 게이트웨이로부터 받은 응답 유실 초래 => 통신실패의 원인 인식 불가
  - 터널의 끝단 중 한쪽 커넥션이 끊기면   
    * => 끊기지 않은 쪽에서 전송된 데이터 버려짐
+ SSL 터널링
  - SSL 등 암호화된 프로토콜은 구식 필터링 라우터/프록시에서 처리 불가  
    * 터널 이용 시 SSL 트래픽을 HTTP 메세지에 담겨 방화벽 통과 가능
    * but) 악의적인 트래픽이 유입되는 경로가 될 수도 있음
  - 비교

    |HTTP/HTTPS 게이트웨이| SSL터널링|
    |---|---|
    |클라이언트-게이트웨이 사이에 일반 HTTP 사용 <br> => 낮은 보안|클라이언트-서버 사이에 SSL 세션이 적용됨|
    |프록시가 인증 담당하므로 서버에 SSL 클라이언트 인증 불가|프록시에 SSL 구현 불필요|
    |게이트웨이의 완전한 SSL 지원 필요||

+ 터널 인증
  - 프록시 인증 기능 이용해 클라이언트가 터널 사용할 권한 있는지 검증 가능
  - 동작
    * 클라이언트가 `CONNECT` 요청 전송 시 인증요구를 반환 
    * 클라이언트가 인증정보와 `CONNECT` 요청 재전송
    * 커넥션 및 터널 생성
+ 보안 이슈
  - 통신하고 있는 프로토콜이 올바른 용도로 사용하고 있는지 검증 불가  
  - 예) 게임, 악의적인 텔넷 세션 생성, 사내 이메일 차단 우회  
  => 특정 포트만 터널링 허용해야

### 릴레이
: HTTP 미준수하는 단순한 HTTP 프록시 => 한 번에 1개 홉에 데이터 전달
+ 단순 필터링/진단/콘텐츠 변환 등에 사용
+ 단순 맹목적 릴레이는 Connection헤더 처리 불가  
  => keep-alive 커넥션 이용 시 행(hang) 문제 발생 가능
