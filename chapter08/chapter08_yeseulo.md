# 8. 통합점: 게이트웨이, 터널, 릴레이

HTTP는 웹에 있는 모든 리소스에 대한 프로토콜로 사용됐으며, 애플리케이션 간에 서로 다른 프로토콜을 상호 운용하는 용도로 사용하기도 한다.

* 게이트웨이: 서로 다른 프로토콜과 애플리케이션 간의 HTTP 인터페이스다.
* 애플리케이션 인터페이스: 서로 다른 형식의 웹 애플리케이션이 통신하는 데 사용한다.
* 터널: HTTP 커넥션을 통해서 HTTP가 아닌 트래픽을 전송하는 데 사용한다.
* 릴레이: 일종의 단순한 HTTP 프락시로, 한 번에 한 개의 홉에 데이터를 전달하는 데 사용한다.

## 8.1 게이트웨이

* 웹에 더 복잡한 리소스를 올릴 필요가 생기면서 모든 리소스를 한 개의 애플리케이션으로만 처리하기 어려워졌다.
* 인터프리터 같이 리소스를 받기 위한 경로 안내 역할의 게이트웨이를 고안해냈다.
* 게이트웨이는 리소스와 애플리케이션을 연결하는 역할을 한다.
  * 애플리케이션은 게이트웨이에게 요청을 처리해달라고 할 수 있다(HTTP 또는 그 외 정의해 둔 인터페이스를 통해).
  * 게이트웨이는 그에 응답할 수 있으며, 동적인 콘텐츠를 생성하거나 데이터베이스에 질의를 보낼 수 있다.
  * 웹사이트의 서버는 데이터베이스로 가는 게이트웨이 역할을 할 수 있다. 클라이언트가 HTTP를 통해 리소스를 요청하고, 서버는 리소스를 얻기 위한 게이트웨이 인터페이스 역할을 한다.
* 게이트웨이는 HTTP 트래픽을 다른 프로토콜로 자동 변환하여, HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 한다.
* 게이트웨이의 예
  * HTTP/FTP 서버 측 FTP 게이트웨이
    * 게이트웨이는 FTP URL을 가리키는 HTTP 요청을 받아 FTP 커넥션을 맺고, FTP 서버에 적절한 명령을 전송한다.
    * 클라이언트는 적절한 HTTP 헤더와 함께 문서를 받는다.
  * HTTPS/HTTP 클라이언트 측 보안 게이트웨이
    * SSL을 통해 암호화된 웹 요청을 받고, 요청을 해독하여(게이트웨이에 해당 서버 인증서가 설치되어 있어야 함) 생성한 일반 HTTP 요청을 목적지 서버로 전달한다.
    * 이런 보안 가속기는 원 서버에 고성능 암호화 기능을 제공할 목적으로 웹 서버 바로 앞단(보통 같은 구역 내)에 위치할 수 있다.
  * HTTP/CGI 서버 측 애플리케이션 게이트웨이
    * 애플리케이션 서버 게이트웨이 API를 통해 HTTP 클라이언트를 서버 측 애플리케이션 프로그램에 연결한다.
    * 웹에서 물건을 사거나 일기예보, 주식 시세를 조회할 때 실은 애플리케이션 서버 게이트웨이를 방문하는 것이다.

### 8.1.1 클라이언트 측 게이트웨이와 서버 측 게이트웨이

* 웹 게이트웨이는 한쪽에서는 HTTP로, 다른 한쪽에서는 HTTP가 아닌 다른 프로토콜로 통신한다.
  * 상이한 HTTP 버전 사이에서 변환을 수행하는 웹 프락시는 게이트웨이와 같다. 하지만 양쪽에서 HTTP로 통신하기 때문에 기술적으로는 프락시다.
* 게이트웨이는 클라이언트 측 프로토콜과 서버 측 프로토콜을 빗금(/)으로 구분해 기술한다: `<클라이언트 프로토콜>/<서버 프로토콜>`
  * 예) HTTP 클라이언트와 NNTP 뉴스 서버 사이에서는 `HTTP/NNTP` 게이트웨이
* 게이트웨이의 역할
  * 서버 측 게이트웨이는 클라이언트와 HTTP로 통신하고, 서버와는 외래 프로토콜로 통신한다.
  * 클라이언트 측 게이트웨이는 클라이언트와 외래 프로토콜로 통신하고, 서버와는 HTTP로 통신한다.

## 8.2 프로토콜 게이트웨이

* 프락시처럼 게이트웨이에도 HTTP 트래픽을 바로 보낼 수 있다.
* 브라우저에 명시적으로 게이트웨이를 설정해 자연스레 트래픽이 게이트웨이를 거쳐 가게 하거나, 게이트웨이를 대리 서버(리버스 프락시)로 설정할 수도 있다.
* 예) 특정 URL을 모든 FTP URL에 대한 HTTP/FTP 게이트웨이로 설정했다면,
  ```
  HTTP 클라이언트 ------------------ HTTP ------------------->  웹 서버

  HTTP 클라이언트 ---- HTTP ----> HTTP/FTP 게이트웨이 <-- FTP --> FTP 서버
  ```
  * 일반적인 HTTP 트래픽에는 영향을 끼치지 않는다. 일반 HTTP 트래픽은 원 서버로 바로 보낸다.
  * FTP URL을 포함한 요청은 특정 주소의 게이트웨이로 HTTP 요청을 보낸다.
  * 게이트웨이는 클라이언트 측 요청을 FTP 요청으로 반환하여 처리한 뒤 그 결과를 클라이언트에게 HTTP로 전송한다.

### 8.2.1 HTTP/*: 서버 측 웹 게이트웨이

* 서버 측 웹 게이트웨이는 클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측 HTTP 요청을 외래 프로토콜로 전환한다.
* HTTP/FTP 게이트웨이
  * HTTP 요청을 FTP 요청으로 변환한다.
  * 게이트웨이는 원 서버의 FTP 포트로 FTP 커넥션을 연결하고 FTP 프로토콜을 통해 객체를 가져온다.
  * 게이트웨이가 하는 일
    * USER와 PASS 명령을 보내서 서버에 로그인한다.
    * 서버에서 적절한 디렉터리로 변경하기 위해 CWD 명령을 내린다.
    * 다운로드 형식을 ASCII로 설정한다.
    * MDTM으로 문서의 최근 수정 시간을 가져온다.
    * PASV로 서버에게 수동형 데이터 검색을 하겠다고 말한다.
    * RETR로 객체를 검색한다.
    * 제어 채널에서 반환된 포트로 FTP 서버에 데이터 커넥션을 맺는다. 데이터 채널이 열리는 대로, 객체가 게이트웨이로 전송된다.
  * 게이트웨이는 객체를 받는 대로 HTTP 응답에 실어 클라이언트에게 전송한다.

### 8.2.2 HTTP/HTTPS: 서버 측 보안 게이트웨이

* 기업 내부 모든 웹 요청을 암호화함으로써 개인 정보 보호와 보안을 제공하는 데 게이트웨이를 사용할 수 있다.
* 클라이언트는 일반 HTTP를 사용하여 웹을 탐색할 수 있으나 게이트웨이는 자동으로 사용자의 모든 세션을 암호화할 것이다.

### 8.2.3 HTTPS/HTTP: 클라이언트 측 보안 가속 게이트웨이

* HTTPS/HTTP 게이트웨이는 보안 가속기로 유명하다. 이는 웹 서버 앞단에 위치하고 보이지 않는 인터셉트 게이트웨이나 리버스 프락시 역할을 한다.
* 이 게이트웨이는 보안 HTTPS 트래픽을 받아서 복호화하고, 웹 서버로 보낼 일반 HTTP 요청을 만든다.
* 원 서버보다 더 효율적으로 보안 트래픽을 복호화하는 암호화 하드웨어를 내장해서 원 서버의 부하를 줄여주기도 한다.
  * 하지만 게이트웨이와 원 서버 간 암호화하지 않은 트래픽을 전송하므로, 게이트웨이와 원 서버 간에 있는 네트워크가 안전한지 확인을 확실히 하고 사용해야 한다.

## 8.3 리소스 게이트웨이

* 게이트웨이의 가장 일반적인 형태인 애플리케이션 서버는 목적지 서버와 게이트웨이를 한 개의 서버로 결합한다.
* 애플리케이션 서버는 HTTP를 통해 클라이언트와 통신하고 서버 측 애플리케이션 프로그램에 연결하는 서버 측 게이트웨이다.
* 애플리케이션 서버는 HTTP 클라이언트를 여러 백엔드 애플리케이션으로 연결한다.
  * 서버로부터 파일이 전송되는 대신, 애플리케이션 서버는 게이트웨이의 애플리케이션 프로그래밍 인터페이스(Application Programming Interface, API)를 통해서 서버에서 동작하는 애플리케이션에게 요청을 전달한다.
* 애플리케이션 게이트웨이에서 유명했던 최초의 API는 공용 게이트웨이 인터페이스(Common Gateway Interface, CGI)였다.
  * CGI는 특정 URL에 대한 HTTP 요청에 따라 프로그램을 실행하고, 프로그램 출력을 수집하고, HTTP 응답으로 회신하는데 웹 서버가 사용하는 표준화된 인터페이스 집합이다.
* 게이트웨이의 동작
  * 게이트웨이를 통해야 받을 수 있는 리소스 요청이 들어오면, 서버는 헬퍼 애플리케이션을 생성하여 요청을 처리한다.
  * 헬퍼 애플리케이션은 필요한 데이터(요청 전체 또는 사용자가 데이터베이스에서 실행시킬 질의 등)를 전달받는다.
  * 그 다음 바로 클라이언트로 전달할 응답 또는 응답 데이터를 서버에 반환한다.
  * 서버와 게이트웨이는 별개 애플리케이션이라 각각 가진 책임이 분명히 나뉜다.

### 8.3.1 공용 게이트웨이 인터페이스

* 공용 게이트웨이 인터페이스(CGI)는 최초이자 지금까지 널리 쓰이는 서버 확장이다.
  * 웹에서 동적인 HTML, 신용카드 처리, 데이터베이스 질의 등을 제공할 때 쓰인다.
* CGI 애플리케이션이 서버와 분리되면서 펄(Perl), Td, C, 다양한 셀 언어를 포함해 많은 언어로 구현할 수 있게 되었다.
* CGI는 단순하여 거의 모든 HTTP 서버가 지원한다.
* CGI가 내부에서 어떤 처리를 하는지는 사용자에게 보이지 않는다. 사용자 시각에서는 CGI가 내부적으로 일반적인 요청을 만드는 것일 뿐이다.
  * 서버와 CGI 애플리케이션 간에 진행되는 처리 단계도 감춰져 있다. URL의 'cgi' 혹은 '?'로 CGI 애플리케이션이 뭔가 하고 있다는 것을 알 수 있다.
* CGI는 거의 모든 리소스 형식과 서버의 접점에 있으면서 필요에 따라 어떤 변형이든 처리해내는 단순한 기능을 제공한다.
* 인터페이스는 문제가 많은 확장으로부터 서버를 보호한다는 점에서 훌륭하다고 할 수 있다.
* 그러나 이런 분리 때문에 성능 관련 비용이 발생한다. 모든 CGI 요청마다 새로운 프로세스를 만드는 데 부하가 꽤 크고, CGI 사용 서버의 성능을 제한하며, 서버 장비에 부담을 준다.
* 이 문제를 피하고자 새로운 CGI 형식인 Fast CGI가 개발되었다. 이는 CGI와 유사하지만 데몬으로 동작함으로써 요청마다 새로운 프로세스를 만들고 제거하면서 생기는 성능 저하 문제를 해결했다.

### 8.3.2 서버 확장 API

* CGI 프로토콜은 구동 중인 HTTP 서버에 외부 인터프리터가 쉽게 접속할 수 있게 해준다.
* 서버 자체의 동작을 바꾸고 싶거나 서버 처리 능력을 최고치로 끌어올리고자, 서버 개발자는 웹 개발자가 자신의 모듈을 HTTP와 직접 연결할 수 있는 강력한 인터페이스인 서버 확장 API를 제공한다.
* 확장 API는 프로그래머가 자신의 코드를 서버에 연결하거나 서버의 컴포넌트를 자신이 만든 것으로 교체할 수 있게 한다.
* 유명한 서버 대부분은 개발자에게 확장 API를 한 개 이상 제공한다.
* 이런 확장은 서버 자체의 아키텍처에 의존하기 때문에, 대부분 한 가지 서버 형식으로 특화되었다.
* 서버 확장의 예) 프론트페이지 제작자가 웹 출판 서비스를 하게 지원해주는 마이크로소프트의 프론트페이지 서버 확장(FrontPage Server Extension, FPSE)
  * 이는 프론트페이지 클라이언트로부터 전송되는 원격 프로시져 호출(remote procedure call, RPC) 명령을 인식할 수 있다.
  * 이 명령은 HTTP에 편승하여 온다. (특히 HTTP POST 메서드 상에 붙어서 온다) (19장 참고)

## 8.4 애플리케이션 인터페이스와 웹 서비스

* 애플리케이션을 연결하며 생기는 이슈 중 하나는 데이터를 교환하려는 두 애플리케이션 사이에서 프로토콜 인터페이스를 맞추는 일이다.
* 애플리케이션 상호 운용을 하다보면, HTTP 헤더로는 표현이 힘든 복잡한 정보를 교환하기 위해 HTTP 확장이나 HTTP 위에 프로토콜을 덧씌울 수도 있다. (19장 참고)
* 인터넷 커뮤니티는 각 애플리케이션이 서로 통신하는데 사용할 표준과 프로토콜 집합을 개발하였고, 이런 표준을 웹 서비스로 부르게 되었다. 여기서의 웹 서비스는 애플리케이션이 정보를 공유하는데 사용하는 새로운 메커니즘을 의미한다.
* 웹 서비스는 HTTP 같은 표준 웹 기술 위에서 개발한다.
* 웹 서비스는 SOAP을 통해 XML을 사용하여 정보를 교환한다.
  * XML(eXtensible Markup Language)은 데이터 객체를 담는 데이터를 생성하고 해석하는 방식을 제공한다.
  * SOAP(Simple Object Access Protocol)은 HTTP 메시지에 XML 데이터를 담는 방식에 관한 표준이다.

## 8.5 터널

* 웹 터널은 HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공한다.
* 웹 터널을 사용하면 HTTP 커넥션을 통해 HTTP가 아닌 트래픽을 전송할 수 있고, 다른 프로토콜을 HTTP 위에 올릴 수 있다.
* 웹 터널을 사용하는 가장 일반적 이유는 HTTP 커넥션 안에 HTTP가 아닌 트래픽을 전송할 수 있다.

### 8.5.1 CONNECT로 HTTP 터널 커넥션 맺기

* 웹 터널은 HTTP의 CONNECT 메서드를 사용하여 커넥션을 맺는다.
* CONNECT 프로토콜은 HTTP/1.1 명세에 자세히 나와 있지는 않지만, 많이 구현하는 확장이다.
* CONNECT 메서드는 터널 게이트웨이가 임의의 목적 서버와 포트에 TCP 커넥션을 맺고 클라이언트와 서버 간 데이터를 무조건 전달하기를 요청한다.
* CONNECT 메서드가 게이트웨이로 터널을 연결하는 방식
  1. 클라이언트는 게이트웨이에 터널을 연결하려고 CONNECT 요청을 보낸다. 클라이언트의 CONNECT 메서드는 TCP 커넥션을 위해 게이트웨이에 터널 연결을 요청한다.
  2. 443 포트로 TCP 커넥션을 열고 커넥션이 생성된다.
  3. TCP 커넥션이 맺어지면 게이트웨이는 클라이언트에게 `HTTP 200 Connection Established` 응답을 전송하여 연결됨을 알린다.
  4. 이 시점에 터널이 연결된다. HTTP 터널을 통해 전송된 클라이언트의 모든 데이터는 위에서 맺은 TCP 커넥션으로 바로 전달되며, 서버로부터 전송된 모든 데이터 역시 HTTP 터널을 통해 클라이언트에게 전달된다.
* CONNECT 메서드는 모든 서버나 프로토콜에 TCP 커넥션을 맺는데 사용할 수 있다.

#### CONNECT 요청

* CONNECT 문법은 시작줄을 제외하고 다른 HTTP 메서드와 같다.
* 요청 URI는 호스트 명이 대신하며, 콜론에 이어 포트를 기술한다.

```
CONNECT home.netscape.com:443 HTTP/1.0
User-agent: Mozilla/4.0
```

* 시작줄 다음에는 다른 HTTP 메시지와 같이 추가적인 HTTP 요청 헤더 필드가 올 수 있다.
* 보통 각 행은 CRLF로 끝나고, 헤더 목록의 끝은 빈 줄의 CRLF로 끝난다.

#### CONNECT 응답

* 클라이언트는 요청을 전송한 다음, 게이트웨이의 응답을 기다린다.
* 일반 HTTP 메시지처럼 200 응답 코드는 성공을 뜻한다. 편의상 응답의 사유 구절은 `Connection Established`로 기술된다.
  ```
  HTTP/1.0 200 Connection Established
  Proxy-agent: Netscape-Proxy/1.1
  ```
* 일반적 HTTP 응답과는 달리 `Content-Type` 헤더를 포함할 필요는 없다. 커넥션이 메시지 전달 대신 바이트를 그대로 전달하기 때문에 콘텐츠 형식을 기술할 필요가 없다.

### 8.5.2 데이터 터널링, 시간, 커넥션 관리

* 터널을 통해 전달되는 데이터는 게이트웨이에서 볼 수 없어서 게이트웨이는 패킷의 순서나 흐름에 대한 어떤 가정도 할 수 없다. 터널이 일단 연결되면, 데이터는 언제 어디로든 흘러가버릴 수 있다.
* 클라이언트는 성능을 높이기 위해 CONNECT 요청을 보낸 다음, 응답을 받기 전에 터널 데이터를 전송할 수 있다.
  * 이는 서버에 데이터를 더 빨리 보내는 방법이나, 게이트웨이가 요청에 이어 데이터를 적절하게 처리할 수 있어야 함을 전제로 한다.
  * 특히 게이트웨이는 네트워크 I/O 요청이 헤더 데이터만 반환해줄 거라 가정할 수 없어서, 커넥션이 맺어지는 대로 헤더를 포함해서 읽어들인 모든 데이터를 서버에 전송해야 한다.
  * 요청 후 터널을 통해 데이터를 전송한 클라이언트는 인증 요구(authentication challenge)나 200 외 응답이 왔을 때 요청 데이터를 다시 보낼 준비가 되어 있어야 한다.
* 터널의 끝단 어느 부분이든 커넥션이 끊어지면, 그 끊어진 곳으로부터 온 데이터는 반대편으로 전달된다. 그 다음 커넥션이 끊어졌던 터널 끝단 반대편의 커넥션도 프락시에 의해 끊어진다. 커넥션이 끊긴 한쪽에 아직 전송하지 않은 데이터는 버려진다.

### 8.5.3 SSL 터널링

* 웹 터널은 원래 방화벽을 통해 암호화된 SSL 트래픽을 전달하려고 개발되었다.
* SSL과 같이 암호화된 프로토콜은 정보가 암호화되어 있어서 낡은 방식의 프락시에서는 처리되지 않는다.
* 터널을 사용하면 SSL 트래픽을 HTTP 커넥션으로 전공하여 80 포트의 HTTP만 허용하는 방화벽을 통과시킬 수 있다.
* SSL 트래픽이 기존 프락시 방화벽을 통과할 수 있게 HTTP에 터널링 기능이 추가되었다. 이 기능은 HTTP 메시지에 암호화된 날 데이터를 담고 일반 HTTP 채널을 통해 데이터를 전송한다.
* 직접 SSL 커넥션에서는 보안 웹 서버로 SSL 트래픽이 바로 전송된다.(SSL 포트인 443으로)
* HTTP 터널을 통한 SSL에서, SSL 트래픽은 일반 SSL 커넥션을 통해 전송되기 전까지는 HTTP 메시지에 담겨 HTTP 포트인 80에 전송된다.
* 터널은 HTTP가 아닌 트래픽이 포트를 제한하는 방화벽을 통과할 수 있게 해준다. 이는 보안 SSL 트래픽이 방화벽을 통과하는 데 유용하게 사용될 수 있다. 그러나 터널은 악의적인 트래픽이 사내로 유입되는 경로가 될 수 있다.

### 8.5.4 SSL 터널링 vs HTTP/HTTPS 게이트웨이

* HTTPS 프로토콜(SSL 상의 HTTP)은 다른 프로토콜과 같은 방식으로 게이트웨이를 통과할 수 있다.
* 원격 HTTPS 서버와 SSL 세션을 시작하는 게이트웨이(클라이언트 대신)를 두고 클라이언트 측의 HTTPS 트랜잭션을 수행하는 방식이다.
* 응답은 프락시가 받아서 복호화하고 난 후, HTTP를 통해 클라이언트로 전송한다. 이는 게이트웨이가 FTP를 처리하는 방식과 같다.
  * 이 접근의 단점
    * 클라이언트-게이트웨이 사이에는 보안이 적용되지 않은 일반 HTTP 커넥션이 맺어져 있다.
    * 프락시가 인증을 담당하고 있기 때문에, 클라이언트는 원격 서버에 SSL 클라이언트 인증(X509 인증서 기반의 인증)을 할 수 없다.
    * 게이트웨이는 SSL을 완벽히 지원해야 한다.
* 이 상황에서 SSL 터널링을 사용하면 프락시에 SSL을 구현할 필요가 없다.
* SSL 세션은 클라이언트가 생성한 요청과 목적지(보안이 적용된) 웹 서버 간에 생성된다.
* 프락시 서버는 트랜잭션의 보안에 관여하지 않고 암호화된 데이터를 그대로 터널링한다.

### 8.5.5 터널 인증

* HTTP의 다른 기능들을 터널과 함께 사용할 수 있다.
* 특히 프락시 인증 기능은 클라이언트가 터널을 사용할 수 있는 권한을 검사하는 용도로 터널에서 사용할 수 있다.
* 게이트웨이는 터널 사용 허가를 내리기 전 프락시 인증을 할 수 있다.
  1. 터널은 클라이언트와 게이트웨이 사이에 놓인다.
  2. 클라이언트가 CONNECT 요청을 전송한다.
  3. 게이트웨이가 인증 요구를 반환하고 클라이언트는 적절한 인증과 함께 CONNECT 요청을 전송한다.
  4. 게이트웨이는 443 포트로 TCP 커넥션을 열고, 커넥션이 맺어지면 HTTP 커넥션 준비 메시지를 클라이언트에게 반환한다.

### 8.5.6 터널 보안에 대한 고려사항들

* 보통 터널 게이트웨이는 통신하고 있는 프로토콜이 터널을 올바른 용도로 사용하고 있는지 검증할 방법이 없다.
* 예) 회사 직원이 게임을 하기 위해 회사 방화벽에 터널을 생성하여 게임 트래픽을 사내로 유입시킬 수도 있고, 악의적 사용자가 회사에 텔넷 세션을 열거나 회사 이메일 차단 장치를 우회하려고 터널을 사용할 수 있다.
* 터널 오용을 최소화하기 위해, 게이트웨이는 HTTPS 전용 포트인 443 같이 잘 알려진 특정 포트만 터널링할 수 있게 허용해야 한다.

## 8.6 릴레이

* HTTP 릴레이는 HTTP 명세를 완전히 준수하지 않는 간단한 HTTP 프락시다.
* 릴레이는 커넥션을 맺기 위한 HTTP 통신을 한 후, 바이트를 맹목적으로 전달한다.
* HTTP는 복잡해서 모든 헤더와 메서드 로직을 수행하지 않고 맹목적으로 트래픽을 전달하는 간단한 프락시 구현 방식이 유용할 때가 있다.
* 데이터를 맹목적으로 전달하도록 구현하기는 쉬워서 단순 필터링이나 진단, 콘텐츠 변환을 하는데 사용되기도 한다. 그러나 이는 잠재적으로 심각한 상호 운용 문제를 가지고 있기 때문에 주의해서 배포해야 한다.
* 단순 맹목적 릴레이를 구현하는데 관련된 더 일반적인 문제 중 하나는, 맹목적 릴레이가 `Connection` 헤더를 제대로 처리하지 못해서 keep-alive 커넥션이 행(hang)에 걸리는 것이다.
  1. 웹 클라이언트는 `Connection: Keep-Alive` 헤더를 보내서, 릴레이에 keep-alive 커넥션을 맺기 희망한다는 요청 메시지를 전송한다. 클라이언트는 keep-alive 채널에 대한 요청이 받아들여졌는지 확인하기 위해 응답을 기다린다.
  2. 릴레이가 HTTP 요청을 받지만, `Connection` 헤더를 이해하지 못하므로, 단순히 요청을 서버로 넘긴다. `Connection` 헤더는 홉과 홉 사이(hop-by-hop)에만 사용하는 헤더다. 이는 단일 전송 링크만 지원하고 체인을 따라 전달할 수 없다. 문제는 여기서 시작된다.
  3. 릴레이 된 HTTP 요청이 웹 서버에 도착한다. 웹 서버가 프락시로부터 `Connection: Keep-Alive` 헤더를 받으면, keep-alive 요청을 받은 것으로 생각하고 `Connection: Keep-Alive` 응답 헤더로 응답한다. 이 시점부터 웹 서버는 릴레이와 함께 keep-alive 통신을 하고, keep-alive 규칙에 맞게 동작할 것이다. 하지만 릴레이는 keep-alive에 대해 아무것도 모른다.
  4. 릴레이는 웹 서버로부터 받은 `Connection: Keep-Alive` 헤더를 포함한 응답 메시지를 클라이언트에게 전달한다. 클라이언트는 이 헤더를 통해 릴레이가 keep-alive로 통신하는 것에 동의했다고 추측한다. 이 시점에 클라이언트와 서버는 keep-alive로 통신하고 있다고 믿지만, 실제로 통시하는 릴레이는 keep-alive가 무엇인지 모른다.
  5. 릴레이는 keep-alive에 대해 아무것도 모르기 때문에 원 서버가 커넥션을 끊기를 기다리며 받은 데이터 전부를 그대로 클라이언트에게 보낸다. 원 서버는 릴레이가 자신에게 커넥션을 계속 맺고 있기를 요청했다고 믿고 커넥션을 끊지 않을 것이다. 릴레이는 커넥션이 끊길 때를 기다리며 계속 커넥션을 맺고(hang) 있는다.
  6. 클라이언트가 응답 메시지를 받으면, 바로 다음 요청을 keep-alive 커넥션을 통해 릴레이에게 전송한다. 단순 릴레이는 같은 커넥션으로 또 다른 요청이 오는 것을 예측하지 못한다. 브라우저는 계속 돌지만 아무 작업도 진행되지 않는다.
* 이런 위험 예방을 위해 릴레이를 좀 더 똑똑하게 만들 수도 있으나, 프락시의 단순함 이면에는 상호 운용과 관련한 문제가 발생할 위험이 있다.
* 특정 목적을 위해 단순한 HTTP 릴레이를 구축할 때는 어떻게 사용할지 신중히 고민해야 한다. 여러 문제 예방을 위해 HTTP를 제대로 준수하는 프락시를 사용하는 게 좋다.