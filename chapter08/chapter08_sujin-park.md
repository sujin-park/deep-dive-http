# 8장 통합점: 게이트웨이, 터널, 릴레이

- 게이트웨이: 서로 다른 프로토콜과 애플리케이션 간의 HTTP 인터페이스
- 애플리케이션 인터페이스: 서로 다른 형식의 웹 애플리케이션이 통신하는 데 사용
- 터널: HTTP 커넥션을 통해 HTTP가 아닌 트래픽을 전송하는 데 사용
- 릴레이: 일종의 프락시로 한 번에 한 개의 홉에 데이터를 전달하는 데 사용

## 8.1 게이트웨이

- 게이트웨이는 리소스와 애플리케이션을 연결하는 역할
- 애플리케이션은 게이트웨이에게 요청을 처리해달라고 할 수 있고, 게이트웨이는 그에 응답 가능
- 동적인 콘텐츠 생성 및 데이터베이스에 질의 전송 가능
- ```HTTP 트래픽을 다른 프로토콜로 자동으로 변환하여, HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 하기도 함```


### 8.1.1 클라이언트 측 게이트웨이와 서버 측 게이트웨이

게이트웨이는 클라이언트 측 프로토콜과 서버 측 프로토콜을 빗금(`/`)으로 구분해 기술합니다.

```클라이언트 프로토콜/서버 프로토콜```

- 서버 측 게이트웨이는 클라이언트와 HTTP로 통신하고, 서버와는 외래 프로토콜로 통신
- 클라이언트 측 게이트웨이는 클라이언트와 외래 프로토콜로 통신하고, 서버와는 HTTP로 통신

## 8.2 프로토콜 게이트웨이

프락시에 트래픽을 보내는 것과 같이 게이트웨이에도 HTTP 트래픽을 바로 보낼 수 있습니다. 브라우저에 명시적으로 게이트웨이를 설정하여 트래픽이 게이트웨이를 지나가게 하거나, 게이트웨이를 리버스 프락시로 설정할 수도 있습니다.

### 8.2.1 HTTP/*: 서버 측 웹 게이트웨이

서버 측 웹 게이트웨이는 `클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 HTTP 요청을 외래 프로토콜로 전환`합니다.

게이트웨이는 원 서버의 FTP 포트로 FTP 커넥션을 연결하고 FTP 프로토콜을 통해서 객체를 가져올 때 다음과 같은 일을 합니다.

- USER 와 PASS 명령을 보내서 서버에 로그인
- 서버에서 적절한 디렉터리로 변경하기 위해 CWD 명령
- 다운로드 형식을 ASCII로 설정
- MDTM 으로 문서의 최근 수정 시간을 가져옴
- PASV 로 서버에게 수동형 데이터 검색을 하겠다고 말함
- RETR로 객체 검색
- 제어 채널에서 반환된 포트로 FTP 서버에 데이터 커넥션을 맺고, 데이터 채널이 열리는 대로 객체가 게이트웨이로 전송

### 8.2.2 HTTP/HTTPS: 서버 측 보안 게이트웨이

클라이언트는 일반 HTTP를 사용하여 웹을 탐색할 수 있지만, 게이트웨이는 자동으로 사용자의 모든 세션을 암호화 할 것입니다.

### 8.2.3 HTTPS/HTTP: 클라이언트 측 보안 가속 게이트웨이

`HTTPS/HTTP 게이트웨이`는 `웹 서버의 앞단에 위치하고, 인터셉트 게이트웨이나 리버스 프락시 역할`을 합니다. 게이트웨이는 보안 HTTPS 트래픽을 받아서 복호화하고, 웹 서버로 보낼 일반 HTTP 요청을 만듭니다.

**장점**

원 서버보다 더욱 효율적으로 보안 트래픽을 복호화하는 암호화 하드웨어를 내장해서 원 서버의 부하를 줄여주기도 함

**단점**

게이트웨이와 원 서버 간에 있는 네트워크가 안전한지 확인을 확실히 하고 사용해야 함

## 8.3 리소스 게이트웨이

HTTP를 통해서 클라이언트와 통신하고 서버 측에 있는 애플리케이션 프로그램에 연결하는 서버 측 게이트웨이인 `애플리케이션 서버`는 목적지 서버와 게이트웨이를 한 개의 서버로 결합합니다.

애플리케이션 게이트웨이에서 유명했던 최초의 API는 공용 게이트웨이 인터페이스(CGI)였습니다.
`CGI`는 특정 URL에 대한 HTTP 요청에 따라 프로그램을 실행하고, 출력을 수집하고, 응답으로 회신하는데 웹 서버가 사용하는 표준화된 인터페이스 집합입니다.

`게이트웨이를 통해야 받을 수 있는 리소스 요청이 들어오면`, 서버는 헬퍼 애플리케이션을 생성하여 요청을 처리합니다. 그 다음, 클라이언트로 전달할 응답이나 응답 데이터를 서버에 반환합니다.

### 8.3.1 공용 게이트웨이 인터페이스

`공용 게이트웨이 인터페이스(CGI)`는 동적 HTML, 데이터베이스 질의 등을 제공하는 데 사용합니다.

**특징**
- CGI는 거의 모든 리소스 형식과 서버의 접점에 있으면서 필요에 따라 어떤 변형이든 처리해내는 단순한 기능 제공
- 분리로 인해 성능 관련한 비용 발생
- 새로운 프로세스를 만드는 데 따르는 부하가 크고, 서버의 성능을 제한하며 서버 장비에 부담 제공

## 8.4 애플리케이션 인터페이스와 웹 서비스

`애플리케이션 인터페이스`

- 애플리케이션을 연결하면서 생기는 이슈는 데이터를 교환하려는 두 애플리케이션 사이에서 프로토콜 인터페이스를 맞추는 일
- 애플리케이션이 상호 운용하다보면 HTTP 헤더로는 표현하기 힘든 복잡한 정보를 교환해야 할 수도 있음

`웹 서비스`
- HTTP 같은 표준 웹 기술 위에서 개발하고, SOAP를 통해 XML을 사용하여 정보 교환
- XML은 데이터 객체를 담는 데이터를 생성하고 해석하는 방식 제공
- 현대 웹 서비스의 데이터 교환 방식은 SOAP 보다 REST 를 많이 사용하며, 데이터 포맷은 XML보다 JSON을 많이 사용 함

## 8.5 터널

`웹 터널`은 HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공합니다.

- HTTP 커넥션을 통해 HTTP가 아닌 트래픽 전송 가능, 다른 프로토콜을 HTTP 위에 올릴 수 있음
- 가장 일반적인 사용 예는 HTTP 커넥션 안에 HTTP가 아닌 트래픽을 얹기 위함
- 웹 트래픽만을 허용하는 방화벽이 있더라도 HTTP가 아닌 트래픽 전송 가능

### 8.5.1 CONNECT로 HTTP 터널 커넥션 맺기

웹 터널은 HTTP의 CONNECT 메서드를 사용하여 커넥션을 맺습니다.

`CONNECT` 메서드는 터널 게이트웨이가 임의의 목적 서버와 포트에 TCP 커넥션을 맺고 클라이언트와 서버 간에 오는 데이터를 무조건 전달하기로 요청합니다.

**CONNECT 메서드가 게이트웨이로 터널을 연결하는 과정**

- 클라이언트는 게이트웨이에 터널을 연결하고자 CONNECT 요청 전송
    - TCP 커넥션을 위해 게이트웨이에 터널 연결을 요청
- TCP 커넥션은 게이트웨이에서 서버로 443 포트로 커넥션을 생성
- TCP 커넥션이 맺어지면, 게이트웨이는 클라이언트에게 HTTP 200 Connection Established 응답 전송하여 연결되었음을 알림
- 터널 연결 됨
- HTTP 터널을 통해 전송된 클라이언트의 모든 데이터는 TCP 커넥션으로 전달되고, 서버로부터 전송된 모든 데이터 역시 HTTP 터널을 통해 클라이언트에게 전달 됨

`CONNECT 요청`

CONNECT 문법은 시작줄을 제외하고는 다른 HTTP 메서드와 같습니다.

```
CONNECT <호스트명>:<포트> HTTP/1.0
User-agent: Mozilla/4.0
```

시작줄 다음은 HTTP 요청 헤더 필드가 있거나 없고, 보통 각 행은 CRLF로 끝나고 헤더 목록의 끝은 빈 줄의 CRLF 로 끝납니다.

`CONNECT 응답`

클라이언트는 요청을 전송한 다음, 게이트웨이의 응답을 기다립니다. 일반 HTTP 메시지와 같이 200 응답 코드는 성공을 뜻하고, 응답에 있는 사유 구절은 `Connection Established` 로 기술됩니다.

커넥션이 메시지를 전달하는 대신 바이트를 그대로 전달하기 때문에 콘텐츠 형식을 기술하는 `Content-Type 을 포함할 필요가 없습니다.`

### 8.5.2 데이터 터널링, 시간, 커넥션 관리

**데이터 터널링**
- 터널을 통해 전달되는 데이터는 게이트웨이에서도 볼 수 없어서, 게이트웨이는 패킷의 순서나 흐름에 대한 어떤 가정도 할 수 없음

**시간**
- 성능을 높이기 위해, CONNECT 요청을 보낸 후 응답을 받기 전에 터널 데이터를 전송할 수 있음
- 게이트웨이는 커넥션이 맺어지는 대로 헤더를 포함해서 읽어들인 모든 데이터를 서버에 전송
- 요청 후에 터널을 통해 데이터를 전송한 클라이언트는 인증요구나 200 외의 응답이 왔을 때 요청을 다시 보낼 수 있어야 함

**커넥션 관리**
- 터널의 끝단 어느 부분이든 커넥션이 끊어지면, 끊어진 곳으로부터 온 데이터는 반대편으로 전달되고 커넥션이 끊어졌던 터널의 끝단 반대편의 커넥션도 프락시에 의해서 끊어질 것
- 커넥션이 끊긴 한쪽에 아직 전송하지 않은 데이터는 버려짐

### 8.5.3 SSL 터널링

`터널링`이란 `터널을 사용하면 SSL 트래픽을 HTTP 커넥션으로 전송`하여 80 포트의 HTTP만을 허용하는 방화벽을 통과시킬 수 있는 기능으로 HTTP 메시지에 암호화된 날 데이터를 담고 일반 HTTP 채널을 통해 데이터를 전송합니다.

터널은 HTTP가 아닌 트래픽이 포트를 제한하는 방화벽을 통과시킬 수 있게 해줍니다.

### 8.5.4 SSL 터널링 vs HTTP/HTTPS 게이트웨이

`원격 HTTPS 서버와 SSL 세션을 시작하는 게이트웨이를 두고 클라이언트 측의 HTTPS 트랜잭션을 수행하는 방식` 으로 게이트웨이를 통과할 수 있습니다. 이 방식은 몇 가지 단점이 있습니다. 

- 클라이언트-게이트웨이 사이에는 보안이 적용되지 않은 일반 HTTP 커넥션이 맺어져 있음
- 프락시가 인증을 담당하고 있기 때문에, 클라이언트는 원격 서버에 SSL 클라이언트 인증을 할 수 없음
- 게이트웨이는 SSL을 완벽히 지원해야 함

SSL 터널링을 사용하면, 프락시에 SSL을 구현할 필요가 없습니다.

### 8.5.5 터널 인증

HTTP의 다른 기능들은 터널과 함께 적절히 사용할 수 있는데, 그 중 `프락시 인증 기능`은 `클라이언트가 터널을 사용할 수 있는 권한을 검사하는 용도로 터널에서 사용할 수 있습니다.`

### 8.5.6 터널 보안에 대한 고려사항들

터널 게이트웨이는 통신하고 있는 프로토콜이 터널을 올바른 용도로 사용하고 있는지 검증할 방법이 없습니다.

`터널의 오용을 최소화하기 위해서`, 게이트웨이는 HTTPS 전용 포트인 443 같이 잘 알려진 특정 포트만을 터널링할 수 있게 허용해야 합니다.

## 8.6 릴레이

`HTTP 릴레이`는 커넥션을 맺기 위한 HTTP 통신을 한 다음, 바이트를 맹목적으로 전달하는 간단한 HTTP 프락시입니다.

장점
- HTTP는 복잡하기에, 맹목적으로 트래픽을 전달하는 간단한 프락시를 구현하는 방식이 유용할 때 사용할 수 있음
- 데이터를 전달하도록 구현하기 쉽기 때문에, 단순 필터링이나 진단 혹은 콘텐츠 변환을 하는데 사용하기도 함

단점
- 잠재적으로 심각한 상호 운용 문제를 가지고 있기 때문에 주의해서 배포해야 함
- 맹목적 릴레이가 Connection 헤더를 제대로 처리하지 못해서 keep-alive 커넥션이 행에 걸릴 수 있음

**Connection 헤더를 지원하지 않고 한 가지 작업만 하는 단순 맹목적 릴레이가 행에 걸리는 과정**

1. 클라이언트는 Connection: Keep-Alive 헤더를 보내서, 릴레이에 keep-alive 커넥션을 맺기를 원한다는 요청 메시지 전송하고 대기
2. 릴레이가 HTTP 요청을 받지만 Connection 헤더를 이해하지 못하고 서버에 넘김
3. 릴레이 된 HTTP 요청이 서버에 도착함.
4. 릴레이는 웹 서버로부터 받은 Connection: Keep-Alive 헤더를 포함한 응답 메시지를 클라이언트에게 전달.
5. 릴레이는 keep-alive 에 대해서 모르기 때문에, 원 서버가 커넥션을 끊기를 기다리며 받은 데이터 전부를 그대로 클라이언트에게 전달
6. 원 서버는 릴레이가 자신에게 커넥션을 계속 맺고 있기를 요청했다고 믿기 때문에 커넥션을 끊지 않고 hang 에 걸림

**여러 문제를 예방하기 위해서는 릴레이를 구축하는 것보다는 HTTP를 제대로 준수하는 프락시를 사용하는게 좋습니다.**