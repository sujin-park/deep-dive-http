# 8장 - 통합점: 게이트웨이, 터널, 릴레이

## 8.1 게이트웨이
- 모든 리소스를 한 개의 애플리케이션으로만 처리할 수 없었음
- 개발자들은 인터프리터 같이 리소스를 받기 위한 경로를 안내하는 역할을 하는 게이트웨이를 고안해냄
- 게이트웨이는 리소스와 애플리케이션을 연결하는 역할을 함
- 게이트웨이는 요청을 받고 응답을 보내는 포털 같이 동작 & 동적인 콘텐츠를 생성하거나 데이터베이스에 질의를 보낼 수 있음
- 게이트웨이는 HTTP 트래픽을 다른 프로토콜로 자동으로 변환, 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 함

### 8.1.1 클라이언트 측 게이트웨이와 서버 측 게이트웨이
- 웹 게이트웨이는 한쪽에서는 HTTP로 통신하고 다른 한쪽에서는 다른 프로토콜로 통신
- 클라이언트 측 프로토콜과 서버 측 프로토콜을 빗금으로 구분해 기술
- 서버 측 게이트웨이는 클라이언트와 HTTP로 통신하고, 서버와는 외래 프로토콜로 통신
- 클라이언트 측 게이트웨이는 클라이언트와 외래 프로토콜로 통신하고, 서버와는 HTTP로 통신

## 8.2 프로토콜 게이트웨이
- 게이트웨이에도 HTTP 트래픽을 바로 보낼 수 있음
- 브라우저에 명시적으로 게이트웨이를 설정하여 자연스럽게 트래픽이 게이트웨이를 거쳐가게 하거나, 게이트웨이를 대리 서버로 설정할 수도

### 8.2.1 HTTP/*: 서버 측 웹 게이트웨이
- 서버 측 웹 게이트웨이는 클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 HTTP 요청을 외래 프로토콜로 전환
### 8.2.2 HTTP/HTTPS: 서버 측 보안 게이트웨이
- 기업 내부의 모든 웹 요청을 암호화함으로써 개인 정보 보호와 보안을 제공하는 데 게이트웨이를 사용할 수 있음
### 8.2.3 HTTPS/HTTP: 클라이언트 측 보안 가속 게이트웨이
- 이 게이트웨이는 웹 서버의 앞단에 위치하고 보이지 않는 인터셉트 게이트웨이나 리버스 프락시 역할을 함

## 8.3 리소스 게이트웨이
- 애플리케이션 서버는 목적지 서버와 게이트웨이를 한 개의 서버로 결합함
- 서버로부터 파일이 전송되는 대신에, 애플리케이션 서버는 게이트웨이의 애플리케이션 프로그래밍 인터페이스(API)를 통해서 요청을 서버에서 동작하고 있는 애플리케이션에 전달
### 8.3.1 공용 게이트웨이 인터페이스
- 공용 게이트웨이 인터페이스(CGI)는 최초의 서버 확장이자 지금까지도 가장 널리 쓰이는 서버 확장
- CGI 애플리케이션이 서버와 분리되면서 다양한 셸 언어를 포함하여 수많은 언어로 구현할 수 있게 되었음
- CGI가 내부에서 어떤 처리를 하는지는 사용자에게 보이지 않음
- CGI는 거의 모든 리소스 형식과 서버의 접점에 있으면서 필요에 따라 어떤 변형이든 처리해내는 단순한 기능을 제공함
- 인터페이스는 문제가 많은 확장으로부터 서버를 보호한다는 점에서 훌륭
- 하지만 이런 분리 때문에 성능 관련한 비용이 발생
- 모든 CGI 요청마다 새로운 프로세스를 만드는 데 따르는 부하가 꽤 크고, CGI를 사용하는 서버의 성능을 제한하며 서버 장비에 부담을 줌
### 8.3.2 서버 확장 API
- CGI 프로토콜은 구동 중인 HTTP 서버에 외부 인터프리터가 쉽게 접속할 수 있게는 해주지만, 서버 자체의 동작을 바꾸고 싶거나 서버의 처리 능력을 최고치로 끌어올리고
싶을 때는 다른 방법이 필요했음
- 이러한 필요로 서버 확장 API이 제공됨  
- 확장 API는 프로그래머가 자신의 코드를 서버에 연결하거나 서버의 컴포넌트를 자신이 만든 것으로 교체해버릴 수 있게 하였음

## 8.4 애플리케이션 인터페이스와 웹 서비스
- 데이터를 교환하려는 두 애플리케이션 사이에서 프로토콜 인터페이스를 맞추는 일이 까다로웠음
- 인터넷 커뮤니티는 각 웹 애플리케이션이 서로 통신하는데 사용할 표준과 프로토콜 집합을 개발하였음 -> 웹 서비스
- 웹 서비스는 SOPA(Simple Object Access Protocol)을 통해 XML을 사용하여 정보를 교환

## 8.5 터널
- 웹 터널은 HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공함
### 8.5.1 CONNECT로 HTTP 터널 커넥션 맺기
- CONNECT 메서드는 터널 게이트웨이가 임의의 목적 서버와 포트에 TCP 커넥션을 맺고 클라이언트와 서버 간에 오는 데이터를 무조건 전달하기를 요청
- CONNECT 요청
    - CONNECT 문법은 시작줄을 제외하고는 다른 HTTP 메서드와 같음
    - 요청 URI는 호스트 명이 대신하며 콜론에 이어 포트를 기술
- CONNECT 응답
    - 클라이언트는 요청을 전송한 다음, 게이트웨이의 응답을 기다림
    - 일반적인 HTTP 응답과는 달리 Content-Type 헤더를 포함할 필요는 없음
### 8.5.2 데이터 터널링, 시간, 커넥션 관리
- 터널을 통해 전달되는 데이터는 게이트웨이에서 볼 수 없어서 패킷의 순서나 흐름에 대한 어떤 가정도 할 수 없음
- 클라이언트는 성능을 높이기 위해 CONNECT 요청을 보낸 다음, 응답을 받기 전에 터널 데이터를 전송할 수 있음
- 게이트웨이가 요청에 이어서 데이터를 적절하게 처리할 수 있어야 함을 전제로 함
- 게이트웨이는 네트워크 I/O 요청이 헤더 데이터만을 반환해줄 거라고 가정할 수 없어서, 커넥션이 맺어지는 대로 헤더를 포함해서 읽어들인 모든 데이터를 서버에 전송해야 함
- 요청 후에 터널을 통해 데이터를 전송한 클라이언트는 인증요구나 200 외의 응답이 왔을 때 요청 데이터를 다시 보낼 준비가 되어 있어야 함
- 터널의 끝단 어느 부분이든 커넥션이 끊어지면, 그 끊어진 곳으로부터 온 데이터는 반대편으로 전달됨
- 그 다음 커넥션이 끊어졌던 터널의 끝단 반대편의 커넥션도 프락시에 의해서 끊어질 것
- 커넥션이 끊긴 한쪽에 아직 전송하지 않은 데이터는 버려짐
### 8.5.3 SSL 터널링
- 웹 터널은 원래 방화벽을 통해서 암호화된 SSL 트래픽을 전달하려고 개발되었음
- SSL 같이 암호화된 프로토콜은 정보가 암호화되어 있기 때문에 낡은 방식의 프락시에서는 처리되지 않음
- 터널을 사용하면 SSL 트래픽을 HTTP 커넥션으로 전송하여 80 포트의 HTTP만을 허용하는 방화벽을 통과시킬 수 있음
- 하지만 터널은 악의적인 트래픽이 사내로 유입되는 경로가 될 수도 있음
### 8.5.4 SSL 터널링 vs HTTP/HTTPS 게이트웨이
- HTTP/HTTPS 게이트웨이는 FTP를 처리하는 방식과 같다
- 하지만 몇가지 단점이 있음
    - 클라이언트-게이트웨이 사이에는 보안이 적용되지 않은 일반 HTTP 커넥션이 맺어져 있음
    - 프락시가 인증을 담당하고 있기 때문에, 클라이언트는 원격 서버에 SSL 클라이언트 인증을 할 수 없음
    - 게이트웨이는 SSL을 완벽히 지원해야 함
- 이 상황에서 SSL 터널링을 사용하면, 프락시에 SSL을 구현할 필요가 없음
- SSL 세션은 클라이언트가 생성한 요청과 목적지 웹 서버 간에 생성됨
- 프락시 서버는 트랜잭션의 보안에는 관여하지 않고 암호화된 데이터를 그대로 터널링할 뿐
### 8.5.5 터널 인증
- HTTP의 다른 기능들은 터널과 함께 적절히 사용될 수 있음 - 특히 프락시 인증 기능(클라이언트가 터널을 사용할 수 있는 권한을 감시)
### 8.5.6 터널 보안에 대한 고려사항들
- 터널 게이트웨이는 통신하고 있는 프로토콜이 터널을 올바른 용도로 사용하고 있는지 검증할 방법이 없음
- 터널의 오용을 최소화하기 위해 게이트웨이는 HTTPS 전용 포트인 443 같이 잘 알려진 특정 포트만을 터널링할 수 있게 허용해야 함

## 8.6 릴레이
- HTTP 릴레이는 HTTP 명세를 완전히 준수하지는 않는 간단한 HTTP 프락시
- 릴레이는 커넥션을 맺기 위한 HTTP 통신을 한 다음, 바이트를 맹목적으로 전달함
- 구현하기가 쉬워서 단순 필터링이나 진단 혹은 콘텐츠 변환을 하는데 사용되기도 함
- 하지만 잠재적인 상호 운용 문제를 가지고 있기 때문에 주의해서 배포해야 함
- 맹목적 릴레이가 Connection 헤더를 제대로 처리하지 못해서 Keep-alive 커넥션이 행에 걸리는 문제가 있음
- 이러한 위험을 예방하기 위해 HTTP를 제대로 준수하는 프락시를 사용하는 게 좋음



