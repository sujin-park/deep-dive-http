# 17장 내용 협상과 트랜스코딩
- HTTP는 클라이언트와 서버가 사용자에게 적합한 콘텐츠를 보내도록 내용 협상 방법을 제공
- 이 방법을 이용해서 하나의 URL이 여러 가지 리소스 중 적합한 것에 대응되도록 할 수 있음
## 17.1 내용 협상 기법
- 서버에 있는 페이지들 중 어떤 것이 클라이언트에게 맞는지 판단하는 세 가지 다른 방법
    1. 클라이언트 주도 협상: 클라이언트에게 선택지를 주기
    2. 서버 주도 협상: 서버가 자동으로 판단
    3. 투명한 협상: 중개자에게 선택하도록 부탁
    
## 17.2 클라이언트 주도 협상
- 서버 입장에서 가장 구현하기 쉽고 최선의 사본이 선택될 것
- 단점은 각 페이지에 두 번의 요청이 필요하다는 것
- 클라이언트에게 줄 선택지를 표현하는 두 가지 방법
    1. 여러 가지 버전에 대한 링크와 각각에 대한 설명이 담긴 HTML 페이지를 돌려주기 
       - 클라이언트 브라우저는 이러한 응답을 받아 링크와 함께 페이지를 보여주거나 사용자가 결정을 하도록 하기 위해 대화창을 띄울 것
       - 결정은 브라우저 사용자에 의해 수동으로 클라이언트 쪽에서 행해짐
    2. 300 Multiple Choices 응답 코드로 HTTP/1.1 응답을 돌려주기
- 여러 개의 URL을 요구한다는 단점이 있음

## 17.3 서버 주도 협상
- 클라이언트는 반드시 자신의 무엇을 선호하는지에 대한 충분한 정보를 (클라이언트의 요청 헤더로) 서버에게 주어야 함
- HTTP 서버가 사용하는 메커니즘
    - 내용 협상 헤더들을 살펴봄(Accept 관련 헤더들)
    - 내용 협상 헤더 외의 다른 헤더들을 살펴봄
    
### 17.3.1 내용 협상 헤더
- Accept: 서버가 어떤 미디어 타입으로 보내도 되는지 알려줌 - 엔터티 헤더의 Content-Type
- Accept-Language: 서버가 어떤 언어로 보내도 되는지 - 엔터티 헤더의 Content-Language 
- Accept-Charset: 서버가 어떤 차셋으로 보내도 되는지 - 엔터티 헤더의 Content-Type
- Accpet-Encoding: 서버가 어떤 인코딩으로 보내도 되는지 - 엔터티 헤더의 Content-Encoding
- HTTP는 상태가 없는 프로토콜이기 때문에 클라이언트는 자신의 선호 정보를 반드시 매 요청마다 보내야 함

### 17.3.2 내용 협상 헤더의 품질값
- HTTP 프로토콜은 클라이언트가 각 선호의 카테고리마다 여러 선택 가능한 항목을 선호도와 함께 나열할 수 있도록 품질값을 정의하였음
- 서버가 클라이언트의 선호에 대응하는 문서를 하나도 갖고 있지 않을 때 문서를 고치거나 트랜스코딩할 수 있음

### 17.3.3 그 외의 헤더들에 의해 결정
- User-Agent와 같은 클라이언트의 다른 요청 헤더들을 이용해 알맞은 요청을 만들어내려고 시도할 수도
- 최선에 가까운 대응을 찾아낼 수 있는 q값 메커니즘은 없음
- 캐시는 반드시 캐시된 문서의 올바른 '최선의' 버전을 제공해주려 해야 하기 때문에, HTTP 프로토콜은 서버가 응답에 넣어 보낼 수 있는 Vary 헤더를 정의

## 17.4 투명 협상
- 중개자 프락시가 클라이언트와의 메시지 교환을 최소화하는 동시에 서버 주도 협상으로 인한 부하를 서버에서 제거
- 서버는 클라이언트의 요청에 가장 잘 맞는 것이 무엇인지 판별하려면 어떤 요청 헤더를 검사해야 하는지 프락시에게 말해줄 수 있어야 함

### 17.4.1 캐시와 얼터네이트
- 콘텐츠를 캐시하는 것은 그 콘텐츠가 나중에 재사용될 것이라고 예상하기 때문
- 캐시는 클라이언트에게 올바로 캐시된 응답을 돌려주기 위해, 서버가 응답을 돌려줄 때 사용했던 의사결정 로직의 상당 부분을 그대로 사용해야 함

### 17.4.2 Vary 헤더
- HTTP Vary 응답 헤더는 서버가 문서를 선택하거나 커스텀 콘텐츠를 생성할 때 고려한 클라이언트 요청 헤더 모두를 나열함
- Vary 헤더가 존재한다면, 그 Vary 헤더가 명시하고 있는 헤더들은 새 요청과 오래된 캐시된 요청에서 그 값이 서로 맞아야만 함

## 17.5 트랜스코딩
- 트랜스코딩: 서버가 클라이언트의 요구에 맞는 문서를 갖고 있지 않을 때 클라이언트가 사용할 수 있는 무언가로 변환하는 것
- 가상의 트랜스코딩
    - HTML 문서 -> WML 문서
    - 고해상도 이미지 -> 저해상도 이미지
    - 64K색 이미지 -> 흑백 이미지
    - 프레임을 포함한 복잡한 페이지 -> 프레임이나 이미지가 없는 단순한 텍스트 페이지
    - 자바 애플릿이 있는 HTML 페이지 -> 자바 애플릿이 없는 페이지
    - 광고가 있는 페이지 -> 광고가 없는 페이지
    
### 17.5.1 포맷 변환
- 데이터를 클라이언트가 볼 수 있도록 한 포맷에서 다른 포맷으로 변환하는 것

### 17.5.2 정보 합성
- 정보 합성: 문서에서 정보의 요점을 추출하는 것

### 17.5.3 콘텐츠 주입
- 내용 주입 트랜스코딩: 양을 늘리는 또 다른 종류의 변환
- 예: 자동 광고 생성과 사용자 추적 시스템

### 17.5.4 트랜스코딩 vs 정적으로 미리 생성해놓기
- 트랜스코딩의 대안은 웹 서버에서 웹페이지의 여러 가지 사본을 만드는 것

## 17.6 다음 단계
- 내용 협상에 대한 이야기는 다음 두 가지 이유로 Accept나 Content 관련 헤더들에서 끝나지 않음
1. HTTP의 내용 협상은 성능 제약을 초래
   - 적절한 콘텐츠를 위해 여러 배리언트를 탐색하는 것이나, 가장 잘 맞는 것을 추측하려는 것은 비용이 클 수 있음
   - RFC 2295와 2296은 간소화되었으며 내용 협상 프로토콜에 집중할 수 있는 방법이 있는지 질문을 던짐
2. HTTP는 내용 협상이 필요한 유일한 프로토콜이 아님
    - 미디어 스트리밍과 팩스는 클라이언트와 서버가 클라이언트의 요청에 대한 최적의 답을 하기 위해 논의해야 할 필요가 있는 두 가지 다른 예
    


    

    