# 17장 내용 협상과 트랜스코딩

## 17.1 내용 협상 기법

서버에 있는 페이지들 중 어떤 것이 클라이언트에게 맞는지 판단하는 세 가지 다른 방법이 있습니다.

| 기법 | 어떻게 동작하는가 | 장점 | 단점
|---|:---:|:---:|:---:|
| `클라이언트 주도` | 클라이언트가 요청 보내면, 서버는 클라이언트에게 선택지를 보내주고, 클라이언트가 선택 | 서버 입장에서 구현하기 쉬움 | 대기시간 증가
| `서버 주도` | 서버가 클라이언트의 요청 헤더를 검증해서 어떤 버전을 체크할지 결정 | 클라이언트 주도보다 빠름 | 헤더에 맞는 것이 없으면, 서버는 추측을 해야 함
| `투명` | 주로 프락시 캐시가 서버를 대신하여 협상 | 웹 서버가 협상을 할 필요 없음 | 투명 협상에 대한 정형화된 명세가 없음

## 17.2 클라이언트 주도 협상

`클라이언트 주도 협상`은 서버가 클라이언트 요청을 받았을 때 가능한 페이지의 목록을 응답으로 돌려주어 클라이언트가 보고 싶은 것을 선택하게 하는 것입니다.

**장점**

- 서버 입장에서 가장 구현하기 쉽고, 최선의 사본이 선택될 것

**단점**

- 각 페이지에 두 번의 요청이 필요하다는 것 (한 번은 목록을 얻고, 두 번째는 선택한 사본을 얻는 것)


서버에게는 클라이언트에게 줄 선택지를 표현하는 두 가지 방법이 있습니다.

1. 여러 버전에 대한 링크와 설명이 담긴 HTML 페이지를 반환
2. 300 Multiple Choices 응답 코드로 HTTP/1.1 응답을 반환


## 17.3 서버 주도 협상

HTTP 서버가 클라이언트에게 보내줄 적절한 응답을 계산하기 위해 사용하는 메커니즘은 두 가지가 있습니다.

- 내용 협상 헤더
- 내용 협상 헤더 외 다른 헤더

### 17.3.1 내용 협상 헤더

| 헤더 | 설명
|---|:---:|
| `Accept` | 서버가 어떤 미디어 타입으로 보내도 되는지 알려줌
| `Accept-Language` | 서버가 어떤 언어로 보내도 되는지 알려줌
| `Accept-Charset` | 서버가 어떤 차셋으로 보내도 되는지 알려줌
| `Accept-Encoding` | 서버가 어떤 인코딩으로 보내도 되는지 알려줌

`내용 협상 헤더`들은 클라이언트와 서버가 선호 정보를 서로 교환하고 문서들의 여러 버전 중 하나를 선택하는 것을 도와, 클라이언트의 선호에 가장 잘 맞는 문서를 제공해 주기 위한 목적으로 사용됩니다.

| Accept 관련 헤더들 | 엔터티 헤더
|---|:---:|
| `Accept` | Content-Type
| `Accept-Language` | Content-Language
| `Accept-Charset` | Content-Type
| `Accept-Encoding` | Content-Encoding

- HTTP는 상태가 없는 프로토콜이기 때문에 클라이언트는 자신의 선호 정보를 반드시 매 요청마다 보내야 합니다.
- 만약 어떤 두 클라이언트가 자신이 이해할 수 있는 언어를 지정한 Accept-Language 헤더 정보를 보낸다면, 서버는 어떤 사본을 각 클라이언트에게 돌려줘야 할지 판단할 수 있습니다.
- `클라이언트 주도 모델` 에서 협상을 위해 메시지가 수차례 오가는 것으로 인해 발생했던 커뮤니케이션 대기시간을 줄여줍니다.

### 17.3.2 내용 협상 헤더의 품질값

클라이언트가 각 선호의 카테고리마다 여러 선택 가능한 항목을 선호도와 함께 나열할 수 있도록 `품질값`을 정의합니다.

```
Accept-Language: en;q=0.5, fr;q=0.0, nl;q=1.0, tr;q=0.0
```

`q값`은 가장 낮은 선호도 0.0부터 가장 높은 선호도 1.0까지의 값을 가질 수 있습니다.

### 17.3.3 그 외의 헤더들에 의해 결정

**User-Agent**

서버는 또한 User-Agent와 같은 클라이언트의 다른 요청 헤더들을 이용해 알맞은 요청을 하려고 시도할 수 있습니다.

**Vary**

Vary 헤더는 캐시에게 서버 응답의 최선의 버전을 결정하기 위해 요청 헤더를 참고하고 있는지 말해줍니다. 

### 17.3.4 아파치의 내용 협상

여러 가지 버전으로 제공해 주려고 한다면 콘텐츠 제공자가 버전에 해당하는 파일들을 아파치 서버의 적절한 디렉터리에 넣어주어야 합니다. 그 후, 아래의 방법 중 내용 협상을 동작시킬 수 있습니다.

- variant를 갖는 웹 사이트의 각 URI를 위한 type-map 파일을 만듭니다. type-map 파일은 모든 배리언트와 각각에 대응하는 내용 협상 헤더들을 나열합니다.
- 아파치가 디렉터리에 대해 자동으로 type-map 파일을 생성하도록 하는 지시어를 켭니다.

### 17.3.5 서버 측 확장

마이크로소프트의 액티브 서버페이지 (ASP)와 같이 서버에서 확장을 하는 방법이 있습니다.

## 17.4 투명 협상

`투명 협상`은 클라이언트 입장에서 협상하는 프락시를 둠으로써 클라이언트와 메시지 교환을 최소화하는 동시에 서버 주도 협상으로 인한 부하를 제거합니다.

### 17.4.1 캐시와 얼터네이트(alternate)

- 캐시는 클라이언트에게 올바른 응답을 돌려주기 위해, 서버가 응답을 돌려줄 때 사용했던 로직을 상당부분 사용해야 합니다.
- 캐시는 반드시 모든 요청을 서버에게 전달하고 모든 응답을 저장해야 합니다.
캐시는 같은 URL에 대해 두 개의 다른 문서를 갖게 된다.
- 서버와 마찬가지로 캐시는 같은 URL에 대해 두 개의 다른 문서를 갖게 되는데, 이 다른 버전은 배리언트(variant)나 얼터네이트(alternate)라고 합니다.

### 17.4.2 Vary 헤더

- Vary 응답 헤더는 클라이언트 요청 헤더 모두를 나열합니다.
- 캐시가 문서를 클라이언트에게 제공해 주기 전에, 캐시는 반드시 캐시된 응답 안에 서버가 보낸 Vary 헤더가 있는지 확인해야 합니다.
- Vary 헤더가 존재한다면, Vary 헤더가 명시하고 있는 헤더들이 새 요청과 오래된 캐시 요청 값과 일치해야 합니다.

만약 서버의 Vary 헤더가 이렇다면, User-Agent 와 Cookie 값이 많은 variant 를 만들어 낼 것입니다. 
```
Vary: User-Agent, Cookie
```

- 캐시는 각 배리언트마다 알맞은 문서 버전을 저장해야 하는데, 캐시가 검색 할 때 먼저 내용 협상 헤더로 콘텐츠를 맞춰보고, 그 다음 요청의 배리언트를 캐시된 배리언트와 맞춰봅니다.
- 만약 맞는 것이 없으면, 캐시는 문서를 서버에서 가져옵니다.

## 17.5 트랜스코딩

`트랜스코딩`이란 서버가 클라이언트의 요구에 맞는 문서를 아예 갖고 있지 않다면 서버는 기존의 문서를 클라이언트가 사용할 수 있는 무언가로 변환할 수 있는 방법입니다.

**가상의 트랜스코딩**
| 전 | 후
|---|:---:|
| `HTML 문서` | WML 문서
| `고해상도 이미지` | 저해상도 이미지
| `64K색 이미지` | 흑백 이미지
| `프레임을 포함한 복잡한 페이지` | 프레임이나 이미지가 없는 단순한 텍스트 페이지
| `자바 애플릿이 있는 HTML 페이지` | 자바 애플릿이 없는 페이지
| `광고가 있는 페이지` | 광고가 없는 페이지


트랜스코딩에는 `포맷 변환, 정보 합성, 내용 주입`이 있습니다.

### 17.5.1 포맷 변환

- 데이터를 클라이언트가 볼 수 있도록 포맷을 변환하는 것입니다.
- 내용 협상 헤더에 의해 주도되고, 내용 변환 혹은 트랜스코딩은 콘텐츠 인코딩이나 전송 인코딩과는 다릅니다.
- 콘텐츠를 특정 접근 장치에서 볼 수 있도록 하기 위한 것입니다.

### 17.5.2 정보 합성

- 문서에서 정보의 요점을 추출하는 것입니다.
- e.g) 제목에 기반한 문서의 개요 생성 또는 페이지 광고 및 로고 제거

### 17.5.3 콘텐츠 주입

- 일반적인 트랜스코딩은 일반적으로 웹 문서의 양을 줄이지만, 오히려 양을 늘리는 또 다른 종류입니다.
- e.g) 자동 광고 생성, 사용자 추적 시스템

### 17.5.4 트랜스코딩 vs 정적으로 미리 생성해놓기

`트랜스코딩의 대안 - 정적으로 미리 생성해놓기`

웹 서버에서 웹페이지의 여러 가지 사본을 만드는 것입니다.

**단점**
- 페이지에 대한 수정, 더 많은 공간, 프로그래밍의 복잡도가 증가합니다.
- 광고 삽입과 몇몇 트랜스코딩은 정적인 방법으로는 수행될 수 없습니다.

## 17.6 다음 단계

내용 협상은 아래 두 가지 이유로 Accept나 Content 관련 헤더들에서 끝나지 않습니다.

- HTTP 내용 협상은 성능 제약을 초래합니다. 적절한 콘텐츠를 위해 여러 배리언트를 탐색하는 것이나, 가장 잘 맞는 것을 추측하려는 것은 비용이 클 수 있습니다.
- HTTP는 내용 협상이 필요한 유일한 프로토콜이 아닙니다. 