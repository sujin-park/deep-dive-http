- 하나의 URL로 여러 리소스에 대응할 필요가 있는 경우가 있음
- HTTP는 클라이언트/서버가 판단을 할 수 있도록 내용 협상(content-negotiation)방법을 제공
    - 이를 이용해 하나의 URL에 여러 리소스 중 하나를 선택할 수 있음.
    - 리소스의 서로 다른 버전을 배리언트(variant)라고 함

## 17.1 내용 협상 기법

- 서버에 있는 페이지 중 어떤 것이 클라이언트에게 맞는지 판단하는 방법 3가지
    1. 클라이언트 주도(Client-driven) 협상
    2. 서버 주도(Server-driven 협상
    3. 투명한(Transparent) 협상

## 17.2 클라이언트 주도 협상

- 동작 방식:
    - 서버는 클라이언트 요청에 대해 선택지를 주고 클라이언트가 선택
    - 요청에 대한 선택지 전달 방법 2가지:
        - 각 버전에 대한 링크와 설명이 담긴 HTML → 브라우저 사용자에 의해 수동으로 결정
        - `300 Multiple Choices` 응답 코드로 응답
- 장점:
    - 서버 입장에서 구현이 가장 쉬움
    - 클라이언트가 선택하므로 가장 적절한 것이 선택 됨(적절한 목록을 줬다면)
- 단점:
    - 각 페이지에 두번의 요청 필요해(1. 목록 얻기, 2. 목록 중 선택한 사본 얻기) 대기시간 증가

## 17.3 서버 주도 협상

- 동작 방식:
    - 클라이언트는 선호 정보를 서버에게 전달하고 서버는 요청을 보고 어떤 것을 제공할지 선택
        - 응답 계산을 위해 사용 하는 메커니즘:
            1. 내용 협상 헤더(Accept 관련 헤더)를 보고 결정
            2. 내용 협상 외 헤더(예: User-Agent)를 보고 결정 
- 장점:
    - 클라이언트 주도 협상보다 빠름.
- 단점:
    - 헤더에 맞는 적절한 것이 없으면 서버는 추측해야 함.
- 그 외:
    - 서버가 다운 스트림 장치에게 요청이 어떻게 평가되는지 말해줄 수 있도록 `Vary` 헤더 제공

### 17.3.1 내용 협상 헤더

- 클라이언트는 아래 헤더를 이용하여 자신의 선호 정보 전송
    - `Accept`: 서버가 어떤 미디어 타입으로 보내도 되는지
    - `Accept-Language`: 서버가 어떤 언어로 보내도 되는지
    - `Accept-Charset`: 서버가 어떤 차셋(Charset)으로 보내도 되는지
    - `Accept-Encoding`: 서버가 어떤 인코딩으로 보내도 되는지
- 위 헤더는 엔터티 헤더와 비슷하지만, 목적이 다름
    - 엔터티 헤더: 메시지를 전송시 필요한 메시지 본문의 속성
    - 내용 협상 헤더: 선호 정보 교환 및 적절한 문서 제공을 위해 사용
- Accept 관련 헤더와 엔터티 헤더와 짝
    - `Accept` ↔ `Content-Type`
    - `Accept-Language` ↔ `Content-Language`
    - `Accept-Charset` ↔ `Content-Type`
    - `Accept-Encoding` ↔ `Content-Encoding`
- HTTP는 상태가 없으므로(stateless) 선호 정보를 매 요청시마다 보내야 함.

### 17.3.2 내용 협상 헤더의 품질 값

- HTTP는 클라이언트 선호에 대한 설명을 품질값(quality value, q값)을 이용해 전달할 수 있는 메커니즘 제공

```
Accept-Language: en;q=0.5, fr;q=0.0, nl;q=1.0; tr;q=0.0
```

- 엔터티 헤더의 품질값과 동일하게 0.0(낮은 선호)~1.0(높은 선호)값을 가짐
- 선호에 대응하는 문서가 없을 수도 있으므로, 서버는 선호에 맞추기 위해 문서를 고치거나 트랜스 코딩할 수 있음

### 17.3.3 그 외의 헤더들에 의해 결정

- 서버는 `User-Agent` 와 같은 클라이언트의 다른 요청 헤더를 이용해 응답을 만들 수 있음
    - 예: 오래된 웹 브라우저는 자바스크립트를 지원하지않으므로 없는 버전의 페이지 전송
- 이 경우 q 값 메커니즘은 없으므로 서버는 정확한 대응을 찾아내거나 갖고 있는 것을 제공
- 캐시는 캐시된 문서의 올바른 최선의 버전을 제공해야 하기 때문에, HTTP 프로토콜을 서버가 응답을 넣어 보낼 수 있는 `Vary` 헤더 정의
    - `Vary` 헤더: 응답의 최선의 버전을 결정하기 위해 어떤 요청 헤더를 참고해야하는지 안내

### 17.3.4 아파치의 내용 협상

- 아파치 웹 서버가 내용 협상을 지원하는 방법
    - 웹 사이트 디렉터리에서 배리언트(variant)를 갖는 웹 사이트의 각 URI를 위한 type-map 파일 생성. 그 파일은 모든 배리언트와 각각에 대응하는 내용 협상 헤더 나열
    - 아파치가 디렉터리에 자동으로 type-map을 생성하도록 하는 MultiViews 지시어 켜기

***type-map 파일 사용하기***

1. 서버 설정 파일에 type-map 파일을 명시 

    ```
    AddHandler type-map .var // .var 확장자 파일이 type-map 파일임
    ```

2. type-map 파일 작성

    ```
    URI: joes-hardware.html

    URI: joes-hardware.en.html
    Content-type: text/html
    Content-language: en

    URI: joes-hardware.fr.de.html
    Content-type: text/html;charsett=iso-8859-2
    Contentt-language: fr, de
    ```

    - 품질값 지원은 [아파치 서버 문서 참조](http://httpd.apache.org/docs/2.4/content-negotiation.html)

***MultiViews 사용하기***

- MultiView를 켜키:
    - `access.conf` 파일에 적절한 절(<Directory>, <Location>, <Files>)에 Option 지시어를 이용해 웹사이트를 포함한 디렉터리에
- 자동 type-map 생성:
    - MultiViews가 켜져있을 때, joes-hardware 라는 이름의 리소스를 요청 했다면, 서버는 이름에 'joes-hardware' 가 들어있는 모든 파일을 살펴보고 그들에 대한 type-map 파일 생성
    - 이름에 근거해 서버는 각 파일에 대응하는 적절한 내용 협상 헤더를 추측
        - 예: fr이 들어간 파일이면 프랑스어 버전으로 추측

### 17.3.5 서버 측 확장

- 마이크로소프트의 ASP(액티브 서버 페이지)와 같이 서버에서 확장하는 방법이 있음. 8장 참조

## 17.4 투명 협상

- 동작 방식:
    - 투명한 중간장치(주로 프락시 캐시)가 서버를 대신해 협상
    - 프락시는 클라이언트 요청을 보고 요구사항을 파악할 수 있는 것으로 간주
    - 서버는 협상하려면 `Vary` 헤더를 통해어떤 헤더를 검사해야하는지 프락시에게 안내
- 장점:
    - 클라이언트와의 메시지 교환을 최소화 하는 동시에, 서버 주도 협상으로 인한 부하 제거
    - 클라이언트 주도 협상보다 빠름
- 단점:
    - 투명 협상을 어떻게 하는지에 대한 정형화된 명세 없음

### 17.4.1 캐시와 얼터네이트(alternate)

- 캐시는 같은 URL에 대해 두 개 이상(예: 프랑스어 버전과 스페인어 버전)의 문서를 가질 수 있음
    - 이 다른 버전을 배리언트(variant)나 얼터네이트(alternate)라고 부름
- 내용 협상: 배리언트 중 가장 클라이언트 요청에 맞는 것을 선택하는 과정

### 17.4.2 Vary 헤더

- 캐시는 올바른 캐시된 응답을 돌려주기 위해, 서버가 응답을 돌려줄 때 사용한 의사결정 로직을 거의 그대로 사용해야 함
- 서버의 판단이 `User-Agent` 와 같이 Accept 이외의 헤더에 기초할 수 있으므로 캐시는 어떤 헤더를 기반으로 파악했는지 알아야 함
- `Vary` 응답 헤더: 판단에 근거한 요청 헤더 모두(일반적인 내용 협상 헤더 + a)를 나열
- 새 요청이 도착 했을 때, 캐시는 `Vary` 헤더가 있는지 확인해야 함
    - `Vary` 헤더가 있다면, 거기에서 명시한 헤더들은 새 요청과 캐시된 요청의 값이 같아야 함
- 투명 협상을 구현하기 위해 캐시는 반드시 캐시된 배리언트(variant)와 함께 클라이언트 요청헤더와 그에 맞는 서버 응답 헤더 모두 저장해야 함
    - 예를 들어 `Vary: User-Agent, Cookie` 라면 매우 많은 배리언트가 생성됨

## 17.5 트랜스코딩

- 트랜스 코딩: 서버가 클라이언트의 요구에 맞는 문서가 없을 때, 기존 문서를 변환하여 제공하는 것
- 트랜스 코딩에는 포맷 변환, 정보 합성, 내용 주입의 세 종류가 있음

### 17.5.1 포맷 변환

- 포맷변환(Format Conversion): 데이터가 클라이언트가 볼 수 있도록 특정 포맷으로 변환하는 것
    - 예: HTML 문서→WML 문서, 고해상도 이미지 → 저해상도 이미지
- 내용 협상헤더에 의해 주도됨. `User-Agent` 헤더에 의해 주도될 수도 있음
- 내용 변환/트랜스코딩이 콘텐츠 인코딩/전송 인코딩과 다름을 주의
    - 내용 변환/트랜스코딩 → 특정 접근 장치에서 볼 수 있도록 하기 위함
    - 인코딩/전송 인코딩 → 콘텐츠의 효율적인, 안전한 전송

### 17.5.2 정보 합성

- 정보 합성(information synthesis): 문서에서 정보의 요점을 추출하는 것
    - 예: 각 절의 제목에 기반하여 문서 개요 생성, 페이지에서 광고나 로고 제거
- 해당 기술을 사용하여 다른 곳에서도 사용 가능
    - 포털 사이트의 웹페이지 디렉터리와 같은 자동화된 웹 페이지 분류시스템 등

### 17.5.3 콘텐츠 주입

- 콘텐츠 주입(Content Injection): 웹 문서의 양을 늘리는 종류의 트랜스 코딩
    - 포맷 변환, 정보 합성은 웹 문서의 양을 줄임
    - 예: 자동 광고 생성, 사용자 추적 시스템
- 이런 종류의 트랜스코딩은 동적으로 이루어짐

### 17.5.4 트랜스코딩 VS 정적으로 미리 생성해놓기

- 트랜스 코딩의 대안은 웹 서버에서 웹 페이지의 사본을 여럿 만드는 것
    - 예: 서버에서 HTML과 WML, 고화질과 저화질 이미지 모두 가지고 있는 것
- 정적으로 미리 생성하는 것은 현실적인 기법은 아님
    1. 많은 버전 유지를 위한 많은 저장 공간 필요, 작은 변화에 많은 수정, 관리 문제 등
    2. 동적으로 수행되는 광고 삽입 등은 정적으로 수행될 수 없음
- 대신 트랜스 코딩은 콘텐츠 제공에 있어 대기시간이 증가 함.
    - 몇 계산이나 변환은 외부로 넘겨 웹 서버의 부담을 줄이는 방법이 있음

## 17.6 다음 단계

- 내용 협상은 Accept나 Content 관련 헤더만으로 끝나지 않음
    1. HTTP 내용 협상은 성능 제약 초래. 
    2. HTTP는 내용 협상이 필요한 유일한 프로토콜이 아님