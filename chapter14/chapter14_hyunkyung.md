# 14장 보안 HTTP

## 14.1 HTTP를 안전하게 만들기
- 보다 중요한 트랜잭션을 위해서는 HTTP와 디지털 암호화 기술을 결합해야 함
- HTTP의 보안 버전은 효율적이고, 이식성이 좋아야 하고, 관리가 쉬워야 하며, 현실 세계의 변화에 대한 적응력이 좋아야 한다.
- 또한 사회와 정부의 요구사항에도 맞아야 함
- 이것들이 필요
    - 서버 인증 - 클라이언트는 자신이 위조된 서버가 아닌 진짜와 이야기하고 있음을 알 수 있어야 함
    - 클라이언트 인증 - 서버는 자신이 가짜가 아닌 진짜 사용자와 이야기하고 있음을 알아야 함
    - 무결성 - 데이터 위조로부터 안전
    - 암호화 - 도청에 대한 걱정없이 대화할 수 있어야 함
    - 효율 - 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야 함
    - 편재성 - 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 함
    - 관리상 확장성 - 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 함
    - 적응성 - 현재 알려진 최선의 보안 방법을 지원해야 함
    - 사회적 생존성 - 사회의 문화적, 정치적 요구를 만족시켜야 함
    
### 14.1.1 HTTPS
- HTTPS를 사용할 때, 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화 됨
- HTTPS는 HTTP의 하부에 전송 레벨 암호 보안 계층을 제공함으로써 동작, 이 보안 계층은 안전 소켓 계층(Secure Sockets Layer, SSL) 혹은 그를 계승한 전송 계층 보안(Transport Layer Security, TLS)을 이용하여 구현됨
- 어려운 인코딩 및 디코딩 작업은 대부분 SSL 라이브러리 안에서 일어나기 때문에, 보안 HTTP를 사용하기 위해 웹 클라이언트와 서버가 프로토콜을 처리하는 로직을 크게 변경할 필요는 없음
- 대부분의 경우, TCP 입력/출력 호출을 SSL 호출로 대체하고, 보안 정보를 설정하고 관리하기 위한 몇 가지 호출을 추가하기만 하면 됨

## 14.2 디지털 암호학
- 암호: 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
- 키: 암호의 동작을 변경하는 숫자로 된 매개변수
- 대칭키 암호 체계: 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
- 비대칭키 암호 체계: 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
- 공개키 암호법: 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
- 디지털 서명: 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- 디지털 인증서: 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

### 14.2.1 비밀 코드의 기술과 과학
- 암호법은 메시지 인코딩과 디코딩에 대한 과학이자 기술
### 14.2.2 암호(cipher)
- 암호란 메시지를 인코딩하는 어떤 특정한 방법과 나중에 그 비밀 메시지를 디코딩하는 방법
- 텍스트(평문): 인코딩되기 전의 원본 메시지
- 암호문: 암호가 적용되어 코딩된 메시지

###14.2.3 암호 기계
###14.2.4 키가 있는 암호
- 디코딩 과정을 바르게 동작시키려면 올바른 키를 암호 기계에 입력할 필요가 있음
- 암호 키는 하나의 암호 기계를 여러 가상 암호 기계의 집합처럼 만들어 줌

###14.2.5 디지털 암호
- 디지털 계산의 도래로 인한 발전
    - 속도 빨라짐 복잡한 인코딩과 디코딩 알고리즘이 가능
    - 매우 큰 키를 지원, 복잡하고 많은 조합이 가능해짐
    
##14.3 대칭키 암호법
- 인코딩을 할 때 사용하는 키가 디코딩할 때 같다
- 잘 알려진 대칭키 암호 알고리즘 DES, Triple-DES, RC2, RC4

###14.3.1 키 길이와 열거 공격
- 열거공격: 무차별로 모든 키 값을 대입해보는 공격
- 키의 길이가 길고 가능한 키 값이 많다면 깨기가 어려움

###14.3.2 공유키 발급하기
- 대칭키 암호의 단점: 발송자와 수신자가 서로 대화하려면 둘 다 공유키를 가져야 함
- 관리자 입장에서 비밀키를 관리하는 것은 어려움

##14.4 공개키 암호법
- 공개키 암호 방식은 두 개의 비대칭 키를 사용
- 하나는 호스트의 메시지를 인코딩하기 위한 것, 다른 하나는 그 호스트의 메시지를 디코딩하기 위한 것
- 인코딩 키는 모두를 위해 공개되어 있음 but 호스트만이 개인 디코딩 키를 알고있음
- 키의 분리는 메시지의 인코딩은 누구나 할 수 있도록 해주는 동시에, 메시지를 디코딩하는 능력은 소유자에게만 부여
###14.4.1 RSA
- 악당이 아래 내용을 알고 있다 하더라도 개인 키를 계산할 수 없어야 함
    - 공개키
    - 가로채서 얻은 암호문의 일부
    - 메시지와 그것을 암호화한 암호문
    
###14.4.2 혼성 암호 체계와 세션 키
- 공개키 암호 방식의 알고리즘은 계산이 느린 경향이 있음
- 실제로는 대칭과 비대칭 방식을 섞은 것이 쓰임
- 노드들 사이의 안전한 의사소통 채널을 수립할 때는 공개키 암호를 사용 -> 이 채널을 통해 임시의 무작위 대칭 키 생성, 교환 -> 이후의 나머지 데이터를 암호화할 때는 빠른 대칭키를 사용

##14.5 디지털 서명
###14.5.1 서명은 암호 체크섬이다
- 서명은 메시지를 작성한 저자가 누군지 알려줌
- 서명은 메시지 위조를 방지
- 디지털 서명은 보통 비대칭 공개키에 의해 생성됨
- 개인 키는 오직 소유자만이 알고 있기 때문에, 저자의 개인 키는 일종의 '지문'처럼 사용됨
##14.6 디지털 인증서
- 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고 있음
###14.6.1 인증서의 내부
- 디지털 인증서의 내부
  - 대상의 이름
  - 유효 기간
  - 인증서 발급자
  - 인증서 발급자의 디지털 서명
  
- 대상의 공개키도 담고있음
###14.6.2 X.509 v3 인증서
- 오늘날 사용되는 대부분의 인증서는 X.509라 불리는 표준화된 서식에 저장하고 있음

###14.6.3 서버 인증을 위해 인증서 사용하기
- 사용자가 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져옴
- 만약 서버가 인증서를 갖고 있지 않다면, 보안 커넥션은 실패함
- 서버 인증서가 갖고 있는 필드
  - 웹 사이트의 이름과 호스트 명
  - 웹 사이트의 공개키
  - 서명 기관의 이름
  - 서명 기관의 서명
  
- 브라우저가 인증서를 받으면, 서명 기관을 검사
- 만약 그 기관이 공공이 신뢰할만한 서명 기관이라면 브라우저는 그것의 공개키를 이미 알고 있을 것이며 그 서명을 검증할 수 있음
- 만약 서명 기관이 모르는 곳이라면, 브라우저는 사용자가 서명 기관을 신뢰하는지 확인하기 위한 대화상자를 보여줌

##14.7 HTTPS의 세부사항
- HTTPS는 HTTP의 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것
###14.7.1 HTTPS 개요
- 암호화되지 않은 HTTP 메시지를 TCP를 통해 전 세계의 인터넷 곳곳으로 보내는 대신에 HTTPS는 HTTP 메시지를 먼저 그것들을 암호화하는 보안 계층으로 보냄
###14.7.2 HTTPS 스킴
- 오늘날 보안 HTTP는 선택적 -> 우리는 웹 서버에게 HTTP의 보안 프로토콜 버전을 수행한다고 말해줄 방법이 필요
- 이것은 URL의 스킴을 통해 이루어짐(https)
- 만약 URL이 https 스킴을 가지고 있다면, 클라이언트는 서버에 443번 포트로 연결하고 서버와 바이너리 포맷으로 된 몇몇 SSL 보안 매개변수를 교환하면서 
  '핸드셰이크'를 하고, 암호화된 HTTP 명령이 뒤를 이음
  
- 만약 SSL과 HTTP 트래픽 모두가 80번 포트로 도착한다면, 대부분의 웹브라우저는 바이너리 SSL 트래픽을 잘못된 HTTP로 해석하고 커넥션을 닫을 것
###14.7.3 보안 전송 셋업
- HTTPS에서, 클라이언트는 먼저 웹 서버의 443으로 연결
- 일단 TCP 연결이 되고 나면, 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화
- 핸드셰이크가 완료되면 SSL 초기화는 완료되며, 클라이언트는 요청 메시지를 보안 계층에 보낼 수 있음
- 이 메시지는 TCP로 보내지기 전에 암호화 됨
###14.7.4 SSL 핸드셰이크
- 핸드셰이크에서 일어나는 일
  - 프로토콜 버전 번호 교환
  - 양쪽이 알고 있는 암호 선택
  - 양쪽의 신원 인증
  - 채널을 암호화하기 위한 임시 세션 키 생성
  
###14.7.5 서버 인증서
- 오늘날, 클라이언트 인증서는 웹 브라우징에선 흔히 쓰이지 않음
- 대부분의 사용자는 개인 클라이언트 인증서를 갖고 있지도 않음
- 한편, 보안 HTTPS 트래낵션은 항상 서버 인증서를 요구함
###14.7.6 사이트 인증서 검사
- 넷스케이프가 제안한 웹 서버 인증서 검사를 위한 알고리즘
  - 날짜 검사
    - 먼저, 브라우저는 인증서가 여전히 유효함을 확인하기 위해 인증서의 시작 및 종료일을 검사
  - 서명자 신뢰도 검사
    - 누구나 인증서를 생성할 수 있지만, 몇몇 CA(Certificate Authority, CA)는 인증서 지원자의 신원 및 사업의 선량함을 입증하는 알기 쉬운 절차를 갖춘, 잘 알려진 기관
  - 서명 검사
    - 한번 서명 기관이 믿을 만하다고 판단하면, 브라우저는 서명기관의 공개키를 서명에 적용하여 그의 체크섬과 비교해봄으로써 인증서의 무결성을 검사
  - 사이트 신원 검사
    - 대부분의 브라우저는 인증서의 도메인 이름이 대화 중인 서버의 도메인 이름과 비교하여 맞는지 검사
  
###14.7.7 가상 호스팅과 인증서
- 몇몇 인기 있는 웹 서버 프로그램은 오직 하나의 인증서만을 지원
- 만약 사용자가 인증서의 이름과 정확히 맞지 않는 가상 호스트 명에 도착했다면 경고 상자가 나타날 것

##14.9 프락시를 통한 보안 트래픽 터널링
- 클라이언트가 서버로 보낼 데이터를 서버의 공개키로 암호화하기 시작했다면, 프락시는 더 이상 HTTP 헤더를 읽을 수 없음
- 그리고 만약 프락시가 HTTP 헤더를 읽을 수 없다면, 프락시는 요청을 어디로 보내야 하는지 알 수 없게 됨
- 이를 해결하기 위한 기법 중 하나: HTTPS SSL 터널링 프로토콜
  - 클라이언트는 먼저 프락시에게 자신이 연결하고자 하는 안전한 호스트와 포트를 말해줌
  - 클라이언트는 이 내용을 프락시가 읽을 수 있도록 암호화가 시작되기 전의 평문으로 말해줌
  
- HTTP는 CONNECT라 불리는 새로운 확장 메서드를 이용해서 평문으로 된 종단정보를 전송하기 위해 사용됨
- CONNECT 메서드는 프락시에게 희망하는 호스트와 포트번호로 연결을 해달라고 말해주며, 그것이 완료되면, 클라이언트와 서버 사이에서 데이터가 직접적으로 오갈 수 있게 해주는 터널을 만듦
- CONNECT 메서드는, 안전한 원 서버의 호스트 명과 포트를 콜론으로 구분된 형태로 제공하는, 한 줄로 된 텍스트 명령

