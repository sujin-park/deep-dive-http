# 14장 보안 HTTP

## 14.1 HTTP 를 안전하게 만들기

다음을 제공해 줄 수 있는 HTTP 보안 기술이 필요합니다.
- 서버 인증 : 클라이언트가 자신이 위조된 서버가 아닌 서버와 통신하고 있다는 것을 알야아 합니다.
- 클라이언트 인증 : 서버는 자신이 가짜가 아닌 진짜 사용자와 통신하고 있다는 것을 알아야 합니다.
- 무결성 : 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 합니다.
- 암호화 - 클라이언트와 서버는 도청에 대한 걱정없이 서로 대화할 수 있어야 합니다.
- 효율 : 저렴한 클라이언트나 서버도 이용할 수 있도록 충분히 빨라야 합니다.
- 편재성 : 프로토콜은 모든 클라이언트와 서버에서 지원되어야 합니다.
- 관리상 확장성 : 즉각적인 보안 통신을 어디서든 누구든 할 수 있어야 합니다.
- 적응성 : 현재 알려진 최선의 보안 방법을 지원해야 합니다.
- 사회적 생존성 : 사회의 문화적, 정치적 요구를 만족시켜야 합니다.

### 14.1.1 HTTPS

웹페이지에 HTTP가 아닌 HTTP로 접근하고 있는 경우, URL이 http:// 대신 `https://` 로 시작하는 것을 볼 수 있습니다.

HTTP를 사용할 때,
- HTTP 요청과 응답 데이터는 네트워크로 보내지기 전 암호화
- HTTP 하부에 전송 레벨 암호 보안 계층을 제공함으로써 동작
    - 안전 소켓 계층(SSL), 전송 계층 보안(TLS)를 이용하여 구현
    - 어려운 인코딩 및 디코딩은 SSL 안에서 일어나기 때문에, 보안 HTTP 를 사용하기 위해 클라이언트와 서버가 프로토콜을 처리하는 로직을 신경 쓸 필요 없음

![다운로드](https://user-images.githubusercontent.com/29244798/104731643-5dbc0b80-577f-11eb-9e4f-32e007609d3f.png)

[사진 출처](https://icarus8050.tistory.com/29)
## 14.2 디지털 암호학

- 암호 : 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
- 키 : 암호의동작을 변경하는 숫자로 된 매개변수
- 대칭키 암호 체계 : 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
- 비대칭키 암호 체계 : 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
- 공개키 암호법 : 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
- 디지털 서명 : 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- 디지털 인증서 : 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보


### 14.2.2 암호

`암호`란 메시지를 인코딩하는 어떤 특정한 방법과 나중에 그 비밀 메시지를 디코딩하는 방법

인코딩되기 전의 원본 메시지를 텍스트 또는 평문이라고 불리고, 암호가 적용되어 코딩된 메시지는 보통 암호문이라고 불립니다.

### 14.2.3 암호 기계

암호는 상대적으로 간단한 알고리즘으로 시작했는데, 사람이 직접 인코딩하고 디코딩해야 했기 때문입니다. 기술이 진보하면서, 사람들은 보다 복잡한 암호로 메시지를 빠르고 정확하게 인코딩하고 디코딩하는 기계를 만들기 시작했습니다.

### 14.2.4 키가 있는 암호

`암호 매개변수`를 키라고 부릅니다. 암호 키는 하나의 암호 기계를 여러 가상 암호 기계의 집합처럼 만들어줍니다.
오늘날 거의 대부분의 암호 알고리즘은 키를 사용합니다.

### 14.2.5 디지털 암호

평문 메시지 P, 인코딩 함수 E, 디지털 인코딩 키 e가 주어지면 부호화된 암호문 C를 생성할 수 있습니다. 암호문 C를 디코더 함수 D와 디코딩 키 d를 사용해서 원래의 평문 P로 도로 디코딩할 수 있습니다.

## 14.3 대칭키 암호법

많은 디지털 암호 알고리즘은 `대칭키 암호`라 불리는데, 인코딩을 할 때 사용하는 키와 디코딩을 할 때 사용하는 키가 같기 때문입니다.
1. 대칭키 암호는 통신을 위해 비밀 키를 똑같이 공유할 필요가 있습니다. 발송자는 공유된 비밀 키로 메시지를 암호화하고, 암호문을 수신자에게 발송합니다.
2. 수신자는 암호문을 받아서 키로 평문을 복원하기 위해 사용합니다.

대중적인 대칭키 암호 알고리즘은 DES, Triple-DES, RC2, RC4 등이 있습니다.

### 14.3.1 키 길이와 열거 공격

무차별로 키 값을 대입해보는 공격을 `열거 공격`이라고 합니다. 가능한 키 값의 개수는 키가 몇 비트이며 얼마나 많은 키가 유효한지에 달려있습니다.

평범한 대칭키 암호에서 40비트 키는 빠른 워크스테이션에게는 쉽게 깨질 수 있고 128비트 키는 사용한 대칭키 암호는 매우 강력한 것으로 간주됩니다.

### 14.3.2 공유키 발급하기

대칭키 암호의 단점은 발송자와 수신자가 서로 대화하려면 `둘 다 공유키를 가져야 한다는 것`입니다. N개의 노드가 있고, 각 노드가 상대 N-1 과 대화를 나누어야 한다면, 대략 총 N * N 개의 비밀키가 필요합니다.

## 14.4 공개키 암호법

`공개키 암호 방식`은 두 개의 비대칭 키를 사용합니다.
하나는 호스트의 메시지를 인코딩하고, 다른 하나는 메시지를 디코딩하기 위한 것으로 인코딩 키는 모두 공개 되어있지만 디코딩 키는 개인만 알고 있습니다.

서버에 공개 키만 있으면 되서 서버가 안전하게 메시지를 발송하는 것을 더 쉽게 해줍니다.

> 대칭키 암호 방식

![다운로드 (1)](https://user-images.githubusercontent.com/29244798/104731855-a8d61e80-577f-11eb-8e7b-40ddc18f3506.png)

[사진 출처](https://cryptocat.tistory.com/2)
### 14.4.1 RSA

- 공개키
- 네트워크를 스누핑해서 암호문의 일부 획득
- 메시지와 그것을 암호화한 암호문

위와 같은 모든 항목을 만족하는 공개키 암호 체계 중 유명한 것은 RSA 데이터 시큐리티에서 상용화된 `RSA 알고리즘`

### 14.4.2 혼성 암호 체계와 세션 키

`비대칭 공개 암호 방식`은 누구나 공개키만 알면 키에 대응되는 공개 서버에 안전하게 메세지를 보낼 수 있습니다. 공개키 암호 방식의 알고리즘은 계산이 느린 경향이 있습니다.

## 14.5 디지털 서명

`디지털 서명`은 메시지를 암호화하고 해독하는 것뿐 아니라, 누가 메시지를 썼는지 메시지가 위조되지 않았음을 증명하기 위해 메시지에 서명을 하도록 하는 데에 이용될 수 있습니다.

### 14.5.1 서명은 암호 체크섬이다

두 가지 이점
- 서명은 메시지를 작성한 저자를 알 수 있음
    - 메시지를 작성한 저자만이 개인 키를 가지고 있기 때문에 본인만 계산 가능
- 서명은 메시지 위조를 방지
    - 공격자가 송신 주인 메시지를 수정했다면, 체크섬은 더 이상 그 메시지와 맞지 않게 될 것
    - 체크섬은 저자의 비밀 개인 키에 관련되어 있기 때문에, 침입자는 날조할 수 없음

## 14.6 디지털 인증서

`디지털 인증서`는 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고 있습니다.

### 14.6.1 인증서의 내부

디지털 인증서에는 `인증 기관`에 의해 디지털 서명된 정보의 집합이 담겨 있습니다.

**기본 항목**
- 대상의 이름
- 유효 기간
- 인증서 발급자
- 인증서 발급자의 디지털 서명

디지털 인증서는 대상과 사용된 서명 알고리즘에 대한 서술적인 정보와 대상의 공개키를 담고 있습니다.

<img width="582" alt="스크린샷 2021-01-15 오후 11 04 21" src="https://user-images.githubusercontent.com/29244798/104736245-03727900-5786-11eb-8d84-0e2d2b8490fb.png">

### 14.6.2 X.509 v3 인증서

대부분의 인증서가 정보를 X.509라 불리는 표준화된 서식에 저장하고 있습니다.
`X.509 v3 인증서`는 인증 정보를 파싱 가능한 필드에 넣어 구조화하는 표준화된 방법을 제공합니다.

| 필드 | 설명 |
|---|:---:|
| `버전` | 인증서 버전의 번호 |
| `일련번호` | 인증기관에 의해 생성된 고유한 정수 |
| `서명 알고리즘 ID` | 서명을 위해 사용되는 알고리즘 |
| `인증서 발급자` | 인증서를 발급하고 서명한 기관의 이름 |
| `유효 기간` | 인증서가 유효한 기간 |
| `대상의 이름` | 인증서에 기술된, 사람이나 조직과 같은 엔티티 |
| `대상의 공개 키 정보` | 인증 대상의 공개 키 |
| `발급자의 고유 ID` | 인증서 발급자에 대한 선택적인 고유한 식별자 |
| `대상의 고유 ID ` | 인증 대상에 대한 선택적인 고유한 식별자 |
| `확장` | 선택적인 확장 필드의 집합버전 |
| `인증기관 서명` | 인증기관의 디지털 서명, 명시된 서명 알고리즘을 사용 |

### 14.6.3 서버 인증을 위해 인증서 사용하기

HTTP를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져오고 서버가 인증서를 갖고 있지 않다면 보안 커넥션을 실패합니다.

서버 인증서가 가지고 있는 필드
- 웹 사이트의 이름과 호스트 명
- 웹 사이트의 공개키
- 서명 기관의 이름
- 서명 기관의 서명

브라우저는 인증서를 받으면, 서명 기관을 검사하고 신뢰할 수 없는 브라우저라면 사용자가 서명 기관을 신뢰하는지에 대한 메시지를 노출합니다.

## 14.7 HTTPS의 세부사항

`HTTPS`는 웹 기반 전자상거래의 고속 성장을 이끄는 주력으로 분산된 웹 애플리케이션의 광역 보안 관리에 있어 중요합니다.

### 14.7.1 HTTPS 개요

`HTTPS는 보안 전송 계층을 통해 전송되는 HTTP`입니다. HTTP 메시지를 TCP로 보내기 전에 먼저 그것들을 암호화하는 보안 계층으로 보냅니다.

### 14.7.2 HTTPS 스킴

- 보안이 없는 일반적인 HTTP URL의 스킴 접두사는 `http`입니다.

    http://github.io

- 보안이 되는 HTTPS 프로토콜에서 URL 스킴 접두사는 `https`입니다.

    https://github.io

클라이언트는 웹 리소스에 대한 트랜잭션 수행을 요청받으면 URL의 스킴을 검사합니다.

- `http 스킴을 갖고 있다면`, 서버에 80번 포트로 연결하고 HTTP 명령을 전송
- `https 스킴을 갖고 있다면`, 서버에 443번 포트로 연결하고 서버와 바이너리 포맷으로 된 몇몇 SSL 보안 매개변수를 교환하면서 `핸드셰이크`를 하고, 암호화된 HTTP 명령이 뒤를 잇습니다.

### 14.7.3 보안 전송 셋업

**암호화되지 않은 HTTP 트랜잭션**

1. 서버의 80 포트로 TCP 커넥션 수립
2. TCP를 통해 보내진 HTTP 요청
3. TCP를 통해 보내진 HTTP 응답
4. TCP 커넥션 닫힘

**암호화된 HTTPS 트랜잭션**

1. 서버의 443 포트로 TCP 커넥션 수립
2. SSL 보안 매개변수 핸드셰이크
3. SSL을 통해 보내진 HTTP 요청/TCP를 통해 보내진 암호화된 요청
4. SSL을 통해 보내진 HTTP 응답/TCP를 통해 보내진 암호화된 응답
5. SSL 닫힘 통지
6. TCP 커넥션 닫힘

### 14.7.4 SSL 핸드셰이크

암호화된 HTTP 메시지를 보낼 수 있게 되기 전에, 클라이언트와 서버는 SSL 핸드셰이크를 할 필요가 있습니다.

- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원을 인증
- 채널을 암호화하기 위한 임시 세션 키 생성

**SSL 핸드셰이크**

1. 클라이언트가 암호 후보들을 보내고 인증서 요구
2. 서버는 선택된 암호와 인증서 전송
3. 클라이언트가 비밀정보 생성. 클라이언트와 서버는 키를 생성
4. 클라이언트와 서버는 서로에게 암호화를 시작한다고 말해줌

### 14.7.5 서버 인증서

`서버 인증서`는 조직의 이름, 주소, 서버 DNS 도메인 이름, 그 외의 정보를 보여주는 X.509 v3에서 파생된 인증서입니다.

사용자와 사용자의 클라이언트 소프트웨어는 모든 것이 믿을 만한 것인지 확인하기 위해 인증서를 검증할 수 있습니다.


### 14.7.6. 사이트를 인증서 검사

SSL 자체는 사용자에게 웹 서버 인증서를 검증할 것을 요구하지는 않지만, 최신 웹 브라우저들은 대부분 기본적인 검사를 합니다.

- 날짜 검사

    인증서의 유효함을 확인하기 위해 `시작 및 종료일` 검사

- 서명자 신뢰도 검사

    모든 인증서는 서버를 보증하는 인증 기관(Certificate Authority, CA)에 의해 서명되어 
    있습니다.

    여러 가지 수준의 인증서가 있는데, 브라우저가 알려져 있지 않은 인증기관으로부터 `서명된 인증서를 받았다면, 보통 경고를 보여줍니다`.

- 서명 검사

    서명 기관이 믿을 만하다고 판단하면, 브라우저는 서명기관의 공개키를 서명에 적용해 체크섬과 비교해서 인증서의 무결성 검사

- 사이트 신원 검사

    대부분의 브라우저는 인증서의 도메인 이름이 대화 중인 서버의 도메인 이름과 비교하여 맞는지 검사

    몇몇 CA는 서버 이름의 목록이나 서버 이름들에 대한 와일드카드 표현이 들어있는 인증서를 생성


### 14.7.7 가상 호스팅과 인증서

가상 호스트(하나의 서버에 여러 호스트 명)로 운영되는 사이트의 보안 트래픽을 다루는 것은 까다로운 경우가 많습니다. 몇몇 인기 있는 웹 서버 프로그램은 오직 하나의 인증서만을 지원합니다.

## 14.8 진짜 HTTPS 클라이언트

`SSL`은 복잡한 바이너리 프로토콜입니다. 몇 가지 SSL 클라이언트와 서버 프로그래밍을 쉽게 만들어주는 상용 혹은 오픈 소스 라이브러리들이 존재합니다.

### 14.8.1 OpenSSL

`OpenSSL`은 **SSL과 TLS의 가장 인기 있는 오픈 소스 구현**입니다.
OpenSSL 프로젝트는 강력한 다목적 암호법 라이브러리인 동시에 SSL 과 TLS 프로토콜을 구현한 강건하고 완전한 기능을 갖춘 상용 수준의 툴킷을 개발하고자 협업한 결과물입니다.

## 14.9 프락시를 통한 보안 트래픽 터널링

클라이언트가 서버로 보낼 데이터를 서버의 공개키로 암호화하기 시작했다면, **프락시는 더 이상 HTTP 헤더를 읽을 수 없고** 프락시는 요청을 어디로 보내야 하는지 알 수 없게 됩니다.

HTTPS가 프락시와도 잘 동작할 수 있게 하기 위해, 사용하는 기법 중 하나인 `HTTPS SSL 터널링 프로토콜`입니다.

- HTTP는 CONNECT라 불리는 확장 메서드를 이용하여 평문으로 된 종단 정보를 전송하기 위해 사용됩니다.

- CONNECT 메서드는 프락시에게 희망하는 호스트와 포트번호로 연결해달라고 하며, 완료되면 터널을 만듭니다.

- CONNECT 메서드는 호스트:포트에 뒤이어 HTTP 버전 문자열과 CRLF가 순서대로 옵니다.

    `CONNECT 호스트:포트 HTTP버전CRLF`

    <SSL로 암호화된 데이터가 이 다음..>

    ```
    CONNECT home.netscape.com:443 HTTP/1.0
    User-agent: Mozilla/1.1N
    ```

요청의 빈 줄 다음에, 클라이언트는 프락시로부터 응답을 기다리고 프락시는 요청을 평가하여 유효하고 커넥션을 요청할 수 있도록 허가를 받았는지 확인합니다.

모든 것이 적법하다면 프라시는 서버로 연결하고 성공하면 `200 Connection established`를 보냅니다.

```
HTTP/1.0 200 Connection established
Proxy-agent: Netscape-Proxy/1.1
```
