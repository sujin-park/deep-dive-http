## 14장 보안 HTTP

### HTTP 보안 요건
+ 보안성

  |명칭|상세|
  |---|---|
  |서버/클라이언트 인증 | 서버-클라이언트가 위조되지 않았음을 증명 가능|
  |무결성 | 서버-클라이언트의 데이터 위조 방지|
  |암호화 | 서버-클라이언트 간 통신의 도청 방지|

+ 효율성  
  : 저렴한 기기도 이용 가능하도록 알고리즘 속도 빨라야
+ 이식성/편재성(Ubiquity)  
  : 거의 모든 기기에서 지원 가능해야
+ 관리 확장성  
  : 누구든/어디서든 즉각적인 보안통신 가능해야
+ 적응성  
  : 알려진 최신/최선의 보안방식 지원
+ 사회적 생존성  
  : 사회의 문화/정치적 요구 충족 필요

### HTTPS 개요
+ 개요
  - 가장 인기있는 HTTP 보안 방식
  - 넷스케이프에서 개척
  - 모든 주류 브라우저/서버가 지원
  - 프로토콜이나 자물쇠 모양 보안아이콘으로 확인 가능
+ 보안계층
  - HTTPS는 모든 요청/응답 데이터를 전송 전 암호화
  - HTTP와 TCP 사이에 보안계층을 제공 => 계층 내에서 인/디코딩 처리
  - 보안계층은 SSL(Secure Sockets Layer)이나 TLS(Transport Layer Security) 로 구현하지만 SSL로 통칭  
    * [현재는 TLS가 SSL을 대체 (출처: MDN)](https://developer.mozilla.org/ko/docs/Glossary/SSL)

### 디지털 암호학
+ 암호(cipher)  
  : 메세지를 특정 방법으로 인코딩/디코딩해 열람자 제한하는 것    
  - 평문: 암호화 안 된 원본 텍스트
  - 인코딩: 평문 -> 암호문
  - 디코딩: 암호문 -> 평문  
+ 키  
  : 암호의 인코딩/디코딩 동작 설정하는 매개변수
+ 디지털 암호
  : 디지털 키 값을 이용하는 암호 <-> 기계식 암호 (i.e. 에니그마 암호기계)

### 대칭키 암호법
: 인코딩/디코딩에 동일키 사용하는 알고리즘
+ 방식
  - 발신/수신자가 동일한 비밀키를 공유 (=공유키)
  - 인코딩/디코딩에 해당 비밀키를 사용
+ 알고리즘
  - DES
  - Triple-DES
  - RC2
  - RC4 
+ 특성
  - 열거공격(Enumeration Attack: 가능한 모든 키값 시도)에 취약
  - 키값이 길수록 더 많은 시도 필요 => 보안성 증가  
  - 발신-수신자 쌍마다 공유키 발급 => 관리부담 증가

### 공개키 암호법
: 공개키(공개된 인코딩키) + 비밀키(비공개된 개인 디코딩키) 사용하는 암호화 방식
+ 알고리즘
  - RSA: MIT에서 발명되어 RSA 데이터 시큐리티에서 상용화 
+ 특성
  - 서버의 공개키만 알면 암호화된 메세지 발송 가능
  - PKI(Public-Key Infra)를 통해 기술 표준화  
  - [ 공개키 + 타겟 암호문 + 임의의 평문 + 임의의 평문 인코딩값 ] 알아도 개인키 계산 어려워야 보안성 보장 가능
  - 알고리즘 계산이 느린 편 => 혼성 암호체계 사용 
    * 공개키 암호 채널에서 대칭키 생성 후 대칭키 암호 사용해 효율성 증대

### 디지털 서명
: 메세지의 위변조 여부 입증하는 암호 체크썸
+ 방식
+ 특성
  - 보통 비대칭 공개키 암호화 방식으로 생성
  - 보통 개인키는 소유자만 인지 => 식별수단으로 사용 가능
  - 소유자만 체크썸 계산 가능 => 체크썸을 서명처럼 사용 가능
+ 과정
  - 메세지 정제(=길이값 고정) -> 요약 생성 -> 서명함수에 요약 + 개인키 적용 -> 체크썸 생성
  - 메세지 발송 시 체크썸 추가해 전송
  - 수신노드가 역함수에 체크썸 + 공개키 적용 -> 위변조 확인용 요약 생성 -> 요약 비교 

### 디지털 인증서
: 신뢰 가능한 기관에 의해 서명 및 검증된 신원확인 정보
+ X.509 v3 인증서  
  : 일반적으로 사용되는 디지털 인증서 서식 표준 [(RFC5280)](https://tools.ietf.org/html/rfc5280)  
+ 필드
  - 인증서 정보
    * 인증서 포맷 버전 번호
    * 인증서 일련번호
    * 인증서 서명 알고리즘 정보
    * 유효기간
  - 인증대상 정보
    * 대상의 이름(개인/서버/조직 등)
    * 대상의 공개키
    * 대상의 고유 ID (선택)
  - 인증발급자 정보
    * 인증서 발급자 (CA, Certificate Authorities)
    * 인증서 발급자의 고유 ID (선택)
  - 기타 확장 정보
    * 기본제약: 인증대상과 인증기관과의 관계
    * 인증서 정책: 인증서를 승인한 정책
    * 키 사용: 공개키의 사용방식 제한 
  - 디지털 서명  
    : 나머지 모든 필드에 대한 인증기관의 디지털 서명 (디지털 서명 알고리즘으로 생성) 

### HTTPS 세부사항
+ 스킴
  - 접두사: https://
  - 기본포트: 443
+ 보안전송 셋업
  - 443 포트로 TCP 커넥션 수립
  - SSL 핸드셰이크 (보안 매개변수/교환 키 협상하며 초기화)
  - SSL을 통해 암호화 된 메세지 전송
  - SSL 닫힘 통지
  - TCP 커넥션 종료
+ SSL 핸드셰이크
  - 프로토콜 버전 번호 교환
  - 클라이언트가 암호 후보 전송 및 인증서 요구
  - 서버가 선택한 암호 및 인증서를 전송
  - 클라이언트가 비밀정보 전송 
  - 클라이언트-서버가 키 생성 
  - 클라이언트-서버가 서로에게 암호화 시작 알림 
+ 서버 인증서
  - HTTPS로 접속시 브라우저가 서버로부터 자동으로 취득 및 검증
  - 서버 인증서 없는 경우 HTTPS 연결 실패
  - 브라우저에 내장되지 않은 기관의 서명인 경우 신뢰여부 묻는 대화상자 표시
  - 보안 이메일, 인트라넷에서 접근제어 위해 사용하기도
  - X.509 v3에서 파생
  - 필드 
    * 인증서 일련번호
    * 인증서 유효기간
    * 사이트의 조직 이름 
    * 사이트의 DNS 호스트 명
    * 사이트 공개키
    * 인증서 발급자 이름
    * 인증서 발급자 서명 
+ 사이트 인증서 검사

  |명칭|상세|실패 처리|
  |---|---|---|
  |날짜검사 | 인증서 활성화/만료 여부 검사| 오류 표시|
  |서명자 신뢰도 검사 | 인증기관이 신뢰할 만한 기관 목록에 포함되어 있는지 검사| 경고 표시|
  |서명 검사| 공개키 이용해 서명의 체크섬 검증| |
  |사이트 신원 검사| 인증서의 사이트 정보와 현재 사이트 비교 (사이트명, 호스트명)| 사용자에게 알리거나 커넥션 종료|

+ 가상 호스팅
: 서버 프로그램이 하나의 인증서만 지원하는 경우 경고 표시될 수도  
=> 인증서에 맞는 도메인으로 리다이렉트 후 보안 통신 진행

### 진짜 HTTPS 클라이언트
: SSL은 복잡한 바이너리 프로토콜이므로 직접 구현하지 말고 라이브러리 이용해야 
+ [OpenSSL](https://www.openssl.org)
+ [LibreSSL](https://www.libressl.org/)

### 프록시 통한 보안 트래픽 터널링
: 프록시는 보안 트래픽의 헤더 인식 못하므로 전달 불가  
  => HTTPS SSL 터널링 프로토콜 사용해 서버-클라이언트 사이 터널 수립 (양방향으로 데이터만 전달)
