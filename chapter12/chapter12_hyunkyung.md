# 12장 기본 인증
## 12.1 인증
### 12.1.1 HTTP의 인증요구/응답 프레임워크
- HTTP는 사용자 인증을 하는 데 사용하는 자체 인증요구/응답 프레임워크를 제공
- 웹 애플리케이션이 HTTP 요청 메시지를 받으면, 서버는 요청을 처리하는 대신에 인증 요구를 하고 클라이언트는 인증 정보를 첨부해서 다시 요청

### 12.1.2 인증 프로토콜과 헤더
- HTTP는 필요에 따라 고쳐 쓸 수 있는 제어 헤더를 통해, 다른 인증 프로토콜에 맞추어 확장할 수 있는 프레임워크를 제공
- HTTP에는 기본 인증과 다이제스트 인증이라는 공식적인 인증 프로토콜이 있음

| 단계 | 헤더 | 설명 | 메서드/상태 |
| --- | --- | --- | -------- |
| 요청 | | 첫 번째 요청에는 인증 정보가 없음 | GET |
| 인증 요구 | WWW-Authenticate | 서버는 사용자에게 이름과 비밀번호를 제공하라는 지시의 의미로 401 상태 정보와 함께 요청을 반려함 | 401 Unauthorized |
| 인증 | Authorization | 클라이언트는 요청을 다시 보내는데, 인증 알고리즘과 사용자 이름, 비밀번호를 기술한 Authorization 헤더를 함께 보냄 | GET |
| 성공 | Authentication-Info | 인증번호가 정확하면 서버는 문서와 함께 응답. 어떤 인증 알고리즘은 선택적인 헤더인 Authentication-Info 에 인증 세션에 관한 추가 정보를 기술해서 응답 | 200 OK |

### 12.1.3 보안 영역
- 웹 서버는 기밀문서를 보안 영역(relam) 그룹으로 나누고 보안 영역은 저마다 다른 사용자 권한을 요구

## 12.2 기본 인증
- 기본 인증에서 웹 서버는 클라이언트의 요청을 거부하고 유효한 사용자 이름과 비밀번호를 요구할 수 있음
### 12.2.1 기본 인증의 예
- 사용자가 자신의 가족사진인 /family/jeff.jpg를 요청
- 서버가 WWW-Authenticate 헤더와 함께 개인 가족사진에 접근하는 데 필요한 비밀번호를 요구하는 401 응답 반환
- 브라우저가 401 응답을 받고 사용자 이름과 비밀번호 요구하는 대화상자 띄움
- 사용자가 사용자이름과 비밀번호를 입력하면 그것들을 콜론으로 이어붙이고, base-64방식으로 인코딩하고 Authorization 헤더에 담아서 서버로 재전송
- 서버가 입력값을 디코딩하여 값이 정확한지 검사한 후, 문제가 없으면 HTTP 200 OK 메시지와 함께 요청받았던 문서 보냄

### 12.2.2 Base-64 사용자 이름/비밀번호 인코딩
- base-64 인코딩은 8비트 바이트롤 이루어져 있는 시퀀스를 6비트 덩어리의 시퀀스로 변환
- 각 6비트 조각은 대부분 문자와 숫자로 이루어진 특별한 64개의 문자 중에서 선택됨
- Base-64 인코딩은 바이너리,텍스트,국제 문자 데이터 문자열을 받아서 전송할 수 있게, 그 문자열을 전송 가능한 문자인 알파벳으로 변환하기 위해 발명됐음
- 전송 중에 원본 문자열이 변질될 걱정 없이 원격에서 디코딩할 수 있음

### 12.2.3 프락시 인증
- 중개 프락시 서버를 통해 인증할 수도
- 프락시 서버에서 접근 정책을 중앙 관리 할 수 있기 때문에, 회사 리소스 전체에 대해 통합적인 접근 제어를 하기 위해서 프락시 서버를 사용하면 좋음
- 웹 서버와 프락시 인증에서 쓰이는 상태코드와 헤더들의 대조표

| 웹 서버 | 프락시 서버 |
| --------- | -------------- |
| 비인증 상태 코드 : 401 | 비인증 상태 코드 : 407 |
| WWW-Authenticate | Proxy-Authenticate |
| Authorization | Proxy-Authorization |
| Authentication-Info | Proxy-Authentication-Info |

### 12.3 기본 인증의 보안 결함

- 기본 인증은 악의적이지 않은 누군가가 의도치 않게 리소스에 접근하는 것을 막는데 사용하거나, SSL 같은 암호 기술과 혼용

보안결함
1. 기본 인증은 사용자 이름과 비밀번호를  쉽게 디코딩할 수 있는 형식으로 네트워크에 전송.
2. 보안 비밀번호가 디코딩하기에 더 복잡한 방식으로 인코딩되어 있다고 하더라도, 여전히 제삼자는 읽기 힘든 사용자 이름과 비밀번호를 캡처한 다음, 그것을 그대로 원 서버에 보내서 인증에 성공하고 서버에 접근할 수 있음
3. 치명적이지 않은 곳에 사용되더라도 위험함. 동일한 사용자 이름과 비밀번호로 중요한 온라인 은행 사이트에 접근할 수도
4. 메시지의 인증 헤더를 건드리지는 않지만, 그 외 다른 부분을 수정해서 트랜잭션의 본래 의도를 바꿔버리는 프락시나 중개자가 중간에 개입하는 경우, 기본 인증은 정상적인 동작을 보장하지 않음
5. 기본 인증은 가짜 서버의 위장에 취약.

- 기본 인증은 사용자 이름과 비밀번호를 악의적인 개인들에게 숨기려고 암호화된 데이터 전송과 함께 연계해서 사용할 수 있음

