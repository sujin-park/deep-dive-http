## 12.1 인증

- **인증**: 당신이 누구인지 증명하는 것(예: 비밀번호)

### 12.1.1 HTTP의 인증요구/응답 프레임워크

- HTTP는 사용자 인증을 하는 데 사용하는 자체 인증요구/응답 프레임워크를 제공
- HTTP 인증 모델:
    - HTTP 요청 메시지를 받으면, 서버는 요청을 처리 대신에 현재 사용자가 식별을 위해 비밀번호 같이 개인 정보를 요구하는 '인증 요구'로 응답 가능
    - 사용자는 다시 요청시에 인증 정보를 첨부하고 서버는 정보를 맞으면 요청을 처리, 맞지 않으면 재인증요구를 보내거나 에러 발생

### 12.1.2 인증 프로토콜과 헤더

- HTTP는 필요에 따라 수정할 수 있는 제어 헤더를 통해, 다른 인증 프로토콜에 맞춰 확장할 수 있는 프레임워크 제공
    - 헤더 형식과 내용은 인증 프로토콜에 따라 다르며, 인증 프로토콜은 HHTTP 인증 헤더에 기술되어 있음
- HTTP의 공식적인 인증 프로토콜:
    - 기본 인증(basic authentication)
    - 다이제스트 인증(digest authentication) 13장 참고
    - 현대에는 HTTP 인증요구/응답 프로토콜을 사용하는 새 프로토콜을 사용(예: [OAuth](https://tools.ietf.org/html/6749))
- 네가지 인증 단계
    - 요청(GET): 인증정보 미포함
    - 인증 요구(`401 Unauthhroized`)
        - 서버는 사용자에게 이름/비밀번호를 제공하라는 지시의 의미로 401과 함께 요쳥 반려. 서버 `WWW-Authenticate` 헤더에 인증 방법에 대한 정보를 제공.
    - 인증(GET)
        - 클라이언트는 인증 알고리즘과 사용자 이름/비밀번호를 기술한 `Authorization` 헤더를 함께 보냄
    - 성공(`200 OK`)
        - 인증정보가 정확하면, 서버는 문서와 함께 응답. 인증 알고리즘에 따라 선택적으로 `Authentication-Info` 에 인증 세션에 관한 추가 정보를 기술해서 응답

### 12.1.3 보안 영역

- 웹 서버는 기밀문서를 보안 영역(realm) 그룹으로 나누고, 보안 영역마다 다른 사용자 권한을 요구
    - 예: 일반 자료, 대외비 자료, 기밀 자료
- `realm` 파라미터가 함께 기술된 기본 인증 예:

    ```
    HTTP/1.0 401 Unauthroized
    WWW-Authenticate: Basic realm="Corporate Financials"
    ```

- realm은 "Corporate Financials(회사 재무)"와 같이 해설 형식(예: 권한 명,서버 호스트명 등)으로 되어, 권한을 가진 사용자에게 권한의 범위 알리는 데 사용

## 12.2 기본 인증

- 기본 인증은 가장 잘 알려진 HTTP 인증 규약으로, 모든 주요 클라이언트/서버에 구현되어있음

### 12.2.1 기본 인증의 예

- 클라이언트가 요청하면 서버는 `WWW-Authenticate` 헤더와 함께 `401 Unauthhroized` 응답 반환
- 브라우저는 응답을 받아, 이름/비밀번호를 요구하는 대화상자를 띄움. 사용자가 입력하면 브라우저는 이를 콜론으로 이어 붙이고, base-64방식으로 인코딩하고, `Authorization` 헤더에 담아 서버로 요청
- 서버는 사용자 이름/비밀번호를 디코딩하여 검사하고, 문제 없으면 `200 OK` 를 보냄
- 인증 요구/응답의 헤더
    - **인증 요구(서버 → 클라이언트)**: realm은 요청 받은 문서의 집합의 이름을 따옴표로 감싼 것으로, 사용자는 이 정보를 보고 어떤 비밀번호를 사용해야 하는지 알 수 있음

        ```
        WWW-Authenticate: Basic realm=<realm>
        // <realm> = 따옴표로 감산 문서 집합 정보
        ```

    - **응답(클라이언트 → 서버)**: 사용자 이름/비밀번호는 콜론으로 잇고, base-64로 인코딩해서 사용자 이름, 비밀번호에 쉽게 국제문자를 포함할 수 있게 하고 네트워크 트래픽에서 사용자 이름/비밀번호가 미노출되게 함

        ```
        Authorization: Basic <credentials>
        // <credentials> = base-64로 인코딩한 사용자이름/비밀번호
        ```

    - `Authentication-Info` 기본인증에서는 미사용

### 12.2.2 Base-64 사용자 이름/비밀번호 인코딩

- **base-64 인코딩**: 8비트 바이트로 이루어져있는 시퀀스를 6비트 덩어리의 시퀀스로 변환.
    - 각 6비트 조각은 대부분 문자, 숫자로 이루어진 특별한 64개 문자 중에서 선택됨
- base-64 인코딩 사용 예시
    - 이름: 'brian-totty', 비밀번호: 'Ow!'
    - → 'brian-totty:Ow!'
    - → 'YnJpYW4tdG90dHk6T3ch'
    - → `Authorization: Basic YnJpYW4tdG90dHk6T3ch`
- base-64 인코딩은 바이너리/텍스트/국제 문자 데이터 문자열을 전송할 수 있도록 전송 가능 문자인 알파벳으로 변환하기 위해 발명
    - 전송 중 변질 위험 없이 디코딩 가능

### 12.2.3 프락시 인증

- 중개 프락시 서버를 통해 인증 가능.
    - 예: 사용자들이 회사내 서버, LAN, 무선 네트워크 접근 전에 프락시 서버를 거치게 해 사용자 인증
- 프락시 인증은 웹 서버의 인증과 헤더와 상태 코드만 다르고 절차는 같음
    - 비인증 상태 코드: 401 ↔ 비인증 상태 코드: 407
    - `WWW-Authenticate` ↔ `Proxy-Authenticate`
    - `Authorization` ↔ `Proxy-Authorization`
    - `Authentication-Info` ↔ `Proxy-Authentication-Info`

## 12.3 기본 인증의 보안 결함

- 보안 결함
    1. 기본 인증의 사용자 이름/비밀번호는 쉽게 디코딩 가능함. HTTP 트랜잭션을 SSL 암호화 채널로 보내거나, 보안이 더 강화된 다이제스트 인증 프로토콜 사용 권장
    2. 보안 비밀번호가 디코딩하기 어려운 방식으로 인코딩되어 있다하더라도, 제 3자가 디코딩된 정보 그대로 다시 원 서버에 보내서 인증에 성공할 수 있음. 기본 인증은 재전송 공격을 예방하지 않음
    3. 기본 인증을 보안이 뚫리더라도 치명적이지 않은 애플리케이션에 사용하더라도, 일반 사용자는 같은 아이디/비밀번호를 사용하는 경향이 있어, 동일한 정보로 중요한 사이트에 사용하여 문제가 발생할 수 있음
    4. 메시지 인증 헤더를 건드리지 않았지만, 다른 부분을 수정해 트랜잭션의 본래 의도를 바꾸는 프락시/중개자가 개입하는 경우, 기본 인증이 정상 작동하지 않을 수 있음
    5. 기본 인증은 가짜 서버 위장에 취약. 사용자가 가짜 서버/가짜 게이트에 그대로 보낼 수 있음. 
- 즉 기본 인증은 우연이나 사고로 정보에 접근해 보는 것을 예방하는 정도로 사용
- 암호화된 데이터 전송(예: SSL)과 함께 연계해서 사용
