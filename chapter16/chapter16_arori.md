## 16.1 국제적인 콘텐츠를 다루기 위해 필요한 HTTP 지원

- 엔터티 본문은 비트들일 뿐이며, HTTP 메시지는 어떤 언어든 어떤 미디어든 전송 가능
- 국제 콘텐츠 지원을 위해 서버는 각 문서의 문자, 언어를 알려 클라이언트가 바르게 제공할 수 있도록 해야 함
- 서버는 클라이언트에게 문서의 문자와 언어 안내
    - `Content-Type` 의 `charset` 매개 변수와 `Content-Language` 헤더 사용
- 클라이언트는 서버에게 어떤 언어를 이해하고, 어떤 알파벳 코딩 알고리즘이 있는지 안내
    - `Accept-Charset` 과 `Accept-Language` 헤더 사용
    - 매개 변수 q는 품질 인자(quality factor)로, 이를 이용하여 가중치를 줄 수 있음

```
Accept-Charset: fr, en;q=0.8
Accept-Charset: iso-8869-1, utf-8
```

## 16.2 문자집합과 HTTP

### 16.2.1 차셋(Charset)은 글자를 비트로 변환하는 인코딩이다

- HTTP Charset은 어떻게 엔터티 콘텐츠 비트들을 특정 문자 체계의 글자들로 바꾸는지 안내
    - 각 Charset 태그는 비트↔글자 변환의 알고리즘을 명명.
        - Charset 태그는 MIME 문자 집합에 표준화되어있고, [IANA가 관리](http://www.iana.org/assignments/character-sets/character-sets.xhtml)
- 예: iso-8859-6: 아랍문자집합 디코딩 기법. 8비트 값을 숫자, 구두점, 기호, 라틴 문자, 아랍문자로 매핑
- 몇 문자 인코딩(UTF-8, iso-2022-jp 등)은 글자 당 비트 수가 일정하지 않아 더 복잡한 가변 길이 코드.
    - 이런 종류는 중국어, 일본어와 같이 많은 글자로 이루어진 문자 체계 지원을 위해 추가적인 비트를 사용할 수 있게 해줌

### 16.2.2 문자 집합과 인코딩은 어떻게 동작하는가

- 세상에는 문자가 많고, 글자를 비트로 인코딩하는 각각의 장단점을 가진 방법들이 있으므로, 디코딩 알고리즘을 지칭하고 적용하는 표준화된 방법이 필요
- 비트를 문자로 변환하는 방법
    1. 데이터 비트(11100001) →(인코딩 구조를 사용하여 디코딩)→ 문자 코드(225)
    2. 문자 코드(225) →(코딩된 문자집합을 사용하여 색인)→ 유일한 문자(ARABIC LETTER FEH)
- 국제화된 문자 시스템의 핵심 목표는 표현(시각적인 표현 방식)에서 의미(글자들)을 분리하는 것.
    - ⇒ 문자 데이터, 그와 관련된 언어,  Charset 라벨 전송에만 관심을 가짐
    - 글자 모양을 표현 방식은 사용자의 그래픽 디스플레이 소프트웨어(브라우저, 운영체제, 글꼴)가 결정
        - 예: 'ARABIC LETTER FEH' →(그래픽 디스플레이 소프트웨어)→ ف

### 16.2.3 잘못된 차셋은 잘못된 글자를 낳는다

- 같은 값이여도 잘못된 charset 매개변수를 사용한다면 글자가 깨짐
    - 예: 225(이진 값 11100001)
        - iso-8859-1 서유럽 문자 코드 → á
        - iso-8859-6 아랍 코드→ ف
        - iso-8859-7 그리스어 → α
        - iso-8859-8 히브리어 → ב

### 16.2.4 표준화된 MIME 차셋 값

- MIME Charset 인코딩 구조 몇가지
    - `us-ascii`: `ASCII` 로 불리며, 7비트를 128가지 글자에 대응시킴.
    - `iso-8859-1`: 서유럽 언어 지원을 위한 ASCII의 8비트 확장. = `iso-latin-1`, `Latin1`
    - `iso-8859-2`: 체코, 폴란드, 루마니아어 등 중부, 동유럽을 포함시키는 ASCII 확장. = `iso-latin-2`
    - `iso-8859-5`: 러시아, 세르비아, 불가리아어 등 키릴문자를 포함하기 위한 ASCII 확장
    - `iso-8859-6`: 아랍 문자를 포함하기 위한 ASCII 확장.
        - 아랍 문자의 모양은 단어에서의 위치에 좌우되므로, 문맥 분석 후 모양을 생성하는 디스플레이 엔진 필요
    - `iso-8859-7`: 현대 그리스 문자 포함하기 위한 ASCII 확장. = `ELOT-928`, `ECMA-118:1986`
    - `iso-8859-8`: 히브리어, 이디시어 문자를 포함하기위한 ASCII 확장.
    - `iso-8859-15`: 덜 필요한 구두점, 분수 기호를 고대 프랑슷어와 핀란드어로 대체. = `Latin0`
        - 국제 통화기호를 유로 통화 기호로 대체하기 위해 `iso-8859-1` 를 갱신한 것
    - `iso-2022-jp`: 일본어 전자우편, 웹 콘텐츠용 인코딩. 1바이트로 된 ASCII문자들을 지원하는 가변길이 인코딩. 일본어 문자 집합으로 전환하기 위해 3글자로 된 모달 이스케이프 문자열(modal escape sequence) 사용
    - `euc-jp`: 모드나 이스케이프 문자열 없이 글자 식별을 위해 명시적 비트 패턴을 사용하는 ISO 2022 호환 가변 길이 인코딩. 일본어 문자 집합에서의 글자를 식별하기위해 1, 2, 3바이트 문자열 사용.
    - `SHIFT_JIS`: 마이크로소프트에 의해 개발된 일본어 인코딩. = `SJIS`, `MS Kanji`
        - 호환성 문제에 따른 복잡도와 모든 문자 대응 불가이슈가 있지만 여전히 흔히 쓰임
    - `koi8-r`: IETF RFC 1490로 정의된 인기있는 러시아용 8비트 인터넷 문자 집합 인코딩.
    - `utf-8`: 전 세계 문자들에 대한 보편적 문자 집함인 UCS(유니코드)를 표현하기 위한 가변 길이 문자 인코딩 구조. 각 글자를 1~6바이트로 표현하는 가변 길이 인코딩을 문자 코드 값에 사용.
        - 주요 기능 중 하나는 통상적인 7비트 아스키 문자열에 대한 하휘 호환성
    - `windows-1252`: 마이크로소프트에서 개발한 `iso-8859-1` 확장 인코딩. = 윈도우 코드 페이지 1252, `CP1252`, `WinLatin1`

### 16.2.5 Content-Type charset 헤더와 META 태그

- 웹 서버는 클라이언트에게 MIME Charset 태그, charset 매개 변수를 Content-Type 헤더에 담아 전송
    - 문자 집합이 명시적으로 나열되지 않았따면, 수신자는 문서의 콘텐츠로 부터 추측.
- HTML 콘텐츠에서 `<meta http-equiv="Conttent-Type">` 태그는 문자 집합을 서술

    ```html
    <head>
    	<meta http-equiv="Conttent-Type" content="text/html; charset=iso-2022-jp">
    	<meta lang="jp">
    	...
    </head>
    ...
    ```

### 16.2.6 Accept-Charset 헤더

- 대부분의 클라이언트는 모든 종류의 문자 코딩, 매핑 시스템을 지원하지 않음.
- 클라이언트는 `Accept-Charset` 를 통해 어떤 문자 체계를 지원하는지 알려줌
    - 제공한 목록 중  어떤 것으로 콘텐츠를 반환할지는 서버의 자유

## 16.3 다중언어 문자 인코딩에 대한 지침

### 16.3.1 문자 집합 용어

1. 문자(character)
    - 알파벳 글자, 숫자, 구두점, 표의문자, 기호 등 글쓰기의 최소 단위.
    - 유니코드(Unicode)라고 불리는 국제 문자 세트(Universal Character Set, UCS)계획에 따라 여러 글자에게 알맞고 유일한 이름을 부여하기 위한 표준화된 이름 집합 개발되어 옴
2. 글리프(glyph)
    - 하나의 글자를 표현하기 위한, 획의 패턴이나 다른 것과 구분되는 유일한 시각적 형태
    - 하나의 글자를 여러 방식으로 쓰는게 가능하다면 글리프를 여러개 가질 수 있음.
3. 코딩된 문자(coded character)
    - 우리가 글자를 다룰 수 있도록 각 글자에 할당된 유일한 숫자
4. 코드 공간(coding space)
    - 문자 코드 값으로 사용하려고 계획 해 둔 정수의 범위
5. 코드 너비(code width)
    - 각 문자 코드의 (고정된 크기의) 비트 개수
6. 사용 가능한문자 집합(character repertoire)
    - 글자들에 대한 특정한 작업 집합(세상에 존재하는 모든 글자의 부분 집합)
7. 코딩된 문자 집합(coded character set)
    - 사용 가능 문자 집합(세상의 모든 글자에서 일부분을 선택한 것)을 받아서 각 글자에 코드 공간의 코드를 할당해주는 코딩된 문자들의 집합.
    - = 실제 글자들에 숫자로된 문자 코드를 대응시킨 것
8. 문자 인코딩 구조(character encoding scheme)
    - 숫자로 된 문자 코드들 ↔ 콘텐츠 비트의 연속을 인코딩/디코딩하는 알고리즘.
    - 문자 인코딩 구조는 글자를 식별하기 위해 필요한 데이터의 양을 줄이거나(압축), 전송상의 어떠한 제약을회피하거나, 중복된 코딩 된 문자 집합을 통합하는데 사용

### 16.3.2 '차셋(Charset)'은 형편 없는 이름이다

- `Content-Type` charset 매개 변수와, `Accept-Charset` 헤더에서 쓰이는 MIME charset 태그는 문자 집합을 의미하는 것이 아님
- 데이터 비트를 고유한 문자의 코드로 매핑하는 알고리즘의 이름. 즉 문자 인코딩 구조 + 코딩된 문자 집합
- 하지만 이를 지칭하는 다른 표준이 있으므로, 표준 문서를 읽을 때에는 정확히 무엇이 정의되어있는지 확인하여 읽어야 함.

### 16.3.3 문자

- 문자는 기본적인 구성 요소로, 글꼴이나 스타일에 독립적임
- 같은 글자라도 그 글자가 단어의 어디에 위치하냐에 따라 각각 다른 모양을 갖는 표기 체계도 있음.

### 16.3.4 글리프(glyphs), 연자(ligatures) 그리고 표현 상태

- 글리프와 문자를 헷갈려서는 안됨. 각 문자는 미적인 양식과 스크립트에 따라 여러 글리프를 가짐.
    - 문자: 유일하고 추상화된 언어의 요소
    - 글리프: 각 글자를 그리는 특정한 방법
- 많은 필기체와 활자체에는 인접한 글자들이 부드럽게 이어지는 연자(ligature)를 지원
    - 일반적인 규칙은(항상 명확하진 않음), 글리프 하나를 다른 것으로 바꾸었을 때
        - 텍스트의 이미지가 바뀐다 → 그 글리프는 서로 다른 글자임.
        - 바뀌지 않는다 → 모양만 다를뿐인 같은 글자임.

### 16.3.5 코딩된 문자 집합(Coded Character Set)

- 코딩된 문자 집합은 정수를 글자로 대응 시킴.
    - 68 →(US-ASCII 코딩된 문자 집합)→ 'LATIN CAPITAL LETTER D'

***US-ASCII: 모든 문자 집합의 어머니***

- 가장 유명한 코딩된 문자 집합으로, 코드값 0~127을 사용(7bit).
- 다른 국제 변종과 구분하기위해 'US-ASCII'라는 이름 선호됨
- HTTP 메시지(헤더, URI) 등은 US-ASCII 사용

***iso-8859***

- 국제적인 글쓰기를 위해 필요 글자들을 하이 비트를 이용해서 추가한 US-ASCII의 9비트 확대 집합
- 추가 비트에 의해 제공되는 추가 공간이 충분히 크지 않으므로, 지역에따라 커스터마이징된 문자 집합을 제공
    - 서유럽어: `iso-8859-1`, 중앙,동유럽어 `iso-8859-2`, 남유럽어: `iso-8859-3`, 북유럽어: `iso-8859-4`, 키릴: `iso-8859-5`,  아랍어: `iso-8859-6`,  그리스어: `iso-8859-7`,  히브리어: `iso-8859-8`,  터키어: `iso-8859-9`,  노르딕어: `iso-8859-10`
    - 유로 통화를 포함한 `iso-8859-1` 의 변형 : `iso-8859-15`

***JIS X 0201***

- 아스키를 일본어 가타카나 반각문자를 더해 확장한 매우 작은 문자 집합. 보통 `JIS Roman` 으로 불림

***JIS X 0208과 JIS 0212***

- 최초의 멀티 바이트 일본어 문자 집합. JIS X 0201 대신 실질적 사용을 위해 제작

UCS

- 국제 문자 세트(Universal Character Set, UCS)는 전 세계의 모든 글자를 하나의 코딩된 문자 집합으로 통합하려는 세계적인 표준.

### 16.3.6 문자 인코딩 구조

- 인코딩 구조는 숫자로 된 문자 코드 ↔ 콘텐츠 비트들로 인코딩/디코딩 함.
- 문자 인코딩은 크게 세종류로 분류
    1. **고정폭**
        - 각 코딩된 문자를 고정된 길이의 비트로 표현. 빠르게 처리되지만, 공간 낭비 우려
    2. **가변폭(비모달)**
        - 다른 문자 코드 번호에 다른 길이의 비트 사용.
        - 자주 사용하는 글자의 비트 길이를 줄일 수 있고, 국제 문자에 대해서는 여러 바이트를 사용하도록 하여 이전 8비트 문자 집합과의 호환성 유지 가능
    3. **가변폭(모달)**
        - 다른 모드로의 전환을 위해 특별한 'escape' 패턴 사용
            - 예: 어떤 모달 인코딩은 텍스트에서 중첩된 여러가지 문자집합 간의 전환을 위해 사용.
        - 모달 인코딩은 처리하기 복잡하지만, 복잡한 표기 체계를 효과적으로 지원
- 몇가지 문자 인코딩의 구조
    - 8비트
        - 8비트 고정폭 아이덴티티 인코딩은 간단히 각 문자 코드를 그에 대응하는 8비트 집합으로 인코딩
        - 256개(2^8) 문자 코드 범위에 대한 문자 집합만 지원.
        - iso-8859 문자 집합군은 9비트 아이덴티티 인코딩 사용
    - UTF-8
        - UTF-8(UCS Transformation Format 8-bit)는 인기있는 UCS를 위해 설계된 문자 인코딩
        - 문자 코드의 값을 위해 비모달 가변길이 인코딩 사용.
        - 첫 바이트의 선두 비트들은 인코딩된 문자의 길이를 바이트 단위로 나타냄.
            - 첫번째 인코딩된 바이트의 하이 비트가 0이라면 길이는 1바이트. 나머지 7비트는 문자 코드.
                - 이 때문에 아스키와 호환성이 확보됨. 예: 90 → Z
                - iso-8859는 하이비트를 사용하므로 호환되지 않음
        - 이후 바이트들은 각각 6비트의 코드 값을 포함

    - iso-2022-jp
        - 8비트 문자 지원하지 않는 소프트웨어와의 문제 방지를 위해 128보다 작은 값으로만 이루어진 가변 길이 모달 인코딩
        - 인코딩 콘텍스트(encoding context)는 언제나 네가지 미리 정의된 문자 집합 중 하나로 설정 됨.
        - 특별한 '이스케이프 문자열'을 이용해 한 집합에서 다른 집합으로 전환
            - iso-2022-jp는 처음에 US-ASCII를 사용하지만 3바이트 이스케이프 문자열을 이용해 JIS X 0201, JIS X 0208-1978, JIS X 0208-1983으로 전환 가능
    - euc-jp
        - EUC(Extended Unix Code)는 유닉스 운영체제에서 아시아 문자를 지원하기 위해 처음 개발 됨.
        - 가변 길이 인코딩이나 모달이 아니며, 모드 전환을 위한 이스케이프 문자열이 없음.
        - JIS X 0201, JSX 0208, 반각 가타카나, JIS X 0212, 총 4개의 코딩된 문자 집합을 지원
    - euc-kr
        - 한글 문서를 위해 사용된 가변길이 인코딩으로 KS X 1003, KS X 1001 두 가지 문자 집합 지원
        - KS X 1003: 1바이트로 인코딩되는 로마자 문자 집합. (US-ASCII에서 \만 원화 기호로 치환한 것)
        - KS X 1001: 2바이트로 인코딩되는 한글, 한자, 특문으로 이루어진 한국어 문자 집합.
            - 총 2,350자의 한글을 담고 있으며, 전체 한글을 담기에는 적음.
            - [한글 채움 문자](https://ko.wikipedia.org/wiki/%ED%95%9C%EA%B8%80_%EC%B1%84%EC%9B%80_%EB%AC%B8%EC%9E%90)(fill code)를 사용하여 한글을 초, 중, 종성으로 표현하여 표현함.

## 16.4 언어 태그와 HTTP

- 언어 태그: 언어에 이름을 붙이기 위한 짧고 표준화 된 문자열
    - 브라질 포르투갈어: pt-BR, 미국 영어: en-US, 허난 중국어: zh-xiang

### 16.4.1 Content-Language 헤더

- `Content-Language` 엔터티 헤더 필드는 엔터티가 어떤 언어 사용자를 대상으로 하는지 서술
    - 여러 언어 사용자를 대상으로 한다면 나열 할 수 있음

```html
Content-Language: fr, en
```

- `Content-Language` 헤더는 텍스트 문서외에, 오디오 클립, 동영상, 애플리케이션도 대상으로 할 수 있음.
- 여러가지 언어가 하나에 엔터티에 사용되었다 하더라도 반드시 여러 언어 사용자를 대상으로 하는 것이 아님
    - 예: 영어 사용자를 위한 라틴어 수업은 'en' 만 포함해야 함.

### 16.4.2 Accept-Language 헤더

- 우리의 언어 제약과 선호도를 웹 서버에 전달. 서버는 이 값을 보고 컨텐츠를 맞춰 제공

```html
Accept-Language: es
```

### 16.4.3 언어 태그의 종류

- 언어 태그는 [RFC 3066 "Tags for the Identification of Languages"](https://tools.ietf.org/html/rfc3066) 에 문서화된 표준 문법을 갖음
- 언어 태그는 다음을 표현하기 위해 사용 될 수 있음
    - 일반적인 언어의 종류. (예: 스페인어 'es')
    - 특정 국가의 언어. (예: 영국 영어 'en-GB')
    - 방언. (노르웨이어의 'Book Language'를 의미하는 'no-bok')
    - 지방어(마서스 비니어드 섬의 수화를 의미하는 'sgn-US-MA')
    - 그 외의, 다른 언어의 변형이 아닌 표준 언어 (예: 나바호어 'i-navajo')
    - 비표준 언어(예: 스노우보드를 타는 사람들의 은어 'x-snowboarder-slang')

### 16.4.4 서브태그

- 언어 태그는 하이픈으로 분리된 하나 이상의 서브 태그로 이루어짐
    - 첫 번째 서브태그는 주 서브 태그. 표준화 되어있음. 알파벳만 포함
    - 두 번째 서브태그는 선택적이고 자신만의 이름 표준을 따름. 알파벳, 숫자를 포함할 수 있으며 최대 8자
    - 세 번째 서브태그는 등록 되어 있지 않음

### 16.4.5 대소문자의 구분 및 표현

- 모든 태그는 대소문자가 구분되지 않음. 하지만 관용적/권고안으로 언어는 소문자, 국가는 대문자를 사용
    - 예: fr은 프랑스어 FR은 국가 프랑스

### 16.4.6 IANA 언어 태그 등록

- IANA는 RFC 3066 규칙에 따라 표준 언어 태그 목록(첫 번째, 두 번째 언어 서브 태그) 관리.
- 언어가 표준 국가와 언어 값의 조합이면, 틍록되지 않아도 무방하며, 표준 국가와 언어 값으로 구성될 수 없는 언어 태그는 IANA 에 의해 등록될 필요가 있음.

### 16.4.7 첫 번째 서브태그: 이름 공간

- ISO 639 표준 언어 집합에서 선택된 표준화된 언어 토큰.
- 첫 번째 서브태그 규칙
    - 두 글자라면, ISO 639, 639-1 표준 언어 코드
    - 세 글자라면, ISP 639-2 표준과 확장에 열거된 언어 코드
    - 글자 'i' 라면, IANA에 등록된 것
    - 글자 'x' 라면, 특정 개인/집단 전용 비표준 확장자
- [639와 639-2 이름 목록](https://ko.wikipedia.org/wiki/ISO_639-1_%EC%BD%94%EB%93%9C_%EB%AA%A9%EB%A1%9D)

### 16.4.8 두 번째 서브태그: 이름 공간

- ISO 3166 국가 코드와 지역 표준 집합에서 선택된 표준화된 국가 토큰
- 두 번째 서브태그 규칙
    - 두 글자라면, ISO 3166에 정의된 국가/지역(혹은 예약어)
    - 3~8 글자라면, IANA에 등록된 것
    - 한 글자라면, 잘못 된 것
- [ISO 3166 국가 코드 목록](https://ko.wikipedia.org/wiki/ISO_3166-1)

### 16.4.9 나머지 서브태그: 이름 공간

- 세 번째와 그 이후 서브태그에는 8자 이하의 알파벳, 숫자로 이루어져야하는 것 외에는 다른 규칙 없음

### 16.4.10 선호 언어 설정하기

- 웹 브라우저 프로필에서 언어 설정을 할 수 있음

## 16.5 국제화된 URI

- 처음의 URI는 국제화를 지원하지 않아, US-ASCII의 부분 집합으로 구성되어 있었음.
- URI에 대한 최신 명세인 [RFC 3986](https://tools.ietf.org/html/rfc3986) 은 URI에 UTF-8 문자를 사용할 수 있는 방법을 명시적으로 제시
    - 오늘날엔 다양한 문자들로 URI를 사용할 수 있음.

### 16.5.1 국제적 가독성 vs 의미 있는 문자들

- URI 설계자들은 두 가지 목표가 있고, 이는 서로 충돌 함
    - 국제적 가독성: 전 세계 모두가 URI를 다른 사람들과 쉽게 공유
    - 의미 있는 문자들: URI가 사용하기 쉽고 기억하기 쉬움
- 문자 집합에는 제한이 있고, 국제적 가독성을 더 중요시 여겨서, ASCII 문자로 제한된 집합으로 이루어진 URI를 갖게되었음.

### 16.5.2 URI에서 사용될 수 있는 문자들

- URI에서는 예약된 문자, 예약되지 않은 문자, 이스케이프 문자로 나뉨.
    - 예약되지 않은 문자: URI의 어떤 컴포넌트에서도 일반적으로 사용됨
    - 예약된 문자: URI에서 특별한 의미를 가지며, 일반적으로 사용될 수 없음.
        - `;`, `/`, `?`, `:`, `@`, `&`, `=`, `+`, `$`, `,`
    - 이스케이프
        - `%`

### 16.5.3 이스케이핑과 역이스케이핑(unescaping)

- 이스케이프: 퍼센트 글자(%) 와 뒤 이은 16진수 글자 둘(US-ASCII)로 이루어진 세글자 문자열.
    - 예약된 문자, 미지원 문자들을 안전하게 URI에 삽입할 수 있는 방법 제공
- URL에 스페이스(ASCII 32)를 삽입하고 싶다면, `%20`사용할 수 있음
- HTTP 애플리케이션은 URI를 데이터가 필요할 때만 언이스케이핑(unescaping)을 해야하며, 두 번 언이스케이핑이 되지 않도록 해야 함
    - 예: %를 이스케이핑하고 두 번 언이스케이핑하면 데이터 손실 유발

### 16.5.4 국제 문자들을 이스케이핑하기

- 초반에는 이스케이프 값들이 US-ASCII코드의 범위(0-127)에 있어야 했음
- 오늘날에는 ASCII 범위 밖 문자도 인코딩 할 수 있음.

## 16.6 기타 고려사항

### 16.6.1 헤더와 명세에 맞지 않는 데이터

- HTTP 헤더는 반드시 US-ASCII 문자 집합의 글자들로만 이루어져야 함
    - 대부분의 라이브러리는 지원하지않으며, 잘못된 글자가 주어졌을 떄 충돌을 일으킴

### 16.6.2 날짜

- HTTP 명세는 올바른 GMT 날짜 형식을 정의하고 있지만, 모든 서버/클라이언트가 규칙을 따르고 있지 않음
- HTTP 애플리케이션은 명세에 맞지 않는 날짜를 관대하게 받아들이면서도, 충돌을 일으키지 말아야 함.
    - 아예 처리할 수 없는 날짜라면, 보수적으로 다루어야 함

### 16.6.3 도메인 이름

- 국제화 문자를 포함하는 도메인 이름을 '국제화 도메인 이름(Internationalizing Domain Name)'이라고 함.
- 퓨니코드(punycode): 유니코드 문자열을 호스트 명에서 사용 가능한 문자만으로 이루어진 문자열로 변환하는 방법
    - RFC 3492에 정의되어있으며, 오늘날 대부분의 웹브라우저가 이것을 이용해 국제화 도메인 이름 지원
    - 예: '한글.com' → 'xn--bj0bj06e.com'