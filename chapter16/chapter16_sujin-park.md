# 16장 국제화

16장의 내용은 다음과 같습니다.

- HTTP가 어떻게 여러 언어 문자들의 체계 및 표준과 상호작용하는지 설명합니다.
- HTTP 프로그래머가 올바르게 업무를 수행하는데 도움이 될 수 있도록 전문용어, 기술, 표준의 간략한 개요를 제공합니다.
- 언어를 위한 표준 명명 체계와, 어떻게 표준화된 언어 태그가 선택한 콘텐츠를 서술하는지에 대해 설명합니다.
- 국제화된 URI의 규칙과 주의사항을 개괄적으로 서술합니다.
- 날짜와 그 외 다른 국제화 이슈에 대해 간단히 논의합니다.

## 16.1 국제적인 콘텐츠를 다루기 위해 필요한 HTTP 자원

`국제 콘텐츠를 지원하기 위해`, 서버는 클라이언트에게 각 문서의 문자와 언어를 알려줘서, 클라이언트가 올바르게 문서를 이루고 있는 비트들을 문자들로 풀어내고, 올바르게 처리해서 사용자에게 콘텐츠를 제공해줄 수 있도록 할 필요가 있습니다.

- 서버는 클라이언트에게 문서의 문자와 언어를 HTTP Content-Type charset 매개변수와 Content-Language 헤더를 통해 알려줌
- 클라이언트는 서버에게 자신이 어떤 차셋 인코딩 알고리즘들과 언어들을 이해하며 그 중 무엇을 선호하는지 말해주기 위해 Accept-Charset 과 Accept-Language 헤더를 전송

다음의 HTTP Accept 관련 헤더는 사용자의 브라우저가 iso-8859-1 서유럽어 차셋 인코딩과 UTF_8 유니코드 차셋 인코딩을 지원하는 것을 보여줍니다.

```
Accept-Language: fr, en;q=0.8
Accept-Charset: iso-8859-1, utf-8
```

## 16.2 문자집합과 HTTP

### 16.2.1 Charset 은 글자를 비트로 변환하는 인코딩이다

HTTP `Charset 값`은 어떻게 엔터티 콘텐츠 비트들을 특정 문자 체계의 글자들로 바꾸는지 말해줍니다.

각 차셋 태그는 비트들을 글자들로 변환하거나 혹은 그 반대의 일을 해주는 알고리즘을 명명하는데, MIME 문자집합에 표준화 되어있고, IANA 가 관리합니다.

`iso-8859-6 인코딩 구조`는 8비트 값을 숫자와 구두점 그리고 다른 기호들을 포함한 라틴 문자와 아랍 문자로 매핑합니다. 몇몇 문자 인코딩은 글자 당 비트 수가 일정하지 않아 더 복잡한 가변길이 코드로 중국어나 일본어와 같이 많은 글자로 이루어진 문자체계를 지원하기 위해 추가적으로 비트를 사용할 수 있게 해줍니다.

### 16.2.2 문자집합과 인코딩은 어떻게 동작하는가

비트들을 문자로 변환하는 디코딩 알고리즘을 지칭하고 적용하는 표준화 방법이 필요합니다.

`국제화된 문자 시스템의 핵심 목표`는 표현에서 의미를 분리하는 것입니다.

**비트를 문자로 변환하는 단계**

- 문서를 이루는 비트들은, 문자집합의 특정 문자로 식별될 수 있는 문자 코드로 변환
- 문자 코드는 코딩된 문자집합의 특정 요소를 선택하기 위해 사용
    - 단계 1,2에서 사용되는 알고리즘은 MIME 차셋 태그를 통해 결정

### 16.2.3 잘못된 차셋은 잘못된 글자들을 낳는다

만약 클라이언트가 잘못된 charset 매개변수를 사용한다면, 클라이언트는 이상한 깨진 글자를 보여주게 될 것입니다.

### 16.2.4 표준화된 MIME 차셋 값

특정 문자 인코딩과 특정 코딩된 문자집합의 결합을 `MIME 차셋`이라고 합니다. HTTP는 표준화된 MIME 차셋 태그를 Content-Type과 Accept-Charset 헤더에 사용합니다. MIME 차셋의 값은 IANA 에 등록이 되어있고 등록된 차셋 값들의 목록은 https://www.iana.org/numbers 에서 볼 수 있습니다.

### 16.2.5 Content-Type charset 헤더와 META 태그

```
Content-Type: text/html; charset=iso-2022-jp
```

- 웹 서버는 클라이언트에게 MIME 차셋 태그를 charset 매개변수와 함께 Content-TYpe 헤더에 담아 보냅니다.
- HTML 콘텐츠에서 문자 집합은 문자 집합을 서술하는 <META HTTP-EQUIV="Content-Type"> 태그에서 찾을 수 있습니다.
- 만약 클라이언트가 문자 인코딩을 추측하지 못했따면, iso-8859-1인 것으로 가정합니다.

### 16.2.6 Accept-Charset 헤더

`Accept-Charset`

HTTP 클라이언트는 서버에게 정확히 어떤 문자 체계를 그들이 지원하는지 요청 헤더를 통해 알려줍니다. Accept-Charset 헤더의 값은 클라이언트가 지원하는 문자 인코딩의 목록을 제공합니다.

```
Accept-Charset: iso-8859-1, utf-8
```

`Accept-Charset 요청 헤더에 대응하는 Content-Charset 응답 헤더는 존재하지 않는 다는 것`에 주의를 해야합니다. 응답 문자집합은 MIME 과의 호환을 위해 Content-Type 응답 헤더의 charset 매개변수를 통해 서버로부터 돌려받습니다.

## 16.3 다중언어 문자 인코딩에 대한 지침

### 16.3.1 문자집합 용어

**문자**
- 알파벳 글자, 숫자, 구두점, 표의문자, 기호 등 글쓰기의 최소 단위
- 여러 언어의 여러 글자에게 알맞고 유일한 이름을 부여하기 위한 표준화된 이름 집합이 개발되어 옴

**글리프(glyph)**
하나의 글자를 표혆기 위한, 획의 패턴이나 다른 것과 구분되는 유일한 시각적 형태

**코딩된 문자(coded character)**
우리가 글자를 다룰 수 있도록 각 글자에 할당된 유일한 숫자

**코드 공간**
문자 코드 값으로 사용하려고 계획해 둔 정수의 범위

**코드 너비**
각 문자 코드의 비트 개수

**사용 가능 문자집합**
글자들에 대한 특정한 작업 집합

**코딩된 문자집합**
사용 가능 문자집합을 받아섯 각 글자에 코드 공간의 코드를 할당해주는 코딩된 문자들의 집합

**문자 인코딩 구조**
숫자로 된 문자 코드들을 콘텐츠 비트의 연속으로 인코딩하는 알고리즘

### 16.3.2 `차셋(Charset)`은 형편없는 이름이다

`MIME 차셋 값`은 데이터 비트를 고유한 문자의 코드로 매핑하는 알고리즘의 이름으로 문자집합을 의미하는 것이 아닙니다.

### 16.3.3 문자

`문자`는 쓰기의 기본적인 구성요소로 하나의 문자는 하나의 알파벳 글자, 숫자, 구두점, 표의문자, 수학 기호, 다른 쓰기의 기본 단위를 표현합니다.

### 16.3.4 글리프, 연자 그리고 표현 형태

`글리프`는 그리는 특정한 방법으로 각 문자는 미적인 양식과 스크립트에 따라 여러 가지 글리프를 가집니다.

### 16.3.5 문자 인코딩 구조

**고정폭**

- 각 코딩된 문자를 고정된 길이의 비트로 표현
- 빠르게 처리될 수 있찌만 공간을 낭비할 우려가 있음

**가변폭(비모달)**

- 다른 문자 코드 번호에 다른 길이의 비트를 사용
- 자주 사용하는 글자의 비트 길이를 줄일 수 있고, 국제 문자는 이전의 8비트 문자집합과의 호환성 유지 가능

**가변폭(모달)**

- 다른 모드로의 전환을 위해 특별한 `escape` 헤더를 사용

> 8비트

각 문자 코드를 그에 대응하는 8비트 값으로 인코딩을 하고, 256개 문자의 코드 범위에 대한 문자집합만을 지원

> UTF-8

- UTF-8 은 문자 코드의 값을 위해 비모달 가변길이 인코딩을 사용
- 첫 바이트의 선두 비트들은 인코딩된 문자의 길이를 바이트 단위로 나타내고, 그 이후의 바이트들은 각각 6비트의 코드 값을 가짐


> euc-kr

`euc-kr` 은 한글 인터넷 문서를 위해 널리 사용되는 가변길이 인코딩으로 KS X 1003 과 KS X 1001의 두 가지 문자 집합을 지원합니다.

KS X 1001 은 2바이트로 인코딩 한글, 한자, 그 외 특수문자들로 이루어진 한국어 문자 집합이고, KS X 1003은 1바이트로 인코딩 되는 로마자 문자 집합입니다.

## 16.4 언어 태그와 HTTP

### 16.4.1 Content-Language 헤더

- Content-Language 헤더는 엔터티가 어떤 언어 사용자를 대상으로 하고 있는지 서술
- 오디오 클립, 동영상, 애플리케이션도 특정 언어 사용자를 대상으로도 할 수 있음
- 콘텐츠가 여러 언어 사용자를 대상으로 하고 있다면, 여러 언어를 나열 할 수 있음

```
Content-Language: mi, en
```

### 16.4.2 Accept-Language 헤더

웹 서버는 우리가 선호하는 언어로 된 콘텐츠를 줄 수 있습니다.
클라이언트는 자신이 이해할 수 있는 콘텐츠를 요청하기 위해 `Accept-Language`와 `Accept-Charset`를 사용할 수 있습니다.

### 16.4.3 언어 태그의 종류

언어 태그는 RFC 3066 로 문서화된 표준화된 문법을 갖고 있습니다.
- 일반적인 언어의 종류
- 특정 국가의 언어
- 방언
- 지방어
- 그 외의, 다른 언어의 변형이 아닌 표준 언어
- 비표준 언어

### 16.4.4 서브태그

언어 태그는 하이픈으로 분리된 하나 이상의 서브태그로 이루어져 있습니다.

- 첫 번째 서브태그는 주 서브태그, 값들은 표준화되어 있음
- 두 번째 서브태그는 선택적이고 자신만의 이름 표준을 따름
- 세 번째부터의 서브 태그는 등록되어 있지 않음

주 서브태그는 오직 A부터 Z까지의 글자만을 포함합니다. 다음 서브태그는 알파벳이나 숫자를 포함할 수 있고, 최대 8자까지 가능합니다.

### 16.4.5 대소문자의 구분 및 표현

- 모든 태그는 대소문자가 구분되지 않음
- 관용적으로 언어를 나타낼 때는 소문자 사용
- 국가를 나타낼 때는 대문자 사용

### 16.4.6 IANA 언어 태그 등록

`첫 번째와 두 번째 언어 서브태그의 값`은 여러 가지 표준 문서와 그것들을 관리하는 조직에 의해서 정의됩니다. 만약 언어 태그가 표준 국가와 언어 값의 조합이라면, 그 태그는 굳이 등록되지 않아도 무방합니다.

### 16.4.7 첫 번째 서브태그: 이름 공간

`첫 번째 서브태그`는 보통 ISO 639 표준 언어 집합에서 선택된 표준화된 언어 토큰

첫 번째 서브태그가,

- 두 글자라면, ISO 639와 639-1 표준의 언어 코드
- 세 글자라면, ISO 639-2 표준과 확장에 열거된 언어 코드
- 글자 'i'라면, 이 언어 태그는 틀림없이 IANA에 등록된 것
- 글자 'x'라면, 이 언어 태그는 특정 개인이나 집단 전용의 비표준 확장 서브태그

### 16.4.8 두 번째 서브태그: 이름공간

`두 번째 서브태그`는 보통 ISO 3166 국가 코드와 지역 표준 집합에서 선택된 표준화된 국가 토큰

두 번째 서브태그는,

- 두 글자라면, ISO 3166 에 정의된 국가/지역
- 3~8 글자라면, IANA에 등록된 것
- 한 글자라면, 뭔가 잘못된 것

### 16.4.9 나머지 서브태그: 이름공간

세 번째와 그 이후의 서브태그는 8자 이하의 알파벳과 숫자로 이루어져야 한다는 것을 제외하면 다른 규칙은 없음

### 16.4.10 선호 언어 설정하기

웹브라우저 프로필에서 선호 언어를 설정할 수 있습니다.

## 16.5 국제화된 URI

### 16.5.1 국제적 가독성 vs 의미 있는 문자들

URI 저자들은 리소스 식별자의 가독성과 공유 가능성의 보장이, 대부분의 의미 있는 문자들로 구성될 수 있도록 하는 것보다 더 중요하다고 여겨 오늘날 ASCII 문자들의 제한된 집합으로 이루어진 URI를 갖게 되었습니다.

### 16.5.2 URI에서 사용될 수 있는 문자들

URI에서 사용될 수 있는 US-ASCII 문자들의 부분집합은 예약된 문자들, 예약되지 않은 문자들, 이스케이프 문자들로 나뉩니다.

| 문자 분류 | 사용 가능 문자집합
|---|:---:|
| `예약되지 않음` | [A-Za-z0-9], "-" , "_" , "." , "!" , "~" , "*" , "'" , "(" , ")"
| `예약됨` | ";", "/", "?", "!", "@", "&", "=", "+", "$", ","
| `이스케이프` | "%"

### 16.5.3 이스케이핑과 역이스케이핑(unescaping)

**URI 이스케이프**

- 예약된 문자나 다른 지원하지 않는 글자들을 안전하게 URI에 삽입할 수 있는 방법을 제공
- %와 16진수 두 글자로 이루어진 세 글자 문자열, 16진수 두 글자는 US-ASCII 문자 코드

e.g)
```
http://www.joes-hardware.com/big%20sale.txt

-> %20 은 스페이스(아스키 32)
```

URI에 사용된 글자들은 `현재 문자집합에서 코드 바이트로 바뀌고`, URI를 해석할 때 이스케이핑된 코드 바이트들은 원래의 `ASCII 코드 바이트로 변환`됩니다.

**주의사항**

- 내부적으로 HTTP 애플리케이션은 URI를 데이터가 필요할 때만 언이스케이핑을 해야 합니다.

- `어떤 URI도 두 번 언이스케이핑 되지 않도록 주의`해야합니다.
    - 언이스케이핑하면 퍼센트 기호가 포함된 URI가 만들어지게 되는데 잘못하면 데이터 손실 유발

### 16.5.4 국제 문자들을 이스케이핑하기

`이스케이프 값은 US-ASCII 코드의 범위 (0 ~ 127)에 있어야 함에 주의`해야 합니다.
iso-8859-1 확장 문자들 (128 ~ 255)를 표현하기 위해 이스케이프 값을 사용하려고 하는데 이는 부정확하여  애플리케이션에서 문제를 유발할 수 있습니다.

## 16.6 기타 고려사항

- HTTP 헤더는 반드시 US-ASCII 문자집합의 글자들로만 이루어져야 합니다.
- HTTP 명세는 올바른 GMT 날짜 형식을 명확히 정의하고 있찌만 모든 웹 서버와 클라이언트가 규칙을 따르고 있지 않음에 주의해야 합니다.
- `국제화 도메인 이름`은 오늘날 대부분의 웹브라우저가 퓨니코드를 이용해 지원합니다.
    - `퓨니코드`란 유니코드 문자열을 호스트 명에서 사용 가능한 문자만으로 이루어진 문자열로 변환하는 방법입니다. (RFC 3492로 정의되어 있습니다.)