# 16. 국제화

* 월드 와이드 웹의 비전에 부응하기 위해 HTTP는 여러 언어와 문자로 된 국제 문서들의 처리와 전송을 지원해야 한다.
* 이 장에서 두 가지 주요 국제화(Internationalization) 이슈인 문자집합 인코딩과 언어 태그를 다룬다.
  * HTTP 애플리케이션은 여러 언어의 문자로 텍스트를 보여주고 요청하기 위해 문자집합 인코딩을 사용한다.
  * 이것을 사용자가 이해할 수 있는 언어만으로 콘텐츠를 서술하기 위해 언어 태그를 사용한다.
* 이 장에서 다루는 내용
  * HTTP가 어떻게 여러 언어 문자들의 체계 및 표준과 상호작용하는지 설명한다.
  * HTTP 프로그래머가 올바르게 업무를 수행하는데 도움이 될 수 있도록 전문용어, 기술, 표준의 간략한 개요를 제공한다.
  * 언어를 위한 표준 명명 체계와, 표준화된 언어 태그가 선택한 콘텐츠를 어떻게 서술하는지 설명한다.
  * 국제화된 URI의 규칙과 주의사항을 개괄적으로 서술한다.
  * 날짜와 그 외 국제화 이슈에 대해 간단히 논의한다.

## 16.1 국제적인 콘텐츠를 다루기 위해 필요한 HTTP 지원

* 국제 콘텐츠를 지원하기 위해 서버는 클라이언트에게 각 문서의 문자와 언어를 알려줘서, 클라이언트가 문서를 구성하는 비트를 문자로 풀어내고 올바르게 처리하여 사용자에게 콘텐츠를 제공해줄 수 있게 할 필요가 있다.
  * 서버는 HTTP `Content-Type charset` 매개변수와 `Content-Language` 헤더를 통해 클라이언트에게 문서의 문자와 언어를 알려준다.
* 동시에 클라이언트는 서버에게 사용자가 어떤 언어를 이해할 수 있고 어떤 알파벳의 코딩 알고리즘이 브라우저에 설치되어 있는지 말해줄 필요가 있다.
  * 클라이언트는 `Accept-Charset`과 `Accept-Language` 헤더를 통해, 서버에게 자신이 어떤 차셋 인코딩 알고리즘과 언어를 이해하며 그 중 무엇을 선호하는지 알려준다.
  * 다음 예시는 모국어인 프랑스어를 선호하지만 피치 못할 경우 영어도 사용하는 사용자가 보냈을 것이다. 이 사용자 브라우저는 iso-8859-1 서유럽어 차셋 인코딩과 UTF-8 유니코드 차셋 인코딩을 지원할 것이다.
    ```
    Accept-Language: fr, en;q=0.8
    Accept-Charset: iso-8859-1, utf-8
    ```
    * 매개변수 `q=0.8`은 품질 인자(quality factor)로, 프랑스어(기본값 1.0)보다 영어에 낮은 우선순위를 주었다.

## 16.2 문자집합과 HTTP

### 16.2.1 차셋(charset)은 글자를 비트로 변환하는 인코딩이다.

* HTTP 차셋 값은 어떻게 엔터티 콘텐츠 비트를 특정 문자 체계의 글자로 바꾸는지 말해준다.
* 각 차셋 태그는 비트들을 글자로 변환하거나 그 반대 일을 해주는 알고리즘을 명명한다.
* 차셋 태그는 등록된 MIME 문자집합에 표준화되어 있고, IANA가 관리한다. (참고: [IANA Character Sets](http://www.iana.org/assignments/character-sets/character-sets.xhtml))
* 다음 예시의 `Content-Type` 헤더는 수신자에게 콘텐츠가 HTML 파일임을, `charset` 매개변수는 수신자에게 콘텐츠 비트를 글자로 디코딩하기 위해 iso-8859-6 아랍 문자집합 디코딩 기법을 사용하라고 알려준다.
  ```
  Content-Type: text/html; charset=iso-8859-6
  ```
  * iso-8859-6 인코딩 구조는 8비트 값을 숫자와 구두점, 다른 기호들을 포함한 라틴 문자와 아랍 문자로 매핑한다.
    * `...11100001...`(십진수 225) --- `iso-8859-6 디코딩` ---> 아랍 글자 `ف`('FEH')
* 몇몇 문자 인코딩(UTF-8과 iso-2022-jp)은 글자 당 비트 수가 일정하지 않아 더 복잡한 가변길이 코드로, 중국어나 일본어처럼 많은 글자로 이루어진 문자체계를 지원하기 위해 추가적인 비트를 사용할 수 있다.

### 16.2.2 문자집합과 인코딩은 어떻게 동작하는가

* 세상에는 여러 종류의 문자가 있고, 글자를 비트로 인코딩하는 여러 방벙이 있기 때문에, 비트를 문자로 변환하는 디코딩 알고리즘을 지칭하고 적용할 표준화된 방법이 필요하다.
* 비트를 문자로 변환하는 과정
  * a) 문서를 이루는 비트들은 특정 코딩된 문자집합의 특정 문자(각각 번호가 매겨져 있다)로 식별될 수 있는 문자 코드로 변환된다.
    * 데이터비트: `11100001` --- `iso-8859-6 디코딩` ---> 디코딩된 문자 코드: `225`
  * b) 문자 코드는 코딩된 문자집합에서 특정 요소를 찾는데에 사용된다. iso-8859-6에서 값 225는 `ARABIC LETTER FEH`에 해당한다.
  * 단계 a, b에서 사용된 알고리즘은 MIME 차셋 태그를 통해 결정된다.
  * c) 글꼴과 포매팅 소프트웨어를 사용해 화면이 보여줄 글자 모양을 찾는다.
* 국제화된 문자 시스템의 주요 목표는 (시각적인)표현에서 의미(글자들)를 분리하는 것이다. HTTP는 문자 데이터 및 그와 관련된 언어와 차셋 라벨의 전송에만 관심을 갖는다.
* 단계 c 처럼 글자 모양을 어떻게 표현할 것이지는 사용자의 그래픽 디스플레이 소프트웨어(브라우저, 운영체제, 글꼴)가 결정한다.

### 16.2.3 잘못된 차셋은 잘못된 글자들을 낳는다

* 클라이언트가 잘못된 `charset` 매개변수를 사용하면 클라이언트는 이상하게 깨진 글자를 보여주게 된다.
* 브라우저가 본문으로부터 값 225를 가져온 경우에
  * 만약 브라우저가 본문이 iso-8859-1 서유럽 문자 코드로 인코딩되었다면, 양음 악센트(acute accent)가 붙은 소문자 라틴문자 'a'를 보여준다: `á`
  * iso-8859-6 아랍 코드를 사용하면 'FEH'를 보여준다: `ف`
  * iso-8859-7 그리스어를 사용한다면 작은 'Alpha'를 보여준다: `ɑ`
  * iso-8859-8 히브리어 코드를 사용하면 'BET'를 보여준다: `ב`

### 16.2.4 표준화된 MIME 차셋 값

* 특정 문자 인코딩과 특정 코딩된 문자집합의 결합을 MIME 차셋이라고 부른다.
* HTTP는 표준화된 MIME 차셋 태그를 `Content-Type`과 `Accept-Charset` 헤더에 사용한다.
* 브라우저에서 사용하는 MIME 차셋 인코딩 구조들: 부록 H 참고
  * `us-ascii`: 1968년 ANSI_X3.4-1968로 표준화된 유명한 문자 인코딩. ASCII로도 불리지만 ISO 646에는 여기서 선택된 글자들을 수정한 여러 가지 국제 변형이 있기 때문에 'US' 접두어를 붙인다. US-ASCII는 7비트 값을 128가지 글자에 대응시킨다. 하이 비트(high bit)는 사용되지 않는다.
  * `iso-8859-1`: 서유럽 언어를 지원하기 위한 ASCII의 8비트 확장이다. ASCII 코드(0-127)에 여러 서유럽 글자를 포함시키기 위한 하이 비트를 사용한다. iso-latin-1으로도 불리며 'Latin1'이란 별명도 있다.
  * `utf-8`: 전 세계 문자의 보편적 문자집합인 UCS(유니코드)를 표현하기 위해 흔히 쓰이는 가변길이 문자 인코딩 구조. 각 글자를 1에서 6바이트로 표현하는 가변길이 인코딩을 문자 코드 값에서 사용한다. UTF-8의 주요 기능 중 하나는 통상적인 7비트 아스키 문자열에 대한 하위호환성이다.

### 16.2.5 Content-Type charset 헤더와 META 태그

```
Content-Type: text/html; charset=iso-2022-jp
```

* 웹 서버는 MIME 차셋 태그를 charset 매개변수와 함께 `Content-Type` 헤더에 담아 보낸다.
* 문자집합이 명시적으로 나열되지 않았다면, 수신자는 문서의 콘텐츠로부터 문자집합을 추측한다. HTML 콘텐츠에서 문자집합을 서술하는 `<meta http-equiv="Content-Type">` 태그에서 찾을 수 있다.
  * 예) HTML Meta 태그에서 문자집합 설정
    ```html
    <html>
    <head>
      <meta http-equiv="Content-Type" content="text/html; charset=iso-2022-jp">
      <meta lang="jp">
      <title>A Japanese Document</title>
    </head>
    <body>
      ...
    </body>
    </html>
    ```
  * 문서가 HTML이 아니거나 Meta Content-Type 태그가 없다면, 소프트웨어는 언어와 인코딩에 대한 일반적 패턴을 찾기 위해 실제 텍스트를 스캐닝하여 문자 인코딩을 추측한다.
  * 클라이언트가 문자 인코딩을 추측하지 못하면 iso-8859-1인 것으로 가정한다.

### 16.2.6 Accept-Charset 헤더

* 대부분 클라이언트는 모든 종류의 문자 코딩과 매핑 시스템을 지원하지 않는다.
* HTTP 클라이언트는 서버에 `Accept-Charset` 요청 헤더를 통해, 정확히 어떤 문자 체계를 지원하는지 알려준다.
* Accept-Charset 헤더 값은 클라이언트가 지원하는 문자 인코딩 목록을 제공한다.
  * 예) 클라이언트가 서유럽 iso-8859-1 문자 시스템을 UTF-8 가변길이 유니코드 호환 시스템만큼 잘 받아들일 수 있음을 알려준다.
    ```
    Accept-charset: iso-8869-1, utf-8
    ```
  * 문자 인코딩 구조 중 어떤 것으로 콘텐츠를 반환할지는 서버의 자유다.
* `Accept-charset` 요청 헤더에 대응하는 Content-charset 응답 헤더는 존재하지 않는다.
  * 응답 문자집합은 MIME과의 호환을 위해 `Content-Type `응답 헤더의 charset 매개변수를 통해 서버로부터 돌려받는다.

## 16.3 다중언어 문자 인코딩에 대한 지침

### 16.3.1 문자집합 용어

##### 문자

* 알파벳 글자, 숫자, 구두점, 표의문자(중국어에서와 같은), 기호 등 글쓰기의 최소 단위
* 유니코드(Unicode)라고 불리는 국제 문자 세트(Universal Character Set, UCS) 계획에 따라 여러 언어의 여러 글자에 알맞고 유일한 이름을 부여하기 위한 표준화된 이름 집합이 개발되어 왔다.

##### 글리프(glyph)

* 하나의 글자를 표현하기 위한, 획의 패턴이나 다른 것과 구분되는 유일한 시각적 형태
* 하나의 글자를 여러 방식으로 쓸 수 있다면 글리프를 여러 개 가질 수도 있다.

##### 코딩된 문자(coded character)

* 우리가 글자를 다룰 수 있도록 각 글자에 할당된 유일한 숫자

##### 코드 공간(coding space)

* 문자 코드 값으로 사용하려고 계획해 둔 정수의 범위

##### 코드 너비(code width)

* 각 문자 코드의 (고정된 크기의) 비트 개수

##### 사용 가능 문자집합(character repertoire)

* 글자들에 대한 특정한 작업 집합(세상에 존재하는 모든 글자의 부분집합)

##### 코딩된 문자집합(coded character set)

* 사용 가능 문자집합을 받아서 각 글자에 코드 공간의 코드를 할당해주는 코딩된 문자들의 집합
* 실제 글자들에 숫자로 된 문자 코드를 대응시킨 것

##### 문자 인코딩 구조
* 숫자로 된 문자 코드들을 콘텐츠 비트의 연속으로 인코딩하는(그리고 다시 원래대로 디코딩하는) 알고리즘
* 문자 인코딩 구조는 글자를 식별하기 위해 필요한 데이터의 양을 줄이거나(압축), 전송상의 어떤 제약을 회피하거나, 중복된 코딩된 문자집합을 통합하는데 사용된다.

### 16.3.2 '차셋(Charset)'은 형편없는 이름이다

* 엄밀히 말해, `Content-Type` `charset` 매개변수와 `Accept-Charset` 헤더에서 쓰이는 MIME 차셋 태그는 문자집합을 의미하는 것이 결코 아니다.
* MIME 차셋 값은 데이터 비트를 고유한 문자의 코드로 매핑하는 알고리즘의 이름이다. 이는 문자 인코딩 구조와 코딩된 문자집합의 개념을 합친 것이다.
* 이 용어는 엉성하고 혼란스러운데, 이미 문자 인코딩 구조와 코딩된 문자집합에 대한 출판된 표준이 존재하기 때문이다. 표준 문서를 읽을 때 정확히 무엇이 정의되어 있는지 확인해야 한다.
  * MIME 차셋 태그는 코딩된 문자집합이나 인코딩 구조의 이름을 끌어들인다. iso-8859-1은 코딩된 문자집합이지만, MIME은 코딩된 문자집합의 8비트 아이덴티티 인코딩(입력받고 아무것도 하지 않고 그대로 출력하는 인코딩)을 의미하기 위해 차셋 값 `iso-8859-1`을 사용한다. 이 애매한 용어는 치명적이지는 않지만 이 전제에 대해 확실히 알아야 한다.

### 16.3.3 문자

* 문자는 쓰기의 기본적 구성 요소로, 하나의 알파벳 글자, 숫자, 구두점, 표의문자, 수학기호, 그 외 다른 쓰기의 기본 단위를 표현한다.
* 문자는 글꼴이나 스타일이 독립적이다. 'LATIN SMALL LETTER A'로 불리는 같은 문자에도 여러 변형이 있다.
* 같은 글자라도 그 글자가 단어의 어디에 위치하느냐에 따라 다른 모양을 갖는 표기 체계도 많다.

### 16.3.4 글리프(glyphs), 연자(ligatures) 그리고 표현 형태

* 문자는 유일하고 추상하된 언어 요소이다.
* 글리프는 각 글자를 그리는 특정한 방법이다. 각 문자는 미적 양식과 스크립트에 따라 여러 가지 글리프를 가진다.
* 쓰기를 보다 멋지게 보이도록 하려고 많은 필기체와 활자체가 인접 글자들이 부드럽게 이어지는 연자(ligature)를 지원한다. 예) `Accept-Language: es`
* 영어의 FI 연자
* 일반적인 규칙은 글리프 하나를 다른 것으로 바꾸었을 때 텍스트의 의미가 바뀐다면, 그 두 글리프는 서로 다른 글자다. 아니라면 모양만 다를 뿐 같은 글자다.

### 16.3.5 코딩된 문자집합(Coded Character Set)

* RFC 2277과 2130에서 정의된 코딩된 문자집합은 정수와 글자를 대응시킨다.
* 코딩된 문자집합은 보통 코드 번호로 인덱싱된 배열로 구현되며, 그 배열의 원소는 문자들이다.
* `코드 68(0x44)` --- `US-ASCII 코딩된 문자집합` ---> `'LATIN CAPITAL LETTER D'`

##### US-ASCII: 모든 문자집합의 어머니

* 아스키는 1968년 ANSI 표준 X3.4 '정보 교환을 위한 미국 표준 코드'로 표준화된 가장 유명한 코딩된 문자집합이다.
* 아스키는 오직 코드 값 0-127만 사용한다. 따라서 코드 공간을 전체를 표현하는데 7비트만이 필요하다.
* 이 문자집합의 다른 국제 변종과 구분하기 위해 'US-ASCII'라는 이름을 사용한다.
* HTTP 메시지(헤더, URI 등)는 US-ASCII를 사용한다.

##### iso-8859

* 국제적인 글쓰기를 위해 필요한 글자를 하이 비트를 이용하여 추가한, US-ASCII의 8비트 확대 집합들이다.
* 추가 비트에 의해 제공되는 추가 공간은 모든 유럽 글자를 담기에 충분히 크지 않으므로, iso-8859는 지역에 따라 커스터마이징된 문자집합을 제공한다.
  * iso-8859-1: 서유럽어(프랑스어, 영어)
  * iso-8859-2: 중앙 및 동유럽어(체코어, 폴란드어)
  * iso-8859-3: 남유럽어
  * ...
  * iso-8859-6: 아랍어
  * iso-8859-15: 새로운 유로 통화 문자를 포함하기 위한 iso-8859-1의 변형
* Latin1로도 알려진 iso-8859-1은 HTML을 위한 기본 문자집합이다. 대부분의 유럽어 텍스트 표현을 할 수 있다.

##### JIS X 0201

* 아스키를 일본어 가타카나 반각문자를 더해 확장한 극단적으로 작은 문자집합이다.
* 가타카나 반각 문자는 원래 일본의 전신 체계에서 쓰이던 것이다.
* JIS X 0201은 보통 'JIS Roman'으로 불린다. JIS는 Japanese Industrial Standard(일본 산업 표준)의 줄임말이다.

##### JIS X 0208과 JIS X 0212

* 일본어는 여러 문자 체계로부터 온 수천 개의 글자를 담고 있다. JIS X 0201의 63개 표음 가타카나 문자로 어렵게나마 표현이 가능하지만, 실질적 사용을 위해서는 더 완전한 문자집합이 필요하다.
* JIS X 0208 문자집합은 최초 멀티바이트 일본어 문자집합이다. 대부분이 일본식 한자인 6,879개의 코딩된 문자를 정의했다.
* JIS X 0212 문자집합은 6,607개 문자를 추가했다.

##### UCS

* 국제 문자 세트(Universial Character Set, UCS)는 전 세계 모든 글자를 하나의 코딩된 문자집합으로 통합하려 노력하는 세계적 표준이다.
* UCS는 ISO 10646으로 정의된다.
* 유니코드는 UCS 표준을 따르는 상업적인 컨소시엄이다.
* UCS는 기본 집합은 단 5만 글자만으로 이루어져 있음에도 불구하고, 수백만 개의 글자를 위한 코드 공간을 갖고 있다.

### 16.3.6 문자 인코딩 구조

* 문자 인코딩 구조들은 숫자로 된 문자 코드를 콘텐츠 비트로 변환하고, 다른 쪽에서는 그들을 다시 문자 코드로 환원한다.

#### 문자 인코딩 구조의 세 종류

##### 고정폭

* 고정폭 인코딩은 각 코딩된 문자를 고정된 길이의 비트로 표현한다.
* 빠르게 처리될 수 있으나 공간을 낭비할 우려가 있다.

##### 가변폭(비모달)

* 가변폭 인코딩은 다른 문자 코드 번호에 다른 길이의 비트를 사용한다.
* 자주 사용하는 글자의 비트 길이를 줄일 수 있고, 국제 문자에 대해 여러 바이트를 사용하게 함으로써 이전 8비트 문자집합과의 호환성도 유지할 수 있다.

##### 가변폭(모달)

* 모달 인코딩은 다른 모드로의 전환을 위해 특별한 'escape' 패턴을 사용한다.
* 어떤 모달 인코딩은 텍스트에서 중첩된 여러 가지 문자집합 간 전환을 위해 사용될 수 있다.
* 모달 인코딩은 처리하기 복잡하나, 복잡한 표기 체계를 효과적으로 지원할 수 있다.

#### 인코딩 구조

##### 8비트

* 8비트 고정폭 아이덴티티 인코딩은 간단히 각 문자 코드를 그에 대응하는 8비트 값으로 인코딩한다.
* 256개 문자의 코드 범위에 대한 문자집합만을 지원한다.
* iso-8859 문자집합군은 8비트 아이덴티티 인코딩을 사용한다.

##### UTF-8

* 인기있는 UCS(UTF는 UCS Transformation Format의 약자)를 위해 설계된 문자 인코딩 구조다.
* UTF-8은 문자 코드의 값을 위해 비모달 가변길이 인코딩을 사용한다.
* 첫 바이트의 선두 비트는 인코딩된 문자의 길이를 바이트 단위로 나타내고, 그 이후 바이트는 각각 6비트의 코드 값을 담는다.
* 첫 번째 인코딩된 바이트의 하이 비트가 0이면, 길이는 단 1바이트다. 남은 7비트는 문자 코드를 담는다. 이 때문에 아스키와의 호환된다. (iso-8859는 하이비트를 사용하기 때문에 호환되지 않는다)

##### euc-kr

* 한글 인터넷 문서를 위해 널리 사용되는 가변길이 인코딩으로 KS X 1003과 KS X 1001의 두 가지 문자 집합을 지원한다.
* KS X 1003은 1바이트로 인코딩되는 로마자 문자 집합으로, 사실 US-ASCII에서 역슬래시를 원화 기호로 치환하기만 한 것이다.
* KS X 1001은 2바이트로 인코딩되는 한글, 한자, 그 외 특수문자들로 이루어진 한국어 문자집합이다.
  * KS X 1001이 담고 있는 한글은 총 2,350자로 한글을 모두 표현하기에는 턱없이 부족하다. 이를 보완하기 위해 한글 채움 문자(fill code, euc-kr에서는 0xA4 0xD4)를 이용해 한글을 표현하는 방식을 규정한다.
    * 한글 문자 한 개를 `(채움) 초성 중성 종성`으로 표현하는 것이다: `똠`을 `(채움) ㄸ ㅗ ㅁ`으로 표현한다.

## 16.4 언어 태그와 HTTP

* 언어 태그는 언어에 이름을 붙이기 위한 짧고 표준화된 문자열이다.
  * 한국어 ko, 영어 en, 독일어 de
  * 미국 영어 es-US, 허난 중국어 zh-xiang

### 16.4.1 Content-Language 헤더

* `Content-Language` 엔터티 헤더 필드는 엔터티가 어떤 언어 사용자를 대상으로 하는지 서술한다.
* 주로 프랑스어 사용자를 대상으로 한다면 `Content-Language: fr`로 표현한다.
* `Content-Language` 헤더는 텍스트 문서만을 위한 것이 아니다. 오디오, 동영상, 애플리케이션도 특정 언어 사용자를 대상으로 할 수 있다. 특정 언어 사용자를 대상으로 하는 어떤 종류의 미디어라도 `Content-Language` 헤더를 가질 수 있다.
* 콘텐츠가 여러 언어 사용자를 대상으로 한다면 여러 언어를 나열할 수 있다: `Content-Language: mi, en`
* 단지 여러 언어가 하나의 엔터티에 동시에 사용되었다고 해서 반드시 여러 언어를 대상으로 하고 있음을 의미하는 것은 아니다. 콘텐츠가 명확하게 특정 언어 사용자들에게 제공된다면 하나만을 포함하는 것이 맞다. (한국인 대상 영어 학습서일 경우 'ko'만 포함)

### 16.4.2 Accept-Language 헤더

* HTTP는 우리에게 우리 언어의 제약과 선호도를 웹 서버에 전달할 수 있게 한다. 웹 서버가 어떤 자원의 여러 언어 버전을 갖고 있다면, 우리가 선호하는 언어의 콘텐츠를 보내줄 수 있다.
* `Accept-Language`와 `Accept-Charset` 헤더를 통해 클라이언트가 이해할 수 있는 콘텐츠 요청을 할 수 있다.
* 예) 스페인어로 된 콘텐츠에 대한 클라이언트의 요청: `Accept-Language: es`

### 16.4.3 언어 태그의 종류

* 언어 태그는 [RFC 3066 "Tags for the Identification of Languages"](https://tools.ietf.org/html/rfc3066)의 표준화된 문법을 갖고 있다.
* 언어 태그는 다음을 표현하기 위해 사용할 수 있다.
  * 일반적인 언어 종류: 스페인어를 의미하는 `es`
  * 특정 국가의 언어: 영국 영어를 의미하는 `en-GB`
  * 방언: 노르웨이의 'Book Language'를 의미하는 `no-bok`
  * 지방어: 마서스 비니어드 섬의 수화를 의미하는 `sgn-US-MA`
  * 그 외, 다른 언어의 변형이 아닌 표준 언어: `i-navajo`
  * 비표준 언어: `x-snowboarder-slang`

### 16.4.4 서브 태그

* 언어 태그는 하이픈으로 분리된 하나 이상의 서브태그로 이루어져 있다.
* 첫 번째 서브태그는 주 서브태그라 불리며, 이 값은 표준화되어 있다.
* 두 번째 서브태그는 선택적이고 자신만의 이름 표준을 따른다.
* 세 번째부터 서브태그는 등록되어 있지 않다.
* 주 서브태그는 오직 A부터 Z까지의 글자만을 포함한다. 다음 서브태그는 알파벳이나 숫자를 포함할 수 있으며 최대 8자까지 가능하다.
  * ex) 마서스 비니어드 섬의 수화: `sgn-US-MA`
    * `sgn` 첫 번째 서브태그(수화)
    * `US` 두 번째 서브태그(미국)
    * `MA` 세 번째 서브태그(매사추세츠 지역 변종)

### 16.4.5 대소문자의 구분 및 표현

* 모든 태그는 대소문자 구분을 하지 않는다. `en`과 `eN`은 같다.
* 관용적으로 언어는 소문자, 국가는 대문자를 사용한다.
  * `fr`은 프랑스어로 분류되는 모든 언어를, `FR`은 국가 프랑스를 의미한다.

### 16.4.6 IANA 언어 태그 등록

* 첫 번째와 두 번째 언어 서브태그 값은 여러 표준 문서와 그 관리 조직에 의해 정의된다. IANA는 [RFC 3066](https://tools.ietf.org/html/rfc3066) 규칙에 따라 표준 언어 태그의 목록을 관리한다.
* 언어 태그가 표준 국가와 언어 값의 조합이면, 그 태그는 굳이 등록되지 않아도 무방하다.
* 오직 표준 국가와 언어 값으로 구성될 수 없는 언어 태그들만이 특별히 IANA에 의해 등록될 필요가 있다.

### 16.4.7 첫 번째 서브태그: 이름공간

* 첫 번째 서브태그는 보통 ISO 639 표준 언어 집합에서 선택된 표준화된 언어 토큰이다.
* 그러나 또한 IANA에서 등록한 이름을 의미하는 글자 `i`일 수도 있고, 특정 집단의 전용 확장 이름임을 의미하는 `x`일 수도 있다.
* 규칙은 만약 첫 번째 서브태그가
  * 두 글자라면: ISO 639와 639-1 표준의 언어 코드다.
  * 세 글자라면: ISO 639-2 표준과 확장에 열거된 언어 코드다.
  * 글자 `i`라면: 틀림없이 IANA에 등록된 것이다.
  * 글자 `x`라면: 특정 개인이나 집단 전용 비표준 확장 서브태그다.
* ISO 639/639-2 이름의 예
  * 아랍어: ar / ara
  * 영어: en / eng
  * 프랑스어: fr / fra(fre)
  * 일본어: ja / jpn
  * 한국어: ko / kor

### 16.4.8 두 번째 서브태그: 이름공간

* 보통 ISO 3166 국가 코드와 지역 표준 집합에서 선택된 표준화된 국가 토큰이다. IANA에 등록된 다른 문자열일 수도 있다.
* 규칙은 두 번째 서브태그가
  * 두 글자라면: ISO 3166에 정의된 국가/지역이다.
  * 3~8글자라면: IANA에 등록된 것이다.
  * 한 글자라면: 뭔가 잘못된 것이다.
* ISO 3166 국가 코드의 예
  * 교황청(바티칸 시국): VA
  * 독일: DE
  * 미국: US
  * 영국: GB
  * 한국: KR

### 16.4.9 나머지 서브태그: 이름공간

* 세 번째와 그 이후 서브태그는 8자 이하 알파벳과 숫자로 구성되어야 한다는 것을 제외하면 다른 규칙은 없다.

### 16.4.10 선호 언어 설정하기

* 웹브라우저 프로필에서 선호 언어를 설정할 수 있다.

### 16.4.11 언어 태그 참조표

* 부록 G 참고

## 16.5 국제화된 URI

* **(옮긴이 주석)** 오늘날 URI에 대한 최신 명세인 [RFC 3986](https://tools.ietf.org/html/rfc3986)은 URI에 UTF-8 문자를 사용할 수 있는 방법을 명시적으로 제시하고 있으므로, 다양한 문자들을 별 문제없이 사용할 수 있다.

### 16.5.1 국제적 가독성 vs 의미 있는 문자들

* 전 세계 모두가 URI에 들어가고 조작하고 공유하기 쉽게 하기 위해 매우 제한된 공통 문자집합(기본적 라틴 알파벳 문자, 숫자, 몇 개의 특수문자)를 선택했다. 이 작은 문자집합은 대부분 소프투웨어와 키보드에서 지원된다.
* 문자집합에는 제한이 있기 때문에, URI는 비영어권 사람들이 그들의 문자로 만들도록 설계되지는 못했다. 전 세계 많은 시민이 라틴 알파벳을 인식조차 하지 못하므로 URI를 추상화된 패턴으로 기억하는 것은 거의 불가능하다.
* URI 저자들은 리소스 식별자의 가독성, 공유 가능성의 보장이 의미 있는 문자로 구성되게 하는 것보다 더 중요하다고 여겼고, 오늘날 ASCII 문자들의 제한된 집합으로 이루어진 URI를 갖게 되었다.

### 16.5.2 URI에서 사용될 수 있는 문자들

* URI에서 사용할 수 있는 US-ASCII 문자들의 부분집합은 예약된 문자들, 예약되지 않은 문자들, 이스케이프 문자들로 나뉜다.
* 예약되지 않은 문자들은 그를 허용하는 URI의 어떤 구성요서에서든 일반적으로 사용될 수 있다.
* 예약된 문자들은 URI에서 특별한 의미를 가지기 때문에 일반적으로 사용될 수 없다.
* 문자 분류와 사용가능 문자집합
  * 예약되지 않음: `[A-Za-z0-9]|"-"|"_"|"."|"!"|"~"|"*"|"'"|"("|")"`
  * 예약됨: `";"|"/"|"?"|":"|"@"|"&"|"="|"+"|"$"|","`
  * 이스케이프: `"%" <HEX> <HEX>`

### 16.5.3 이스케이핑과 역이스케이핑(unescaping)

* URI 이스케이프는 예약된 문자나 다른 지원하지 않는 글자들(스페이스와 같이)을 안전하게 URI에 삽입하는 방법을 제공한다.
* 이스케이프는 퍼센트 글자 `%` 하나와 뒤이은 16진수 글자 둘로 이루어진 세 글자 문자열이다.
* 16진수 두 글자는 US-ASCII 문자의 코드를 나타낸다.
* URL에 스페이스(아스키 32)를 나타내고 싶다면 이스케이프 `%20`을 사용할 수 있다. 20은 32의 16진법 표현이기 때문이다.
* 퍼센트 기호를 넣고 싶다면 퍼센트 기호의 아스키 코드 25를 사용하여 `%25`로 입력한다.
* URI를 해석할 때, 이스케이핑된 코드 바이트들은 원래의 ASCII 코드 바이트로 변환된다.
* 내부적으로 HTTP 애플리케이션은 URI를 데이터가 필요할 때만 언이스케이핑 해야 한다. 또한 애플리케이션은 어떤 URI도 결코 두 번 언이스케이핑되지 않도록 주의해야 한다. 데이터 손실이 생길 수도 있기 때문이다.

### 16.5.4 국제 문자들을 이스케이핑하기

* 이스케이프 값들은 US-ASCII 코드의 범위(0~127)에 있어야 한다.
* 어떤 애플리케이션은 iso-8859-1 확장 문자들(128~255)을 표현하기 위해(예: 국제 문자를 포함한 파일 이름을 부호화하기 위해) 이스케이프 값을 사용하려 하는데, 이는 부정확하며 어떤 애플리케이션에서 문제를 유발할 수도 있다.
* 움라우트를 포함한 파일이름 `Sven Ölssen.html`은 웹 서버에 의해 `...%20%D6...`로 인코딩되었을 수 있다.
  * 스페이스를 %20으로 인코딩한 것은 괜찮지만 엄밀하게 Ö를 %D6으로 인코딩한 것은 잘못이다. 코드 D6(십진수 214)는 ASCII 범위 밖에 있기 때문이다.
    * (옮긴이) 그러나 오늘날은 흔히 ASCII 범위 밖 문자를 인코딩한다.
  * ASCII는 오직 0x7F(십진수 127)까지의 코드만을 정의한다.

### 16.5.5 URI에서의 모달 전환

* 몇 URI는 다른 문자집합의 글자 표현을 위해 ASCII 문자열을 사용한다.
  * iso-2022-jp 인코딩은 JIS-Roman으로 변경하기 위해 `ESC ( J`를 삽입할 수 있으며 `ESC ( B`로 다시 ASCII로 돌아올 수 있다.
* 현재(당시) URI는 그다지 국제호에 친화적이지 않다. URI 이식성의 목표는 언어 유연성의 목표보다 중요했다.
* URI 국제화의 노력은 현재 진행 중이지만 당분간 HTTP 애플리케이션은 ASCII와 함께 해야 한다.

## 16.6 기타 고려사항

### 16.6.1 헤더와 명세에 맞지 않는 데이터

* HTTP 헤더는 반드시 US-ASCII 문자집합의 글자로만 이루어져야 한다.
* 그러나 모든 클라이언트와 서버가 이를 올바르게 구현한 것은 아니라 잘못된 문자를 받을 수도 있다.
* 많은 HTTP 애플리케이션은 글자 처리를 위해 운영체제와 라이브러리 루틴을 사용한다. (예: 유닉스 ctype 문자 구분 라이브러리)
  * 모든 라이브러리가 ASCII 범위(0~127)를 벗어난 글자를 지원하지는 않는다.
  * 몇 상황에서는 이 라이브러리들은 ASCII가 아닌 글자가 주어졌을 때 부적절한 결과를 반환하거나 충돌을 일으킨다.
* HTTP 메시지 처리를 위해 문자구분 라이브러리를 사용하기 전, 메시지에 잘못된 데이터가 포함된 경우를 대비해 그 라이브러리의 문서를 주의깊게 읽어라.

### 16.6.2 날짜

* HTTP 명세는 올바른 GMT 날짜 형식을 명확히 정의하고 있으나, 모든 웹 서버와 클라이언트가 규칙을 따르는 것은 아니다.
* HTTP 애플리케이션은 명세에 맞지 않는 날짜를 관대하게 받아들이고, 받아들이면서 충돌을 일으키지 말아야 한다.
* 날짜를 파싱할 수 없다면 서버는 보수적으로 그것을 다뤄야 한다.

### 16.6.3 도메인 이름

* 국제화 문자를 포함하는 도메인 이름을 '국제화 도메인 이름(Internationalizing Domain Name)'이라고 하는데, 오늘날 대부분 웹브라우저가 퓨니코드(punycode)를 이용해 이를 지원한다.
* 퓨니코드란 문자열을 호스트 명에서 사용 가능한 문자만으로 이루어진 문자열로 변환하는 방법으로, [RFC 3492](https://tools.ietf.org/html/rfc3492)로 정의되어 있다.
* 이 기법을 이용해 웹브라우저들은 사용자가 입력한 다국어로 된 도메인 이름을 알파벳과 숫자 등으로 된 도메인 이름으로 변환한다.
  * 예) '한글.com' -> 'xn-bj0bj06e.com'

## 16.7 추가 정보
### 16.7.1 부록
### 16.7.2 인터넷 국제화
### 16.7.3 국제 표준