책은 HTTP/2.0의 [8번째 초안](https://tools.ietf.org/html/draft-ietf-httpbis-http2-08#section-4.1) 기준으로 작성되어있으며, 책 내용에 [RFC 7540](https://tools.ietf.org/html/rfc7540) 내용을 추가하였다.

## 10.1 HTTP/2.0의 등장 배경

- HTTP/1.1의 메세지 포맷은 구현의 단순성, 접근성에 주안점을 두고 최적화 되다보니, 성능에 희생이 있었음
    - 심각한 회전 지연(latency)가 있었고, 이를 회피하기 위해 병렬 커넥션, 파이프라인 커넥션이 도입되었지만 근본적인 해결책은 아니었음.
- 이 문제 해결을 위해 여러 노력이 있었고, 그 중 구글이 기존의 HTTP에 속도 개선을 위한 기능을 추가한 프로토콜인 SPDY(스피디)를 내놓았음
    - 헤더 압축하여 대역폭 절약
    - 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연 줄이기
    - 클라이언트가 요청을 보내지 않아도 서버가 능동적으로 리소스를 푸시
- HTTP 작업 그룹은 SPDY를 기반으로 HTTP/2.0 초안을 만들기 시작하였음

## 10.2 개요

- HTTP/2.0은 서버와 클라이언트의 TCP 커넥션 위에서 동작. TCP 커넥션을 초기화 하는 것은 클라이언트
- HTTP/2.0 요청, 응답은 길이가 정의된(최대 16383바이트) 한 개 이상의 프레임에 담김.
    - HTTP 헤더는 압축되어 담김
- 프레임에 담긴 요청/응답은 스트림을 통해 보내지며, 한 개의 스트림이 한 쌍의 요청/응답을 처리
    - 한 커넥션 위에 여러 개의 스트림이 동시에 만들어질 수 있어, 여러 개의 요청/응답 동시 처리 가능
- 스트림에 대한 흐름 제어와 우선순위 부여 기능 제공
- **서버 푸시**:
    - 서버가 클라이언트에게 필요하다고 생각하는 리소스라면, 요청을 명시적으로 받지 않더라도 클라이언트에게 능동적으로 보낼 수 있음
    - 최근의 HTTP/2.0과 3.0에는 제거 됨. [참고 링크1](https://evertpot.com/http-2-push-is-dead/), [참고 링크 2](https://groups.google.com/a/chromium.org/g/blink-dev/c/K3rYLvmQUBY/m/vOWBKZGoAQAJ?pli=1)
- 호환성 유지를 위해, 요청/응답 메시지의 의미를 동일하게 유지하였으나, 일부 표현하는 문법은 변경됨
    - `Content-Length` 헤더 → `.content-length`
    - 상태 줄에서 표현되는 `404 Not Found` → `.status` 헤더에 `404` 로 제공

## 10.3 HTTP/1.1과의 차이점

### 10.3.1 프레임

- 모든 메시지는 프레임에 담겨 전송.
    - 프레임은 8바이트 크기의 헤더로 시작하여, 16383바이트 크기의 페이로드가 옴

```
+-----------------------------------------------+
|                 Length (24)                   |
+---------------+---------------+---------------+
|   Type (8)    |   Flags (8)   |
+-+-------------+---------------+-------------------------------+
|R|                 Stream Identifier (31)                      |
+=+=============================================================+
|                   Frame Payload (0...)                      ...
+---------------------------------------------------------------+
```

- 프레임 헤더의 각 필드(RFC 7540 발췌)
    - **Length(길이)**: 페이로드의 길이를 나타내는 24비트 무부호 정수(unsigned integer). 2^14(16,384) 보다 큰 값이 오면 안됨. 이 길이에 프레임 헤더는 미포함.
    - **Type(타입)**: 프레임의 타입을 타나내는 8비트.
    - **Flags(플래그)**: 8비트 플래그. 플래그 값의 의미는 프레임 종류에 따라 다름.
    - **R**: 예약된 1비트 필드. 값의 의미가 정의 되어있지 않으며 반드시 0이여야함. 받는 쪽에서는 값을 무시
    - **Stream Identifier(스트림 식별자)**: 31비트 무부호 정수로 표현된 스트림 식별자. 특별히 0 값은 개별 스트림이 아닌 커넥션 전체와 연관된 프레임을 의미하는 것으로 예약 되어있음.
- HTTP/2.0은 `DATA`, `HEADERS`, `PRIORITY`, `RST_STREAM`, `SETTINGS`, `PUSH_PROMISE`, `PING`, `GOAWAY`, `WINDOW_UPDATE`, `CONTINUATION` 이라는 총 10개의 프레임을 정의하고 있으며, 페이로드의 형식이나 내용은 프레임 종류에 따라 다름.
    - 자세한 설명은 RFC 7540의 ["6. Frame Definitions"](https://tools.ietf.org/html/rfc7540#section-6) 참고.

### 10.3.2 스트림과 멀티플렉싱

- **스트림**: HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀슷
- 한쌍의 요청/응답은 하나의 스트림을 통해 이루어짐.
    - 클라이언트는 새 스트림을 만들어 그를 통해 HTTP 요청을 보내고, 서버는 요청과 같은 스트림으로 응답을 보냄. 이후 스트림은 닫힘
- HTTP/1.1은 TCP 커넥션으로 요청을 보내면, 응답 받기 전까지는 같은 커넥션으로 요청을 보낼 수 없어 회전 지연을 피하기 어려움
    - 회전 지연을 줄이기 위해 TCP 커넥션을 여러 개 만들지만, 무한정 만들 수 없음.
- HTTP/2.0은 한 커넥션에 여러 개의 스트림이 동시에 열릴 수 있어 쉽게 해결됨.
- 스트림은 우선 순위가 있음
    - 네트워크 대역폭이 충분치 않아 프레임 전송이 느리다면, 웹 브라우저는 중요한 리소스(예: 이미지보다 HTML)를 요청하는 리소스에게 더 높은 우선순위 부여 가능
    - 단, 우선순위에 따르는 것은 의무 사항이 아니므로, 요청 우선순위대로 처리된다는 보장은 없음
- 모든 스트림은 31비트의 무부호 정수로된 고유한 식별자를 가짐.
    - 스트림 초기화 주체가 클라이언트면 홀수, 서버면 짝수
    - 새 스트림의 식별자는 이전에 만들어지거나 예약된 스트림의 식별자보다 커야 함
    - 이 규칙을 어기는 식별자를 받았다면 에러코드가 `PROTOCOL_ERROR` 인 커넥션 에러로 응답해야 함
- 서버/클라이언트는 스트림을 상대방과 협상 없이 일방적으로 만듦
    - 스트림 만들 때 협상을 위해 TCP 패킷을 주고 받는 시간 낭비를 하지 않기 위함
- 동시에 여러 스트림을 사용하면 스트림이 블록될 우려가 있다는 주장에 의해, `WINDOW_UPDATE` 프레임을 이용한 흐름 제어(flow control)을 통해, 스트림들이 서로 간섭해서 망가지는 것을 막음

### 10.3.3 헤더 압축

- 요즘 웹 페이지는 수 십~수 백번의 요청을 보내기 때문에, 헤더의 크기가 회전 지연 및 대역폭에 영향을 끼침
- HTTP/2.0은 헤더를 압축하여 보냄.(HTTP/1.1은 무압축)
    - 헤더는 HPACK 명세에 정의된 헤더 압축 방법으로 압축된 뒤, '헤더 블록 조각'들로 쪼개져서 전송.
    - 받는 쪽에서는 이 조각을 이은 뒤 압축을 풀어 원레 헤더 집합으로 복원
- HPACK 헤더를 압축하고 해제 할 때 '압축 콘텍스트(compression context)'를 사용
    - 압축 콘텍스트는 수신한 헤더의 압축을 풀면 변경 됨. 송신측은 이를 가정함.
    - 수신 측은 어떤 경우에도(헤더를 안쓰더라도) 헤더 압축 해제를 수행하고, 불가하다면  `COMPRESSION_ERROR` 와 함께 커넥션 끊어야 함.

### 10.3.4 서버 푸시

- 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있도록 해줌
    - 서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에 유용
    - 이는 클라이언트가 HTML 파싱 후 필요 리소스를 다시 요청하느라 발생하는 트래픽 및 회전 지연을 감소
- 리소스를 푸시하려는 서버는 클라이언트에게 `PUSH_PROMISE` 프레임을 보내 푸시할 것임을 미리 알림
    - 클라이언트가 그 프레임을 받으면, 그 프레임의 스트림은 클라이언트 입장에서 '예약됨(원격)' 상태가 됨
    - 클라이언트가 `RST_STREAM` 프레임을 보내 푸시를 거절할 수 있음. 보내면 그 스트림은 바로 닫힘
    - 스트림이 닫히기 전까지는 서버가 푸시하려고 하는 리소스를 요청해서는 안됨
- 사전에 서버가 `PUSH_PROMISE` 프레임을 보내는 이유는, 서푸시하려는 자원을 클라이언트가 별도로 요청하는 상황을 피하기 위함
- 서버 푸시 사용시 주의사항
    - 서버 푸시를 사용하기로 했더라도, 중간 프락시가 추가 리소스를 클라이언트에게 전달 안하거나, 반대로 서버로부터 받지 않았더라도 보낼 수 있음
    - 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시 가능
    - 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이여야 함
    - 클라이언트는 서버가 푸시한 리소스를 **동일 출처 정책(Same-origin policy)** 에 따라 검사해야함.
        - 예: `example.org` 로의 커넥션은 `www.example.org` 로부터의 푸시 응답 비허용
    - 서버 푸시를 끄고 싶다면 `SETTINGS_ENABLE_PUSH` 를 0으로 설정

## 10.4 알려진 보안 이슈

### 10.4.1 중개자 캡슐화 공격

- HTTP/2.0 메시지를 중간 프락시(중개자)가 HTTP/1.1 로 변환시에 메시지가 변질될 가능성 있ㅇ슴
- HTTP/2.0은 HTTP/1.1과 달리 헤더 필드의 이름/값을 바이너리로 인코딩
    - 이는 HTTP/2.0이 헤더필드로 어떤 문자열(줄바꿈 포함)이든 사용하게 해줌
    - 이를 통해 HTTP/2.0 요청이 불법적이거나 위조된 HTTP/1.1 메시지로 번역 될 수 있음
    - 반대의 케이스(HTTP/1.1 →HTTP/2.0)는 발생하지않음

### 10.4.2 긴 커넥션 유지로 인한 개인정보 누출 우려

- 회전 지연을 줄이기 위해 커넥션을 오래 유지하는 것이 개인 정보 유출에 악용될 수 있음
    - 예: 브라우저 사용시에 이전 브라우저 사용자가 무엇을 했는지 알아 낼 수 있음.
    - HTTP가 현재 갖고있는 문제이지만, 짧게 유지되는 커넥션에서는 위험이 적음