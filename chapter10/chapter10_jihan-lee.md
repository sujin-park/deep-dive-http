# HTTP 완벽가이드 정리
## 10장 HTTP/2.0
### 10.1 HTTP/2.0의 등장 배경

HTTP/1.1의 메시지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화되었다.
그러나, 응답을 받아야만 다음 요청을 보낼 수 있기 때문에 심각한 ```회전 지연(latency)```을 피할 수 없었다.

이러한 지연 문제를 해결하기 위해 많은 곳에서 노력을 해왔으며
2012년 10월 3일, HTTP 작업 그룹은 구글의 SPDY를 기반으로 HTTP/2.0 프로토콜을
설계하기로 결정하였다.

### 10.2 개요

HTTP/2.0은 ```서버와 클라이언트 사이의 TCP 커넥션 위에서 동작```한다. 이때 TCP 커넥션을 초기화하는 것은 클라이언트다.
HTTP/2.0 요청과 응답은 길이가 정의된(최대 16383 바이트) ```한 개 이상의 프레임```에 담긴다.
이때 ``HTTP 헤더는 압축``되어 담긴다.

프레임들에 담긴 요청과 응답은 스트림을 통해 보내진다.
한 개의 스트림이 한 쌍의 요청과 응답을 처리한다. 하나의 커넥션 위에 여러 개의 스트림이 동시에
만들어질 수 있으므로, ```여러 개의 요청과 응답을 동시에 처리하는 것 ```역시 가능하다.

HTTP/2.0은 이들 스트림에 대한 **흐름 제어와 우선순위 부여 기능**도 제공한다.

HTTP/2.0은 새로운 상호작용 모델인 ```서버 푸시```를 도입했다.
이를 통해 서버는 클라이언트에게 필요하다고 생각하는 리소스라면 그에 대한 요청을 명시적으로 받지 않더라도
```능동적으로 클라이언트에게 보내줄 수 있다.```

### 10.3 HTTP/1.1과의 차이점

![프레임의 구조](https://user-images.githubusercontent.com/39042837/103961714-6bc6c680-5198-11eb-8edb-fa4763aac9c1.jpeg)

모든 프레임은 8바이트 크기의 헤더로 시작하며, 뒤이어 최대 16383바이트 크기의 페이로드가 온다.

프레임 헤더의 각 필드는 다음과 같다.

* ```R```
  * 예약된 2비트 필드
  * 값의 의미가 정의되어 있지 않으며, 반드시 ```0``` 이어야 한다.
  * 받는 쪽에서는 이 값을 무시해야 한다.
  
* ```길이```
  * 페이로드의 길이를 나타내는 14비트 무부호 정수(unsigned integer). 이 길이에 프레임 헤더는 포함되지 않는다.

* ```종류```
  * 프레임의 종류

* ```플래그```
  * 8비트 플래그
  * 플래그 값의 의미는 프레임의 종류에 따라 다르다.

* ```R```
  * 예약된 1비트 필드
  * 값의 의미가 정의되어 있지 않으며, 반드시 ```0``` 이어야 한다.
  * 받는 쪽에서는 이 값을 무시해야 한다.

* ```스트림 식별자```
  * 31비트 스트림 식별자
  * 특별히 0은 커넥션 전체와 연관된 프레임을 의미한다.

HTTP/2.0은

* DATA
* HEADERS
* PRIORITY
* RST_STREAM
* SETTINGS
* PUSH_PROMISE
* PING
* GOAWAY
* WINDOW_UPDATE
* CONTINUATION

이라는 총 ```10가지의 프레임```을 정의하고 있으며,
페이로드의 형식이나 내용은 프레임의 종류에 따라 다르다.

#### 10.3.2 스트림과 멀티플렉싱

> 스트림 : HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 **프레임들의 독립된 양방향 시퀀스**

클라이언트는 새 스트림을 만들어 그를 통해 HTTP 요청을 보낸다.
서버는 그 요청과 같은 스트림으로 응답을 보낸다. 그러고 나면 스트림이 닫힌다.

HTTP/1.1에서는 회전 지연을 줄이기 위해 여러 개의 TCP 커넥션을 만들어 동시에 여러 개의 요청을 보내는 방법을 사용한다.
그러나, HTTP/2.0에서는 ```하나의 커넥션에 여러 개의 스트림```이 동시에 열릴 수 있다.

* 스트림은 우선순위도 가질 수 있다.
  * 우선순위를 따르는 것은 의무사항이 아니기 때문에, 요청이 우선순위대로 처리된다는 보장은 없다.
* 모든 스트림은 31비트의 무부호 정수로 된 고유한 식별자를 갖는다.
  * 스트림이 클라이언트에 의해 초기화되었다면 이 식별자는 반드시 홀수여야 하고, 서버라면 짝수여야 한다.
* 새로 만들어진 스트림의 식별자는 이전에 만들어졌거나 예약된 스트림들의 식별자보다 커야 한다.
  * 이 규칙을 어기는 식별자라면 에러코드 PROTOCOL_ERROR인 커넥션 에러로 응답해야 한다.
* HTTP/2.0 커넥션에서 한번 사용한 스트림 식별자는 다시 사용할 수 없다.
  * 커넥션을 오래 사용하면 스트림 할당 식별자가 고갈되기도 하는데, 그런 경우 커넥션을 다시 맺으면 된다.
* 동시에 여러 개의 스트림을 사용하면 스트림이 블록될 우려가 있다는 주장이 있다.
  * HTTP/2.0은 WINDOW_UPDATE 프레임을 이용한 흐름 제어를 통해 스트림들이 서로 간섭해서 망가지는 것을 막아준다.

#### 10.3.3 헤더 압축

요즈음에는 웹페이지 하나를 보기 위해 수십에서 수백개의 요청을 보내기 때문에,
헤더의 크기가 회전 지연과 대역폭 양쪽 모두에 실질적인 영향을 끼치게 되었다.

이를 개선하기 위해 HTTP/2.0에서는 ```HTTP 메시지의 헤더를 압축하여 전송```한다.

헤더는 HPACK 명세에 정의된 헤더 압축 방법으로 압축된 뒤 '헤더 블록 조각'들로 쪼개져서 전송된다.
받는 쪽에서는 이 조각들을 이은 뒤 압축을 풀어 원래의 헤더 집합으로 복원한다.

#### 10.3.4 서버 푸시

1. 리소스를 푸시하려는 서버는 먼저 클라이언트에게 자원을 푸시할 것임을
```PUSH_PROMISE```프레임을 보내어 미리 알려주어야 한다.
2. 클라이언트가 PUSH_PROMISE 프레임을 받게 되면 해당 프레임의 스트림은 ```'예약됨'``` 상태가 된다.
3. 이때, 클라이언트는 ```RST_STREAM``` 프레임을 보내어 푸시를 거절할 수도 있다.
4. 스트림이 닫히기 전까지 클라이언트는 서버가 푸시하려고 하는 리소스를 요청해서는 안 된다.

위와 같이 PUSH_PROMISE 프레임을 먼저 보내는 이유는 서버가 푸시하려고 하는 자원을
클라이언트가 별도로 또 요청하게 되는 상황을 피하기 위함이다.

다음은 서버 푸시를 사용할 때 주의할 점이다.

* 중간의 프락시가 서버로부터 받은 추가 리소스를 클라이언트에게 전달하지 않을 수 있다.
* 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시할 수 있다.
* 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야 한다.
* 클라이언트는 반드시 서버가 푸시한 리소스를 동일 출처 정책(Same-origin policy)에 따라 검사해야한다.
* 서버 푸시를 끄고 싶다면 SETTING_ENABLE_PUSH를 0으로 설정한다.

### 10.4 알려진 보안 이슈

#### 10.4.1 중개자 캡슐화 공격(Intermediary Encapsulation Attacks)

HTTP/2.0 메시지를 중간의 프락시가 HTTP/1.1 메시지로 변환할 때 메시지의 의미가 변질될 가능성이 있다.

HTTP/2.0은 헤더 필드의 이름과 값을 바이너리로 인코딩한다.
이는 정상적인 HTTP/2.0 요청이나 응답이 불법적이거나 위조된 HTTP/1.1 메시지로 번역되는 것을 유발할 수 있다.

다행히도 HTTP/1.1 메시지 -> HTTP/2.0 메시지로 번역 과정에서는 이런 문제가 발생하지 않는다.

#### 10.4.2 긴 커넥션 유지로 인한 개인정보 누출 우려

사용자가 요청을 보낼 때의 회전 지연을 줄이기 위해 클라이언트와 서버 사이의 커넥션을
오래 유지하도록 한다. 이것은 개인 정보 유출에 악용될 가능성이 있다.

