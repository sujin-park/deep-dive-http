# 10장 HTTP/2.0

## 10.1 HTTP/2.0의 등장 배경

회전 지연을 줄이기 위해 구글의 ```SPDY: 더 빠른 웹을 위한 실험적인 프로토콜```을 적용했었고, 20ms인 상황에서는 12.34%의 성능 개선 효과가 있었으며, 80ms인 상황에서는 23.85% 성능 개선 효과가 있었습니다.
HTTP/2.0 프로토콜을 SPDY를 기반으로 설계하기로 결정하였습니다.

## 10.2 개요

- 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작, TCP 커넥션을 초기화하는 것은 클라이언트
- 요청과 응답은 길이가 정의된 한 개 이상의 프레임에 담기고 HTTP 헤더는 압축되어 담김
- 스트림에 대한 흐름 제어와 우선순위 부여 기능도 제공
- 기존의 요청-응답과는 다른 새로운 상호작용 모델인 서버 푸시 도입
- HTTP/1.1 의 응답 메시지 의미 유지
- Content-Length 헤더는 본문의 길이를 의미, 404 Not Found 응답은 리소스를 찾을 수 없음을 의미

## 10.3 HTTP/1.1 과의 차이점

### 10.3.1 프레임

HTTP/2.0 에서 모든 메시지는 프레임에 담겨 전송됩니다.

모든 프레임은 8바이트 크기의 헤더로 시작하며, 뒤이어 최대 16383바이트 크기의 페이로드가 옵니다.

### 10.3.2 스트림과 멀티플렉싱

```스트림```은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스입니다.

HTTP/2.0에서는 하나의 커넥션에 여러 개의 스트림이 동시에 열릴 수 있습니다.

- 스트림은 우선 순위를 가질 수 있음
- 우선순위에 따르는 것은 의무사항이 아니므로 요청이 우선순위대로 처리된다는 보장은 없음
- 스트림은 31비트의 무부호 정수로 된 고유한 식별자를 가짐
- 서버와 클라이언트는 스트림을 상대방과 협상 없이 일방적으로 생성이 가능, 협상을 위해 TCP 패킷을 주고받느라 시간 낭비 X
- HTTP/2.0 커넥션에서 한번 사용한 스트림 식별자는 다시 사용할 수 없음

### 10.3.3 헤더 압축

헤더의 크기가 회전 지연과 대역폭 양쪽 모두에 영향을 끼치게 되었습니다.

HTTP/2.0에서는 HTTP메시지의 헤더를 HPACK 명세에 정의된 헤더 압축 방법으로 압축된 뒤 헤더 블록으로 쪼개져서 전송합니다.

> HPACK

- 헤더를 압축하고 해제 시, 압축 콘텍스트를 사용
- 수신한 헤더의 압축을 풀면 압축 콘텍스트는 영향을 받아 바뀜
- 헤더를 받은 수신 측은 압축 해제를 수행하고, 그럴 수 없다면 반드시 COMPRESSION_ERROR와 함께 커넥션 끊기

### 10.3.4 서버 푸시

서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있도록 해주는 기능이 ```서버 푸시```입니다.
서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유용합니다.

리소스를 푸시하려는 서버는 먼저 클라이언트에게 자원을 푸시할 것임을 PUSH_PROMISE 프레임을 보내서 미리 알려주어야합니다.

**서버 푸시 주의사항**
- 서버 푸시를 사용하기로 했더라도, 추가 리소스를 서버로부터 받지 않았음에도 클라이언트에게 추가 리소스를 전달할 수 있음
- 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시 가능
- 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야 함
- 클라이언트는 반드시 서버가 푸시한 리소스를 동일 출처 정책에 따라 검사해야 함
- 서버 푸시를 끄고 싶다면 SETTINGS_ENABLE_PUSH을 0으로 설정

## 10.4 알려진 보안 이슈

### 10.4.1 중개자 캡슐화 공격

HTTP/2.0은 헤더 필드로 어떤 문자열이든 사용할 수 있게 변경되었습니다. 이는 정상적인 HTTP/2.0 요청이나 응답이 위조된 HTTP/1.1 메시지로 번역되는 것을 유발 할 수 있습니다.

### 10.4.2 긴 커넥션 유지로 인한 개인정보 누출 우려

HTTP/2.0은 사용자가 요청을 보낼 때의 회전 지연을 줄이기 위해 클라이언트와 서버 사이의 커넥션을 오래 유지하는 것을 염두에 두고 있습니다.


