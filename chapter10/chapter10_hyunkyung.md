# 10장 HTTP/2.0

## 10.1 HTTP/2.0의 등장 배경
- HTTP/1.1의 메시지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화되었음 -> 성능을 희생
- 커넥션 하나를 통해 요청 하나를 보내고 그에 대해 응답 하나만을 받는 HTTP의 메시지 교환 방식은 응답을 받아야만 그다음 요청을 보낼 수 있기 때문에 심각한 회전지연이 발생
- 많은 이들이 이것을 해결하기 위해 노력
- 2009년 구글이 웹을 더 빠르게 하겠다는 목표 아래 SPDY 프로토콜을 내놓았음
- SPDY는 헤더를 압축하여 대역폭을 절약했고, 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연을 줄이는 것이 가능했으며, 클라이언트가 요청을 보내지 않아도 서버가 능동적으로 리소스를 푸시하는 기능도 갖추고 있음
- 위 프로토콜은 상당한 성능 개선 효과가 있었고 HTTP 작업 그룹은 SPDY를 기반으로 HTTP/2.0 프로토콜을 설계하기로 결정

## 10.2 개요
- HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작
- 이때 TCP 커넥션을 초기화하는 것은 클라이언트
- HTTP/2.0 요청과 응답은 길이가 정의된 한 개 이상의 프레임에 담김 -> 이때 HTTP 헤더는 압축되어 담김
- 프레임들에 담긴 요청과 응답은 스트림을 통해 보내지고 한 개의 스트림이 한쌍의 요청과 응답을 처리
- 하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어질 수 있으므로, 여러 개의 요청과 응답을 동시에 처리하는 것 역시 가능
- HTTP/2.0은 이들 스트림에 대한 흐름 제어와 우선순위 부여 기능도 제공
- HTTP/2.0은 기존의 요청-응답과는 약간 다른 새로운 상호작용 모델인 서버 푸시를 도입
- 이를 통해 서버는 클라이언트에게 필요하다고 생각하는 리소스라면 그에 대한 요청을 명시적으로 받지 않더라도 능동적으로 클라이언트에게 보내줄 수 있음
- 기존 웹 애플리케이션들과 호환성을 최대한 유지하기 위해 HTTP/2.0은 요청과 응답 메시지의 의미를 HTTP/1.1과 같도록 유지하고 있음

## 10.3 HTTP/1.1과의 차이점
### 10.3.1 프레임
- HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송됨
- 모든 프레임은 8바이트 크기의 헤더로 시작하며, 뒤이어 최대 16383 바이트 크기의 페이로드가 옴

### 10.3.2 스트림과 멀티 플렉싱
- 스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스
- 한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어짐
- 클라이언트는 새 스트림을 만들어 그를 통해 HTTP 요청을 보냄.
- 요청을 받은 서버는 그 요청과 같은 스트림으로 응답을 보냄
- 그러고 나면 스트림이 닫힘
- HTTP/2.0에서는 하나의 커넥션에 여러개의 스트림이 동시에 열릴 수 있음
- 따라서 하나의 HTTP/2.0 커넥션을 통해 여러 개의 요청이 동시에 보내질 수 있어서 회전지연의 문제 해결
- 뿐만 아니라 스트림은 우선순위도 가질 수 있음
- 보다 중요한 리소스에 우선순위를 부여할 수는 있으나 의무가 아니라서 보장은 없다
- 모든 스트림은 31비트의 무부호 정수로 된 고유한 식별자를 가짐
- 스트림이 클라이언트에 의해 초기화되었다면 이 식별자는 반드시 홀수여야 하며 서버라면 짝수여야 함
- 또한 새로 만들어지는 스트림의 식별자는 이전에 만들어졌거나 예약된 스트림의 식별자보다 커야함
- 이 규칙을 어겼다면 PROTOCOL_ERROR로 응답
- 서버와 클라이언트는 스트림을 상대방과 협상 없이 일방적으로 만들고 이는 스트림을 만들 때 협상을 위해 TCP 패킷을 주고받느라 시간을 낭비하지 않아도 됨을 의미
- HTTP/2.0 커넥션에서 한번 사용한 스트림 식별자는 다시 사용할 수 없음
- 커넥션을 오래 사용하다보면 스트림에 할당할 수 있는 식별자가 고갈되기도 하는데 그런 경우에는 다시 맺으면 됨
- HTTP/2.0은 WINDOW_UPDATE 프레임을 이용한 흐름제어를 통해 스트림들이 서로 간섭해서 망가지는 것을 막아줌

### 10.3.3 헤더 압축
- HTTP/1.1에서 헤더는 아무런 압축 없이 그대로 전송됨
- 요즘은 헤더가 성능문제를 유발
- HTTP/2.0에서는 헤더를 압축하여 전송
- 헤더는 HPACK 명세에 정의된 헤더 압축 방법으로 압축된 뒤 '헤더 블록 조직'들로 쪼개져서 전송됨
- 받는 쪽에서는 이 조각들을 이은 뒤 압축을 풀어 원래의 헤더 집합으로 복원
- HPACK은 헤더를 압축하고 해제할 때 '압축 콘텍스트'를 사용
- 따라서 오동작하지 않으려면 항상 올바른 압축 콘텍스트를 유지해야 함
- 이 압축 콘텍스트는 수신한 헤더의 압축을 풀면 이에 영향을 받아 바뀜
- 송신 측은 수신 측이 헤더의 압축을 풀었으며 그에 따라 압축 콘텍스트가 변경되었다고 가정할 것
- 따라서 헤더를 받은 수신 측은 어떤 경우에도 반드시 압축 해제를 수행해야 하고 그럴 수 없다면 COMPRESSION_ERROR와 함께 커넥션을 끊어야 함

### 10.3.4 서버 푸시
- HTTP/2.0은 서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있도록 해줌
- 이 기능은 서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유용(HTML 파일을 받으면 css나 javascript를 서버에서 보내주는 것)
- 리소스를 푸시하려는 서버는 먼저 클라이언트에게 자원을 푸시할 것임을 PUSH_PROMISE 프레임을 보내어 미리 알려주어야 함
- 클라이언트가 위 프레임을 받으면 해당 프레임의 스트림은 클라이언트에게 예약됨 상태가 됨
- 이 상태에서 클라이언트는 RST_STREAM 프레임을 보내어 푸시를 거절할 수 있음
- 위 프레임을 보내서 예약하는 것은 클라이언트가 별도로 또 요청하는 상황을 막기 위함
- 서버 푸시를 할 때 주의할 상황
    - 서버 푸시를 사용하기로 했더라도, 중간의 프락시가 서버로부터 받은 추가 리소스를 클라이언트에게 전달하지 않을 수 있으며, 반대로 추가 리소스를 서버로부터 받지 않았음에도 클라이언트에게 추가 리소스를 전달할 수 있음
    - 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시할 수 있음
    - 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야 함
    - 클라이언트는 반드시 서버가 푸시한 리소스를 동일 출처 정책에 따라 검사해야 함
    - 서버 푸시를 끄고 싶다면 SETTINGS_ENABLE_PUSH을 0으로 설정

## 10.4 알려진 보안 이슈
### 10.4.1 중개자 캡슐화 공격
- HTTP/2.0 메시지를 중간의 프락시가 HTTP/1.1 메시지로 변환할 때 메시지의 의미가 변경될 가능성이 있음
- HTTP/1.1과 달리 HTTP/2.0은 헤더필드의 이름과 값을 바이너리로 인코딩
- 이는 HTTP/2.0이 헤더 필드로 어떤 문자열이든 사용할 수 있게 해줌
- 이는 정상적인 HTTP/2.0 요청이나 응답이, 불법적이거나 위조된 HTTP/1.1 메시지로 번역되는 것을 유발할 수 있음

### 10.4.2 긴 커넥션 유지로 인한 개인정보 누출 우려
- HTTP/2.0은 사용자가 요청을 보낼 때의 회전지연을 줄이기 위해 클라이언트와 서버 사이의 커넥션을 오래 유지하는 것을 염두에 두고 있음
- 이것은 개인 정보 유출에 악용될 가능성 있음(어떤 브라우저 사용했던 사람 정보를 이번에 사용하는 사람이 알아낼 가능성)
 