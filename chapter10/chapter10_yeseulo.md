# 10. HTTP/2.0

* 이 장은 [HTTP/2.0의 8번째 초안](https://tools.ietf.org/html/draft-ietf-httpbis-http2-08)에 기반하여 작성되었다. 다음 내용에서 'HTTP/2.0 초안'은 이 8번째 초안을 의미한다.

## 10.1 HTTP/2.0의 등장 배경

* HTTP/1.1의 메시지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화 되었다.
* 커넥션 하나를 통해 요청 하나를 보내고 그에 대해 응답 하나만을 받는 HTTP 메시지 교환 방식은 단순하지만, 응답을 받아야만 그 다음 요청을 보낼 수 있기 떄문에 심각한 회전 지연(latency)를 피할 수 없었다.
  * 병렬 커넥션이나 파이프라인 커넥션을 도입하였으나 성능 개선에 대한 근본 해결은 하지 못했다. (4장 참고)
* HTTP/1.1 명세가 발표된 지 십수년 동안 이 성능 문제 해결을 위해 많은 노력이 있었다.
  * HTTP 작업 그룹은 HTTP/1.1이 발표되기도 전인 1997년 7월 HTTP-NG 프로젝트를 시작했고, HTTP/1.1의 저자 중 하나인 로이 필딩은 WAKA라는 프로토콜을 제안했다.
  * 마이크로소프트는 Microsoft S+M(Speed+Mobility)라는 프로토콜을 개발하기 시작했다.
  * 2009년 구글은 웹을 더 빠르게 하겠다는 목표 아래 [SPDY(스피디)](https://www.chromium.org/spdy/spdy-whitepaper) 프로토콜을 내놓았다. 기존 HTTP에 속도를 개선하기 위한 여러 기능을 추가한 것으로, SPDY는 헤더를 압축하여 대역폭을 절약하고 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연을 줄이는 것이 가능했으며, 클라이언트가 요청을 보내지 않아도 서버가 능동적으로 리소스를 푸시하는 기능도 갖추었다.
* 2012년 10월 3일, HTTP 작업 그룹은 SPDY를 기반으로 HTTP/2.0 프로토콜을 설계하기로 결정한 것을 밝혔고 SPDY 초안을 그대로 가져와 HTTP/2.0 초안을 만들기 시작했다.
* HTTP/2.0 8번째 초안은 SPDY 특징을 거의 그대로 유지하고 있으며, 크게 변경된 것은 헤더를 압축할 때 더 이상 deflate 알고리즘을 사용하지 않는다는 것이다.

## 10.2 개요

* HTTP/2.0은 서버와 클라이언트 사이 TCP 커넥션 위에서 동작한다. 이때 TCP 커넥션을 초기화하는 것은 클라이언트다.
* HTTP/2.0 요청과 응답은 길이가 정의된(최대 16383바이트) 한 개 이상의 프레임에 담기고, HTTP 헤더는 압축되어 담긴다.
* 프레임들에 담긴 요청과 응답은 스트림을 통해 보내지는데, 한 개의 스트림이 한 쌍의 요청과 응답을 처리한다.
* 하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어질 수 있으므로 여러 개 요청과 응답을 동시에 처리하는 것 역시 가능하다. HTTP/2.0은 이 스트림에 대한 흐름 제어와 우선순위 부여 기능도 제공한다.
* HTTP/2.0은 기존 요청-응답과는 약간 다른 새로운 상호작용 모델인 서버 푸시를 도입했다. 서버는 클라이언트에게 필요하다고 생각하는 리소스라면 요청을 명시적으로 받지 않아도 능동적으로 클라이언트에게 보내줄 수 있다.
* 기존 웹 애플리케이션과의 호환성 유지를 위해 HTTP/2.0은 요청과 응답 메시지의 의미를 HTTP/1.1과 같게 유지하고 있다. HTTP/1.1과 마찬가지로 HTTP/2.0에서도 Content-Length 헤더 이름은 `:content-length`이며, 상태줄을 통해 표현하던 404 Not Found는 `404` 값을 갖는 `:status` 헤더로 표현하게 되었다.

## 10.3 HTTP/1.1과의 차이점

### 10.3.1 프레임

* HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송된다. 모든 프레임은 8바이트 크기의 헤더로 시작하며, 뒤이어 최대 16383바이트 크기의 페이로드가 온다.
* 프레임 헤더의 필드
  * `R`: 예약된 2비트 필드. 값의 의미가 정의되어 있지 않고 반드시 `0`이여야 한다. 받는 쪽에서 이 값을 무시해야 한다.
  * `길이`: 페이로드의 길이를 나타내는 14비트 무부호 정수(unsigned integer). 이 길이에 프레임 헤더는 포함되지 않는다.
  * `종류`: 프레임의 종류
  * `플래그`: 8비트 플래그. 플래그 값의 의미는 프레임 종류에 따라 다르다.
  * `R`: 예약된 1비트 필드. 첫 번째 R과 같이 값의 의미가 정의되어 있지 않고 반드시 `0`이여야 한다. 받는 쪽에서 이 값을 무시해야 한다.
  * `스트림 식별자`: 31비트 스트림 식별자. 특별히 0은 커넥션 전체와 연관된 프레임임을 의미한다.
* HTTP/2.0은 `DATA`, `HEADERS`, `PRIORITY`, `RST_STREAM`, `SETTINGS`, `PUSH_PROMISE`, `PING`, `GOAWAY`, `WINDOW_UPDATE`, `CONTINUATION` 총 10가지 프레임을 정의하고 있다. 페이로드의 형식이나 내용은 프레임 종류에 따라 다르다. (HTTP/2.0 명세 초안의 [6. Frame Definitions](https://tools.ietf.org/html/draft-ietf-httpbis-http2-08#section-6) 참고)

### 10.3.2 스트림과 멀티플렉싱

* 스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스다.
* 한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어진다. 클라이언트는 새 스트림을 만들어 HTTP 요청을 보내고, 요청 받은 서버는 요청과 같은 스트림으로 응답을 보내며, 그 후 스트림이 닫힌다.
* HTTP/1.1에서는 한 TCP 커넥션을 통해 요청을 보냈을 떄, 그 응답이 도착하고 나서야 같은 TCP 커넥션으로 다시 요청을 보낼 수 있었다.
  * 때문에 웹 브라우저는 회전 지연을 줄이기 위해 여러 개의 TCP 커넥션을 만들어 동시에 여러 요청을 보내는 방법을 사용했다.
  * 그러나 TCP 커넥션을 무한정 만들 수 없고, 한 페이지에 보내야 할 요청이 수백에 달하는 오늘날에 회전 지연이 늘어나는 것을 피하기 어렵다.
  * 파이프라인을 통해 이를 피할 수 있으나 널리 구현되지 않았다.
  * HTTP/2.0에서는 하나의 커넥션에 여러 개의 스트림이 동시에 열릴 수 있고 여러 요청을 동시에 보낼 수 있어 이 문제를 해결할 수 있다.
* 스트림은 우선순위를 가질 수 있다. 브라우저에서 어떤 웹페이지를 볼 때 네트워크 대역폭이 충분치 않아 프레임 전송이 느리다면, 웹브라우저는 중요한 리소스(이미지보다 HTML 페이지와 같은)를 요청하는 스트림에게 더 높은 우선순위를 부여할 수 있다.
  * 그러나 이 우선순위를 따르는 것은 의무가 아니어서 요청이 우선순위대로 처리된다는 보장은 없다.
* 모든 스트림은 31비트 무부호 정수의 고유 식별자를 갖는다. 스트림이 클라이언트에 의해 초기화되었다면 이 식별자는 반드시 홀수여야 하며, 서버라면 짝수여야 한다.
* 새로 만들어지는 식별자는 이전에 만들어졌거나 예약된 스트림들의 식별자보다 커야 한다. 이 규칙을 어기는 식별자를 받았다면 에러 코드가 `PROTOCOL_ERROR`인 커넥션 에러로 응답해야 한다.
* 서버와 클라이언트는 상대방과 협상 없이 일방적으로 스트림을 만들어, 협상을 위해 TCP 패킷을 주고받느라 시간 낭비를 하지 않아도 된다.
* HTTP/2.0 커넥션에서 한번 사용한 스트림 식별자는 다시 사용할 수 없다. 커넥션을 오래 사용하다보면 스트림에 할당할 수 있는 식별자가 고갈될 수 있는데, 그러면 커넥션을 다시 맺으면 된다.
* 동시에 여러 개의 스트림을 사용하면 스트림이 블록될 우려가 있다는 주장이 있는데, HTTP/2.0은 `WINDOW_UPDATE` 프레임을 이용한 프름 제어(flow control)를 통해 스트림들이 서로 간섭해서 망가지는 것을 막는다.

### 10.3.3 헤더 압축

* HTTP/1.1에서 헤더는 압축없이 그대로 전송되었다. 과거에는 웹 페이지 하나 방문할 때 요청이 많지 않아 헤더 크기가 문제가 되지 않았으나 요즘은 많게는 수백 번의 요청을 보내기도 해서 헤더의 크기가 회전 지연과 대역폭 양쪽 모두에 영향을 끼치게 되었다.
* 이를 개선하기 위해 HTTP/2.0에서는 HTTP 메시지 헤더를 압축 전송한다.
* 헤더는 HPACK 명세에 정의된 헤더 압축 방법으로 압축된 뒤 '헤더 블록 조각'들로 쪼개져 전송된다. 받는 쪽에서 이 조각들을 잇고 압축을 풀어 원래 헤더 집합으로 복원한다.
* HPACK은 헤더를 압축/해제할 때 '압축 콘텍스트(compression context)'를 사용하며, 항상 올바른 압축 콘텍스트를 유지해야 한다.
* 압축 콘텍스트는 수신한 헤더의 압축을 풀면 이 영향을 받아 바뀐다.
  * 송신 측은 수신 측이 헤더의 압축을 풀었고 그에 따라 압축 콘텍스트가 변경되었다고 가정할 것이다.
  * 따라서 헤더를 받은 수신 측은 어떤 경우에도(헤더를 쓰지 않고 버리는 경우에도) 반드시 압축 해제를 수행해야 한다.
  * 그럴 수 없다면 반드시 `COMPRESSION_ERROR`와 함께 커넥션을 끊어야 한다.

### 10.3.4 서버 푸시

* HTTP/2.0는 서버가 하나의 요청에 대한 응답으로 여러 개의 리소스를 보낼 수 있게 한다. 이 기능은 서버가 클라이언트에게 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유용하다.
  * HTML 문서 요청을 받은 서버는 그 HTML 문서에 링크된 이미지, CSS 파일, 자바스크립트 파일 등 리소스를 클라이언트에게 푸시할 수 있다. 클라이언트가 HTML 문서를 파싱해서 필요한 리소스를 다시 요청하여 발생하는 트래픽과 회전 지연을 줄여준다.
* 리소스를 푸시하려는 서버는 먼저 클라이언트에게 리소스를 푸시할 것임을 `PUSH_PROMISE` 프레임을 보내어 미리 알려줘야 한다.
  * 클라이언트가 `PUSH_PROMISE` 프레임을 받으면 해당 프레임의 스트림은 클라이언트 입장에서 `예약됨(원격)` 상태가 된다.
  * 이 상태에서 클라이언트는 `RST_STREAM` 프레임을 보내 푸시를 거절할 수 있다.
  * `RST_STREAM`을 보내면 그 스트림은 즉시 닫힌다. 스트림이 닫히기 전까지 클라이언트는 서버가 푸시하려는 리소스를 요청해서는 안 된다.
* 이처럼 사전에 `PUSH_PROMISE` 프레임을 먼저 보내는 것은 서버가 푸시하려는 자원을 클라이언트가 별도로 또 요청하는 상황을 피하기 위한 것이다.
* 서버 푸시를 사용할 때 주의할 점
  * 서버 푸시를 사용하기로 했더라도 중간의 프락시가 서버로부터 받은 추가 리소스를 클라이언트에게 전달하지 않을 수 있으며, 반대로 아무런 추가 리소스를 서버로부터 받지 않았음에도 클라이언트에게 추가 리소스를 전달할 수 있다.
  * 서버는 안전하고, 캐시 가능하고, 본문 포함하지 않은 요청에 대해서만 푸시할 수 있다.
  * 클라이언트는 반드시 서버가 푸시한 리소스를 동일 출처 정책(Same-origin policy)에 따라 검사해야 한다.
    * `example.org`로의 HTTP/2.0 커넥션은 `www.example.org`로부터의 푸시 응답을 허용하지 않는다.
  * 서버 푸시를 끄고 싶다면 `SETTING_ENABLE_PUSH`를 `0`으로 설정한다.

## 10.4 알려진 보안 이슈

### 10.4.1 중개자 캡슐화 공격(Intermediary Encapsulation Attacks)

* HTTP/2.0 메시지를 중간의 프락시가 HTTP/1.1 메시지로 변환할 때 메시지의 의미가 변경될 가능성이 있다.
* HTTP/1.1과 달리 HTTP/2.0은 헤더 필드의 이름과 값을 바이너리로 인코딩한다. 이는 HTTP/2.0이 헤더 필드로 어떤 문자열(줄바꿈 문자열도 허용됨)이든 사용할 수 있게 한다.
* 이는 정상적인 HTTP/2.0 요청이나 응답이 불법적이거나 위조된 HTTP/1.1 메시지로 번역되는 것을 유발할 수 있다.
* 다행히 HTTP/1.1 메시지를 HTTP/2.0 메시지로 번역하는 과정에서는 이런 문제가 발생하지 않는다.

### 10.4.2 긴 커넥션 유지로 인한 개인정보 누출 우려

* HTTP/2.0은 사용자가 요청 보낼 때의 회전 지연을 줄이기 위해 클라이언트와 서버 사이 커넥션을 오래 유지하는 것을 염두에 둔다. 이것은 개인 정보 유출에 악용될 가능성이 있다.
  * 예를 들어 어떤 사용자가 브라우저 사용할 때 그 이전에 해당 브라우저를 사용한 사용자가 무엇을 했는지 알아낼 가능성도 있다.
* 이는 HTTP가 현재 가지고 있는 문제이기도 하나, 짧게 유지되는 커넥션에서는 위험이 적다.

## 10.5 추가 정보

* [HTTP/2.0 소개](https://developers.google.com/web/fundamentals/performance/http2?hl=ko)
* [Primer on Web Performance](https://hpbn.co/primer-on-web-performance/)