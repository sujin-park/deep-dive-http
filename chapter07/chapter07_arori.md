## 7.1 불필요한 데이터 전송

- 복수의 클라이언트가 자주 쓰이는 페이지에 접근시, 같은 바이트들이 네트워크를 통해 계속 반복해서 이동
- 캐시를 이용하여, 캐시된 사본이 뒤이은 요청에 대한 응답으로 사용하여 트래픽을 주고 받는 낭비를 줄임

## 7.2 대역폭 병목

- 캐시는 네트워크 병목 줄여줌. 빠른 LAN에 있는 캐시로부터 사본을 가져온다면, 캐싱은 성능 대폭 개선 가능.
    - 많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭 제공.
    - 클라이언트들이 서버에 접근할 때의 속도는 그 경로에 있는 가장 느린 네트워크의 속도.

## 7.3 갑작스런 요청 쇄도(Flash Crowds)

- 많은 사람이 동시에 웹 문서 접근시 발생하며, 캐시를 통해 갑작스런 쇄도 요청에 대처 가능.
    - 이로 초래된 불필요한 트래픽 급증은 네트워크와 웹 서버에 심각한 장애 야기.

## 7.4 거리로 인한 지연

- 거리로 인한 지연 요소
    - 모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킴
    - 라우터가 많지 않더라도, 빛의 속도 그자체로 유의미한 지연 발생
- 복잡한 페이지는 빛의 속도로 인한 지연이 수 초에 달함. 캐시를 통해 전송 거리를 수천 킬로 미터에서 수십 미터로 줄일 수 있음

## 7.5 적중과 부적중

- 캐시는 유용하지만, 세상 모든 문서의 사본을 저장하지 않음.
- 캐시에 요청 도착시,
    - 캐시 적중(cache hit): 사본이 있음. → 이를 이용해 요청 처리
    - 캐시 부적중(cache miss): 사본이 없음. → 원 서버로 전달

### 7.5.1 재검사(Revalidation)

- HTTP 재검사: 원 컨텐츠가 변경될 수 있으므로, 캐시는 반드시 갖고 있는 사본이 최신인지 점검이 필요.
- 캐시는 대부분 사본을 요청받고, 그 것이 검사가 필요할 정도로 오래된 경우에만 재검사.
    - 언제나 재검사가 가능하지만, 보유 문서양 대비 네트워크 대역폭이 부족하기 때문
- 캐시는 재검사 필요시, 원 서버에게 재검사 요청을 보냄.
- HTTP는 재검사 요청에 사용되는 도구 몇 가지를 제공하는데, 그 중 `If-Modified-Since`  제공
    - 서버에 보내는 `GET` 요청에 위 헤더를 추가시, 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미

***재검사 적중***

- 원 서버에 재검사 요청을 보냈을 때 콘텐츠가 미변경된 경우.
    - 서버가 `304 Not Modified` 응답 전송 → 캐시는 사본 제공
- 순수 캐시 적중보다 느림: 원서버 검사가 필요하기 때문
- 캐시 부적중보다 빠름: 서버로부터 객체 데이터를 받아올 필요 없음

***재검사 부적중***

- 원 서버에 재검사 요청을 보냈을 때 콘텐츠가 변경된 경우.
    - 서버는 콘텐츠와 함께 `200 OK` 응답 전송

***객체 삭제***

- 원 서버에 재검사 요청을 보냈을 때 객체가 삭제된 경우.
    - 서버는 `404 Not Found` 응답 전송 → 캐시는 사본 삭제

### 7.5.2 적중률

- **캐시 적중률**(=캐시 적중비), **문서 적중률**(=문서 적중비): 캐시가 요청을 처리하는 비율
    - 적중률은 0~1, 혹은 퍼센트로 표현
    - 0%: 모든 요청이 캐시 부적중, 100%: 모든 요청이 캐시 적중
- 캐시 관리자는 적중율이 100%에 가깝게 되길 원하지만, 실제로는 40%정도라면 웹 캐시로서 괜찮은 편임.
    - 실제 적중률은, 캐시 크기, 캐시 사용자의 관심사의 비슷한 정도, 캐시된 데이터가 얼마나 자주 변경되거나 개인화 되는지, 캐시가 어떻게 설정되어있는 지에 따라 다름.

### 7.5.3 바이트 적중율

- 문서들이 다 같은 크기가 아니므로, 문서 적중률이 모든 것을 말해주지 않음.
    - 몇 큰 객체들은 덜 접근 되지만, 그 크기때문에 전체 트래픽에는 더 크게 기여함
- 이런 이유로 몇 사람들(특히 트래픽 바이트에 요금을 매기는 사람)은 바이트 단위 적중률 측정값을 선호
- **바이트 적중률**: 캐시를 통해 제공된 모든 바이트의 비율
    - 트래픽이 절감된 정도를 포착. 100%라면 모든 바이트가 캐시에서 와서, 어떤 트래픽도 인터넷으로 나가지 않았음을 의미.
- 문서 적중률과 바이트 단위 적중률 모두 캐시 성능에 대한 유용한 지표
    - 문서 적중률: 얼마나 많은 웹 트랜잭션을 외부로 보내지 않았는지 → 대기시간(지연) 최소화
    - 바이트 단위 적중률: 얼마나 많은 바이트가 인터넷으로 나가지 않았는지 → 대역폭 절약 최적화

### 7.5.4 적중과 부적중의 구별

- HTTP는 클라이언트에게 응답이 캐시 적중/원서버 접근인지 전달 불가능. 모두 `200 OK` 로 전달.
- 클라이언트가 응답이 캐시에서 왔는지는 알아낼 수 있는 방법
    1. `Date` 헤더를 통해 알 수 있음.
        - 응답의 값과 현재 시각을 비교하여 응답 생성일이 더 오래되면 응답이 캐시된 것
    2. `Age` 헤더를 통해 알 수 있음.
    3. 어떤 상용 프락시 캐시는 `Via` 헤더를 통해 캐시에 일어난 일 설명

## 7.6 캐시 토폴로지

- 개인 전용캐시(private cache): 한 명에게만 할당된 캐시로. 그 사용자가 자주 찾는 페이지를 담음
- 공용 캐시(public cache): 수천 명의 사용자에게 공유된 캐시로, 사용자 집단에 자주 쓰이는 페이지를 담음

### 7.6.1 개인 전용 캐시

- 많은 에너지/저장공간 불필요 → 작고 저렴함
- 웹 브라우저는 개인 전용 캐시를 내장.
    - 대부분의 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시.
    - 사용자가 캐시 사이즈/설정 수정 및 캐시 내부 확인 가능.

### 7.6.2 공용 프락시 캐시

- 캐시 프락시 서버(=프락시 캐시)라고 불리는 특별한 종류의 공유된 프락시 서버
- 로컬 캐시에서 문서를 제공하거나 혹은 사용자 입장에서 서버에 접근 → 불필요한 트래픽을 줄일 기회가 많음
    - 자주 찾는 객체를 단 한번만 가져와 모든 요청에 대해 공유된 사본을 제공함으로써 트래픽 줄임
- 프락시 캐시는 프락시를 위한 규칙(6장 참조)을 따름
- 브라우저는 수동 프락시를 지정 혹은 프락시 자동 설정파일을 설정해 프락시 캐시를 사용할 수 있음.
- 인터셉트 프락시를 사용함으로써 브라우저 설정없이 HTTP 요청이 캐시를 통하도록 강제할 수 있음.

### 7.6.3 프락시 캐시 계층들

- 캐시 계층을 만드는 방식이 합리적인 경우가 많음
    - 작은 캐시에서 캐시 부적중 발생시, 더 큰 부모 캐시가 그 걸러진 트래픽을 처리함
- 클라이언트 주위에는 자고 저렴한 캐시 사용. 계층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하기위해 더 크고 강력한 캐시 사용
- 캐시 계층이 깊다면 요청은 캐시의 긴 연쇄를 따라가므로, 길어질 수록 중간 프락시는 현저한 성능 저하 발생.
    - 실제로 네트워크 아키텍트들은 2~3개의 프락시만 거치도록 스스로 제한.

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

- 몇 네트워크 아키텍처는 단순한 캐시 계층 대신 복잡한 캐시망을 만듬
- 캐시망의 프락시 캐시는  캐시 커뮤니케이션 결정을 동적으로 내림
    - URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택
    - URL에 근거하여, 특정 부모 캐시를 동적으로 선택
    - 부모 캐시에 가기전에 캐시된 사본을 로컬에서 찾아보기
    - 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근 허용하되, 그들의 캐시를 통한 인터넷 트랜짓(Internet transit, 트래픽이 다른 네트워크로 건너가는 것)을 비허용
- 이렇게 더 복잡한 캐시 사이에는, 서로 다른 조직들이 상호 이득을 위해 캐시끼리 연결하여 서로를 찾아볼 수 있도록 해줌.
    - 이렇게 선택적인 피어링을 지원하는 캐시를 형제 캐시라고 함
    - HTTP는 형제 캐시를 지원하지 않으므로, ICP(인터넷 캐시 프로토콜) 이나 HTCP(하이퍼텍스트 캐시 프로토콜)같은 프로토콜을 이용하여 확장.

## 7.7 캐시 처리 단계

- 상용 프락시 캐시는 매우 고성능이며, HTTP와 그 외 기술의 고급기능을 지원하도록 만들어져 복잡함.
- 웹 캐시의 기본적인 동작은 단순하며, HTTP GET 메시지 하나를 처리하는 캐시 처리절차는 다음과 같다:
    1. 요청받기
    2. 파싱
    3. 검색
    4. 신선도 검사
    5. 응답 생성
    6. 발송
    7. 로깅

### 7.7.1 단계 1: 요청받기

- 캐시는 네트워크 커넥션의 활동을 감지하고, 들어오는 데이터를 읽어들임
- 고성능이면 여러 개의 커넥션들로부터 동시에 읽어들이고 메세지 전체가 도착전에 트랜잭션 처리를 시작

### 7.7.2 단계 2: 파싱

- 캐시는 요청 메시지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료구조에 담음
    - 캐싱 소프트웨어가 헤더 필드를 처리, 조작하기 쉽게 만들어줌

### 7.7.3 단계 3: 검색

- 캐시는 URL을 알아내고, 그에 해당하는 로컬 사본이 있는지 검사
- 로컬 복사본은 메모리/디스크/근처 다른 컴퓨터에 있을 수 있음.
    - 전문적인 수준의 캐시는 객체를 로컬 캐시에서 가져올 수 있는지 여부 판단을 위해 빠른 알고리즘 사용
- 로컬에서 가져올 수 없다면 캐시는 상황/설정에 따라 원 서버 혹은 부모 프락시에서 가져오거나 실패 반환
- 캐시된 객체는 서버 응답 본문과 원 서버 응답 헤더를 포함하고 있으므로, 캐시 적중 동안 올바른 서버 헤더가 반환될 수 있음
- 캐시된 객체는 얼마나 오랫동안 캐시에 머물렀는지, 얼마나 자주 사용되었는지 등에 대한 메타데이터를 포함

### 7.7.4 단계 4: 신선도 검사

- HTTP는 캐시가 일정 기간동안 서버 문서의 사본을 보유하도록 하여, 캐시는 서버 접촉 없이 해당 문서 제공
- 일정 기간을 넘기면 신선하지 않은 것으로 간주하여, 캐시는 문서 제공전에 서버와 재검사
- 신선도 검사 규칙은 매우 복잡하며, 캐시 제품들의 설정 옵션과 비 HTTP 신선도 표준과의 상호작용때문에 더욱 복잡

### 7.7.5 단계 5: 응답 생성

- 캐시된 응답을 원 서버에서 온것처럼 하기 위해, 캐시는 캐시된 서버 응답 헤더를 토대로 응답 헤더 생성
    - 이 기저 헤더들은 캐시에 의해 수정됨
- 캐시는 클라이언트에 맞게 헤더를 조정할 책임이 있음
    - 예: HTTP/1.1 응답을 긱대하는 상황에서 서버가 HTTP/1.0이라면 적절하게 번역해야함
- 캐시 신선도 정보(`Cache-Control`, `Age`, `Expires` 헤더)를 삽입하고, 프락시 캐시를 거쳐갔음을 알려주기위해 `Via` 헤더를 포함하기도 함
- `Date` 헤더(그 객체가 원 서버에서 최초로 생겨난 일시)를 조정하면 안됨.

### 7.7.6 단계 6: 전송

- 응답 헤더가 준비되면, 응답 돌려주기.
- 모든 프락시 서버와 동일하게 클라이언트와의 커넥션을 유지할 필요가 있음
    - 고성능 캐시는 종종 로컬 저장 장치와 네트워크 I/O 버퍼 사이에서 문서 콘텐츠 복사를 피해, 데이터를 효과적으로 전송하려고 노력함

### 7.7.7 단계 7: 로깅

- 로그 파일과 캐시 사용에 대한 통계를 유지.
- 각 캐시 트랜잭션 완료후, 캐시 적중과 부적중 횟수 등에 대한 통계를 갱신하고 로그 파일에 요청 종류, URL, 발생한 일에 대해 알려주는 항목 추가
- 가장 많이 쓰이는 캐시 로그 포맷은 스퀴드 로그 포맷(Squid log format), 넷스케이프 확장 공용 로그 포맷(Netscape extended common log format). 많은 캐시 제품은 커스텀 로그 파일 허용

## 7.8 사본을 신선하게 유지하기

- 캐시의 사본 모두가 서버 문서와 일치하지 않으며, 캐시된 데이터가 서버의 데이터와 일치하도록 관리해야 함
- 캐시된 사본이 서버와 일치하게 유지할 수있는 문서 만료와 서버 재검사라고하는 메커니즘을 갖고 있음

### 7.8.1 문서 만료

- 서버는 `Cache-Control` 과 `Expires` 라는 유효기간을 명시하는 특별한 헤더를 사용.
- 캐시된 문서가 만료되면, 캐시는 반드시 서버에 변경된 것이 있는지 확인하고, 그렇다면 새 유효기간과 함께 새 사본을 얻어와야 함.

### 7.8.2 유효기간과 나이

- `Expirers` 헤더: HTTP/1.0+,
    - 절대 유효기간을 명시.

    ```
    Expires: Fri, 05 Jul 2002, 05:00:00 GMT
    ```

- `Cache-Control: max-age` 응답헤더:
    - HTTP/1.1, 최대 나이 정의. 최대아니는 처음 문서가 생성된 이후부터 신선하다고 간주되지 않을 때까지의 최댓값(초 단위)

    ```
    Cache-Control: max-age=494200
    ```

### 7.8.3 서버 재검사

- 서버 재검사: 캐시가 원 서버에 문서가 변경되었는지 여부를 물어볼 필요가 있음을 의미
- 재검사 결과
    - 컨텐츠가 변경되었다면? → 새 사본을 가져와 오래된 데이터 대신 저장
    - 컨텐츠가 변경되지 않았다면? → 새 만료일을 포함한 새 헤더들만 가져와 캐시 안의 헤더 갱신
- HTTP 프로토콜은 캐시가 다음중 하나를 반환할 것을 요구:
    - 신선한 캐시된 사본
    - 원 서버와 재검사 되어서, 충분히 신선하다고 확실할 수 있는 캐시된 사본
    - 에러 메시지(재검사해야하는 원 서버각 다운된 경우)
    - 경고 메시지가 부착된 캐시의 사본(부정확한 경우)

### 7.8.4 조건부 메서드와의 재검사

- 조건부 메서드는 재검사를 효율적으로 만들어줌
    - 캐시가 서버에게 조건부 GET이라는 요청을 보내, 서버 내 문서가 캐시와 다른 경우에만 본문을 보냄
- 조건부 GET은 특별한 조건부 헤더를 추가해야 하고, 서버는 해당 조건이 참일 때 객체 반환
- HTTP에는 조건부 요청 헤더를 5개 정의했고, 각각 `If-` 접두어로 시작
    - 그 중 `If-Modified-Since`, `IF-None-Match` 각 캐시 재검사에 유용

### 7.8.5 If-Modified-Since: 날짜 재검사

- `If-Modified-Since: <date>` (IMS 요청이라고 줄여 부름)
- 주어진 날짜 이후로 수정되었다면 요청 메서드를 처리.
    - 참: 새 문서와 새 만료날짜와 정보들이 담긴 헤더와 함께 반환
    - 거짓: `304 Not Modified` 에 본문과 불필요한 헤더(예: `Content-Type` 처럼 잘 안변하는 정보)를 제외하고 갱신에 필요한 정보(예: 새 만료날짜)만 제공
- `Last-Modified` 서버 응답 헤더와 함께 사용
    - 원 서버에서 제공하는 문서의 최근 변경 일시 포함
- 몇 웹서버는 실제 날짜 비교로 구현하지 않고, 문자열 비교로 수행함.

### 7.8.6 If-None-Match: 엔터티 태그 재검사

- 날짜 재검사 하기 어려운 케이스가 있음
    - 어떤 문서는 일정 간격으로 다시쓰이지만(예: 백그라운드 프로세스로 동작) 실제 데이터가 같은 경우
    - 어떤 문서의 변경사항이 캐시가 다시 읽어들이기엔 사소한 경우(예: 철자나 주석 변경)
    - 어떤 서버는 그들의 페이지에 대한 최근 변경 일시를 정확히 판별할 수 없음
    - 어떤 서버는 1초보다 작은 간격으로 문서를 갱신
- `IF-None-Match: <tags>` :
- 마지막 변경 날짜 대신, 문서에 대한 일련번호와 같은 태그를 제공
- 캐시된 태그가 서버에 있는 문서 태그와 다를 때 요청 처리
    - 참: 새 문서와 새 ETag 반환
    - 거짓: `304 Not Modified` 응답 반환
- 엔터티 태그가 변경되었다면, 새
- 캐시가 여러 개의 사본을 갖고 있는 경우, 그것을 서버에게 알리기 위해 `If-None-Match` 헤더에 여러 개의 엔터티 태그 포함 가능

    ```
    If-None-Match: "v2.6"
    If-None-Match: "v2.4", "v2.5", "v2.6"
    If-None-Match: "foobar", "A34FAC0095", "Profiles in Courage"
    ```

### 7.8.7 약한 검사기와 강한 검사기

- 엔터티 태그로 최신인지 확인하는 경우, 엔터티 태그와 변경일시는 둘 다 "캐시 검사기(cache validator)"임.
- 약한 검사기(weak validator): 어느 정도의 컨텐츠 변경은 같은 문서로 취급 허용, 중요한 의미가 변경되면 함께 변경됨. HTTP/1.1 에서  지원.
- 강한 검사기(strong validator): 콘텐츠가 바뀔 때마다 바뀜.
- 조건부 특정 범위 가져오기 같은 몇몇 동작은 약한 검사기로는 불가능하기 떄문에, 서버는 `W/` 접두사로 약한 검사기를 구분

    ```
    ETag: W/"v2.6"
    If-None-Match: W/"v2.6"
    ```

- 서버는 서로 다른 두 엔터티에 대해 태그 값을 재활용해서는 안됨.
    - 강한 엔터티 태그: 엔터티 값이 어떻게 바뀌든지 매번 같이 바뀜
    - 약한 엔터티 태그: 대응하는 엔터티에 유의미한 변경이 있을 때마다 같이 변경

### 7.8.8 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가

- HTTP/1.1 클라이언트는
    - 서버가 엔터티 그 반환시 엔터티 태그 검사기를 반드시 사용.
    - Last-Modified 값만 반환했다면, `If-Modified-Since` 검사 사용
    - 둘다 가능하다면,  HTTP/1.0, 1.1 캐시 모두에 적절히 응답할 수 있도록 두 가지 정책을 모두 사용
- HTTP/1.1 서버는
    - 가능하다면 엔터티 태그 검사기를 보내야하며, 이점이 있다면 강한 엔터티 태그 대신 약한 엔터티 태그를 보낼 수 있음
    - `Last-Modified` 값을 같이 보내는 것도 선호
- HTTP/1.1 캐시나 서버가 `If-Modified-Since` 엔터티 태그 조건부 헤더를 모두 받았다면, 요청의 모든 조건부 헤더 필드의 조건에 부합되지 않는 이상 `304 Not Modified` 응답을 반환해서는 안됨

## 7.9 캐시 제어

- 서버는 캐시 만료 기간을 여러가지로 정의할 수 있으며, 우선순위는 다음과 같다.
    1. `Cache-Control: no-store` 헤더를 응답에 첨부
    2. `Cache-Control: no-cache` 헤더를 응답에 첨부
    3. `Cache-Control: must-revalidate` 헤더를 응답에 첨부
    4. `Cache-Control: max-age` 헤더를 응답에 첨부
    5. `Expires` 날짜 헤더를 응답에 첨부
    6. 아무 만료 정보를 주지않고, 캐시가 스스로 휴리스틱한 방법으로 결정

### 7.9.1 no-cache와 no-store 응답 헤더

- 캐시가 검증되지 않은 캐시 객체로 응답하는 것을 막음

```
Cache-Control: no-store
Cache-Control: no-cache
Pragma: no-cache
```

- `no-store` : 캐시가 응답의 사본을 만드는 것을 금지
    - 캐시는 보통 캐시가 아닌 프락시서버와 동일하게 클라이언트에게 `no-store` 응답 전달 후 객체 삭제
- `no-cache` : 캐시가 응답의 사본을 만들기는 하나, 서버와 재검사 없이는 클라이언트로 제공할 수 없음
- `Pragma: no-cache` :
    - HTTP/1.0+와의 하위호환성을 위해 HTTP/1.1에 포함.
    - HTTP 1.1 애플리케이션은 `Pragma: no-cache` 만 이해할 수 있는 HTTP/1.0을 대응해야 하는 경우가 아니라면 `Cache-Control: no-cache` 를 사용해야 함

### 7.9.2 Max-Age 응답 헤더

- `Cache-Control: max-age` 는 문서가 서버로부터 온 이후로 흐른 시간을 초로 나타냄
- `Cache-Control: s-maxage` 헤더는 (max와 age사이에 - 없음) `max-age` 와 동일하지만, 공유된 캐시에만 적용

```
Cache-Control: max-age=3600
Cache-Control: s-maxage=3600
```

- 서버는 0으로 설정함으로써, 캐시가 매 접근마다 문서를 캐시하거나 리프레시하지 않도록 요청할 수 있음

### 7.9.3 Expires 응답 헤더

- deprecated 된 `Expires` 헤더는 실제 만료 날짜 명시.
    - 많은 서버가 동기화되지 않거나, 부정확한 시계를 갖고 있어서 경과시간으로 표현하는 것이 낫다고 판단
- 몇 서버는 문서를 항상 만료되도록 하기 위해 `Expires: 0` 응답헤더를 돌려보내기도 하지만, 문법 위반이며 문제를 일으킬 수 있음.
    - 받아들일 수는 있지만, 생성해서는 안됨.

### 7.9.4 Must-Revalidate 응답 헤더

- 캐시는 성능 개선을 위해, 만료된 객체를 제공하도록 설정될 수 있음.
    - 엄격하게 만료 정보를 따르게 하고싶다면 `Cache-Control: must-revalidate` 사용
- 이 객체의 신선하지 않은 사본을 원 서버와의 재검사 없이 제공해서는 안됨을 의미
    - 캐시는 `must-revalidate` 신선도 검사를 시도했을 때, 원 서버 사용 불가라면 `504 Gateway Timeout error` 를 반환해야함

### 7.9.5 휴리스틱 만료

- 응답에 어떤 것도 포함하지 않는다면, 캐시는 휴리스틱한 방법으로 최대 나이 계산
- 계산 결과로 얻은 값이 24시간 보다 크다면 Heuristic Expiration 경고 헤더가 응답에 추가되어야 함
- 휴리스틱 만료 알고리즘이든 어떤 것이 사용될 수 있지만, LM 알고리즘이 유명
    - 문서가 최근 변경 일시를 포함하고 있다면 사용 가능. 얼마나 자주 바뀌는지 추정에 사용
    - 캐시된 문서의 마지막 변경일이 옛날이라면, 안정적인 문서이므로 오래보관
    - 캐시된 문서가 최근에 변경되었다면, 자주 변경될 것이고 따라서 짧은 시간만 캐시

    ```perl
    $마지막_수정_이후로_경과한_시간 = max(0, $서버의_Date - $서버의_Last_Modified);
    $서버_신선도_한계 = int($마지막_수정_이후로_경과한_시간 * $lm_인자);
    ```

- 최근 변경일 조차 없다면 캐시는 판단 근거를 갖지 못하므로, 기본 신선도 유지기간(보통 한시간~하루) 설정
    - 더 보수적인 캐시면 수명이 없기도함.

### 7.9.6 클라이언트 신선도 제약

- 웹 브라우저는 브라우저/프락시 캐시의 콘텐츠를 강제로 갱신 시켜주는 리프레시/리로드 버튼이 있음
    - `Cache-Control` 요청 헤더가 추가된 GET 요청을 발생시켜, 강제로 재검사하거나 서버로부터 콘텐츠를 가져옴
    - 정확한 동작은 브라우저, 중간 캐시 설정따라 다름
- 클라이언트는 `Cache-Control` 요청 헤더를 사용하여 만료 제약을 엄격/느슨하게 할 수 있음
- `Cache-Control` 요청 지시어
    - `Cache-Control: max-stale` / `Cache-Control: max-stale = <s>`
        - 신선하지 않은 문서라도 자유롭게 제공. 만약 `<s>`가 지정되면, 만료시간이 그 매개변수만큼 지닌 문서도 받아들임. 규칙을 느슨하게 만듦.
    - `Cache-Control: mmin-fresh = <s>`
        - 클라이언트는 지금부터 적어도 `<s>`초 후까지 신선한 문서만을 받아들임. 규칙을 엄격하게 만듦.
    - `Cache-Control: max-age = <s>`
        - 캐시는 `<s>`초 보다 오래된 문서를 반환할 수 없음.  `max-stale` 가 함께 설정되지 않는 이상 규칙을 엄격하게 만듦.
    - `Cache-Control: no-cache` / `Pragma: no-cache`
        - 클라이언트는 캐시된 리소스는 재검사 하기 전에는 받아들이지 않음
    - `Cache-Control: no-store`
        - 저장소에서 문서의 흔적을 빨리 삭제해야 함. 민감정보가 포함되어있음
    - `Cache-Control: only-if-cached`
        - 클라이언트는 캐시에 들어있는 사본만 원함

### 7.9.7 주의할 점

- 문서 만료는 완벽한 시스템이 아님
    - 실수로 유효기간을 너무 길게 설정하거나, 유효기간을 사용하지 않을 수도 있음.

## 7.10 캐시 제어 설정

- 웹 서버들은 캐시 제어/만료 HTTP 헤더 설정을 서로 다른 메커니즘으로 제공

### 7.10.1 아파치로 HTTP 헤더 제어하기

- HTTP 캐시 제어 헤더를 설정할 수 있는 여러 메커니즘을 제공.
- 대부분의 메커니즘이 디폴트로 가능하지 않아서, 활성화가 필요하며, 이 중 몇 가지를 소개

***mod_header***

- 개별 헤더를 설정할 수 있게 해주는 모듈
- 모든 HTML 파일을 캐시되지 않도록 설정하는 예

    ```
    <Files *.html>
    	Header set Cache-control no-cache
    </Files>
    ```

***mod_expires***

- 적절한 만료 날짜가 담긴 `Expires` 헤더를 자동으로 생성하는 프로그램 로직 제공하는 모듈

    ```
    ExpiresDefault A3600
    ExpiresDefault M86400
    ExpiresDefault "access plus 1week"
    ExpiresByType text/html "modification plus 2 days 6 hours 12 minutes"
    ```

***mod_cern_meta***

- HTTP 헤더들의 파일을 특정 객체와 연결시키는 모듈

### 7.10.2 HTTP-EQUIV를 통한 HTML 캐시 제어

- HTTP 서버 응답 헤더는 문서의 만료와 캐시 정보를 돌려주기 위해 사용.
- 웹 서버 설정 파일과 상호작용 없이 쉽게 HTML 문서에 HTTP 헤더 정보를 부여하기 위해 [`<META HTTP-EQUIV>`](https://developer.mozilla.org/ko/docs/Web/HTML/Element/meta) 태그를 정의함

    ```html
    <html>
    	<head>
    		<title>My Document</title>
    		<meta http-equiv="Cache-control" content="no-cache">
    	</head>
    	...
    ```

- 서버는 html에서 해당 태그를 파싱하여 응답에 헤더를 삽입할 것을 의도되어있음.
    - [RFC 1866](https://tools.ietf.org/html/rfc1866)에 정의되어 있음.
    - HTTP 서버는 문서를 처리하는 과정에서 이 정보를 사용한다. 특히, 서버는 이 문서에 대한 요청의 응답에 헤더 필드를 포함할 것이다. 헤더의 이름은 HTTP-EQUIV의 속성값에서 얻고 헤더의 값은 CONTENT 속성의 값에서 얻는다.
- 서버의 부하 가중, 설정 값이 정적, HTML 외의 다른 타입 파일은 미지원의 이유로 웹 서버나 프락시는 대부분 지원하지 않음.
    - 브라우저가 기능을 지원하여, 태그를 파싱하고 실제 HTTP 헤더처럼 다루는 경우도 있는데, 그러면 중간의 프락시 캐시와 다르게 규칙을 적용하게되어 혼란을 초래함.

## 7.11 자세한 알고리즘

- HTTP 명세에서는 문서의 나이, 캐시 신선도를 계산하는 알고리즘을 제공하지만 어렵고 혼란스럽다.
- 캐시 내부에 대한 일을 하는 독자에게 유용하며, 깊은 세부사항에 관심 없다면 건너뛰어도 무방
- 해당 내용이 필요한 경우 원책 참조

## 7.12 캐시와 광고

### 7.12.1 광고 회사의 딜레마

- 캐시는 콘텐츠 제공자에게 접근/유지 비용을 줄일 수 있지만, 광고 접근 횟수를 알기 어려움.
    - 광고의 원서버에 접근하지 않아, 캐시가 접근을 흡수함.

### 7.12.2 퍼블리셔의 응답

- 광고 회사들은 광고 시청수를 가로채지 못하도록, 모든 종류의 '캐시 무력화' 기법 사용.
- 오늘 날에는 콘텐츠 제공자는 모든 접근에 재검사를 하게 한다. 물론 트랜잭션을 느리게 함.

### 7.12.3 로그 마이그레이션

- 이상적으로는 서버로 요청이 가지 않게 하는 것. 대신 캐시가 적중한 로그를 서버에게 나누어 주는 것임.
- 하지만 적중 로그는 크기가 커 옮기기 어렵고, 표준화되지 않았으며, 인증 및 프라이버시 이슈도 있음.

### 7.12.4 적중 측정과 사용량 제한

- [RFC 2227](https://www.ietf.org/rfc/rfc227.txt), "HTTP를 위한 간단한 캐시 적중량 측정과 사용량 제한(Simple Hit-Metering and Usage-Limiting for HTTP" 에서 더 간단한 방법 정의.
- 특정 URL에 대한 캐시 적중 횟수를 정기적으로 서버에게 돌려주는 Meter라는 새 헤더 하나를 추가
    - 서버가 캐시된 문서가 적중한 횟수의 정기적인 업데이트를 캐시로 부터 받음.
    - 추가적으로 원 서버가 캐시가 문서를 제공할 수 있는 횟수나 소모할 수 있는 처리 시간도 제어 가능