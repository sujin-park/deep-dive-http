# 7장 캐시

이 장에서 공부할 수 있는 내용은 아래와 같습니다.

- 불필요한 데이터 전송을 줄여 네트워크 비용 감소
- 네트워크 병목 감소
- 원 서버에 대한 요청 감소
- 거리로 인한 지연 감소

## 7.1 불필요한 데이터 전송

캐시를 이용하면,
- 서버 응답은 캐시에 보관
- 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용되므로 주고받는 트래픽 낭비 감소

## 7.2 대역폭 병목

캐시는 네트워크 병목을 줄여줍니다. 대부분 네트워크는 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공합니다. 클라이언트가 빠른 LAN에 있는 캐시로부터 사본을 가져온다면, 캐싱은 성능을 대폭 개선할 수 있습니다.

## 7.3 갑작스런 요청 쇄도(Flash Crowds)

갑작스런 요청 쇄도가 발생하면 불필요한 트래픽이 급증하여 네트워크와 웹 서버의 심각한 장애를 야기시킵니다. ```캐싱```은 이러한 갑작스런 요청 쇄도에 대처하기 위해 특히 중요합니다.

## 7.4 거리로 인한 지연

모든 네트워크 라우터는 인터넷 트래픽을 지연시킵니다. 대역폭이 문제가 되지 않더라도 거리가 멀면 문제가 될 수 있습니다.

근처에 캐시를 설치해서 문서가 전송되는 거리를 수천 킬로미터에서 수십 미터로 줄일 수 있습니다.

## 7.5 적중과 부적중

```캐시 적중```이란 캐시에 요청이 도착했을 때, 대응하는 사본에 있다면 사본을 이용해 요청이 처리되는 것을 말합니다.

반대로 ```캐시 부적중```은 대응하는 사본이 없어서 원 서버로 전달되는 것을 말합니다.

### 7.5.1 재검사(Revalidation)

```재검사```란 갖고 있는 사본이 여전히 최신인지 서버를 통해 때때로 점검하는 것을 의미합니다.

클라이언트가 사본을 요청했을 때, 사본이 검사를 할 필요가 있을 정도로 충분히 오래된 경우에만 재검사를 합니다.

재검사 요청 시 콘텐츠가 변경되지 않았다면, **304 Not Modified** 응답을 보냅니다. 이렇게 재검사 시 일치하는 사본이 있을 때 ```재검사 적중```이라고 부르는데 재검사 적중은 캐시 적중보단 느리지만 캐시 부적중보단 빠릅니다.


> If-Modified-Since Header

이 헤더를 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미

**재검사 적중**

서버 객체가 변경되지 않았다면, **304 Modified** 응답

**재검사 부적중**

서버 객체가 캐시된 사본과 다르면 콘텐츠 전체와 함께 **200 OK** 응답 

**객체 삭제**

서버 객체가 삭제되었다면, **404 Not Found** 응답

### 7.5.2 적중률

```캐시 적중률```이란 캐시가 요청을 처리하는 비율을 의미합니다. 0에서 1까지의 값으로 표현하고 때로는 0% ~ 100%로 표현하기도 합니다.

### 7.5.3 바이트 적중률

```바이트 적중률```은 캐시를 통해 제공된 모든 바이트의 비율을 표현합니다.

바이트 적중률은 얼마나 많은 바이트가 인터넷으로 나가지 않았는지 보여주는 수치로 이 수치의 개선은 대역폭 절약을 최적화합니다.

### 7.5.4 적중과 부적중의 구별

클라이언트가 응답이 캐시에서 왔는지 구별하는 방법은 **Date 헤더**를 이용하는 것입니다.

응답의 생성일이 Date 와 비교했을 때, 더 오래되었다면 캐시된 응답임을 알 수 있습니다. 또는 응답이 얼마나 오래되었는지 말해주는 Age 헤더를 이용하는 것입니다.

## 7.6 캐시 토폴로지

한 명에게만 할당된 캐시를 개인 전용 캐시(private cache), 공유된 캐시는 공용 캐시(public cache)라고 불립니다.

### 7.6.1 개인 전용 캐시

웹브라우저는 개인 전용 캐시를 내장하고 있습니다. 구글 크롬의 경우, 특별한 URL인 about:cache 를 통해 연결되는 페이지에서 캐시 콘텐츠의 목록을 볼 수 있습니다. (Chrome 65 버전에서만 유효합니다.)

### 7.6.2 공용 프락시 캐시

```공유 캐시```는 캐시 프락시 서버 혹은 프락시 캐시라고 불립니다. 로컬 캐시에서 문서를 제공하거나 혹은 사용자의 입장에서 서버에 접근합니다. 여러 사용자가 접근하기 때문에 불필요한 트래픽을 줄일 수 있는 많은 기회가 있습니다.

### 7.6.3 프락시 캐시 계층들

1단계 작은 규모의 캐시에서 확인하고, 일치하는 것이 없다면 더 큰 부모 캐시가 사용자의 요청을 처리할 수 있습니다.
캐시 계층이 깊다면 연쇄가 발생할 것이고 프락시 연쇄는 길어질수록 현저한 성능 저하가 발생됩니다.

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

캐시망 안에서의 콘텐츠 라우팅을 위해 설계된 캐시들은 아래와 같은 일을 할 수 있습니다.

- URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택
- URL에 근거하여 특정 부모 캐시를 동적으로 선택
- 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 검색
- 부분적으로 캐시된 콘텐츠에 접근할 수 있도록 허용하되, 캐시를 통한 인터넷 트랜짓은 허용하지 않음

## 7.7 캐시 처리 단계

HTTP GET 메시지 하나를 처리하는 기본적인 캐시 처리 절차

1. 요청 받기 - 캐시는 네트워크로부터 도착한 요청 메시지를 읽는다.
2. 파싱 - 캐시는 메시지를 파싱하여 URL과 헤더 추출
3. 검색 - 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아와 로컬에 저장
4. 신선도 검사 - 캐시는 캐시된 사본이 충분히 신선한지 검사, 그렇지 않다면 서버에게 물어본다
5. 응답 생성 - 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지 생성
6. 발송 - 캐시는 넽워크를 통해 응답을 클라이언트에게 반환
7. 로깅 - 선택적으로 로그파일에 트랜잭션에 대해 서술한 로그 하나 생성

### 1. 요청받기

- 캐시는 여러 개의 들어오는 커넥션들로부터 데이터를 동시에 읽어들이고 메시지 전체가 도착하기 전에 트랜잭션 처리 시작

### 2. 파싱

- 요청 메시지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료 구조에 저장

### 3. 검색

- 캐시는 URL을 알아내고 그에 해당하는 로컬 사본이 있는지 검사
- 캐시된 객체는 서버 응답 본문과 헤더를 포함하고 있으므로, 캐시 적중 동안 올바른 서버 헤더가 반환

### 4. 신선도 검사

- HTTP 캐시가 일정 기간 동안 서버 문서의 사본을 보유할 수 있도록 해주는데 이 기간은 신선한 것으로 간주
- 신선하지 않으면 재검사 필요

### 5. 응답 생성

- 캐시는 캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성
- Date 헤더는 객체가 원 서버에서 최초로 생겨난 일시를 표현하는 것으로 캐시는 Date 헤더를 조정해서는 안됨

### 6. 전송

- 일단 응답 헤더가 준비되면, 캐시는 응답을 클라이언트에게 반환
- 고성능 캐시는 로컬 저장장치와 네트워크 I/O 버퍼 사이에서 문서의 콘텐츠 복사를 피함으로써 데이터를 효과적으로 전송하기 위해 노력

### 7. 로깅

- 대부분의 캐시는 로그 파일과 캐시 사용에 대한 통계를 유지
- 가장 많이 쓰이는 캐시 로그 포맷은 스퀴드 로그 포맷, 넷스케이프 확장 공용 로그 포맷

## 7.8 사본을 신선하게 유지하기

서버 재검사를 통해 캐시된 데이터와 서버와 충분히 일치하도록 유지할 수 있게 해줍니다.

### 7.8.1 문서 만료

- 원 서버가 각 문서에 유효기간을 붙일 수 있게 해주는 헤더 : HTTP Cache-Control, Expires

### 7.8.2 유효기간과 나이

- 서버는 응답 본문과 함께 하는, HTTP/1.0+ Expires, Cache-Control:max-age 응답 헤더를 이용해서 유효기간 명시

| 헤더 | 설명 |
|---|:---:|
| `Cache-Control: max-age` | 문서가 처음 생성된 이후 더 이상 신선하지 않다고 간주될 때까지 경과한 시간의 합법적인 최대값에 대한 정의 |
| `Expires` | 절대 유효기간 명시 |

### 7.8.3 서버 재검사

```서버 재검사```는 캐시가 원 서버에게 문서가 변경되었는지 여부를 물어볼 필요가 있음을 의미하는 것으로 문서가 다르다는 것을 의미하는 것은 아닙니다.

재검사 결과,
- 콘텐츠가 변경되었다면: 새로운 사본을 가져와 오래된 데이터 대신 저장 및 클라이언트에게 전송
- 콘텐츠가 변경되지 않았다면: 새 만료일을 포함한 새 헤더들로 캐시 안의 헤더들을 갱신

### 7.8.4 조건부 메서드와의 재검사

캐시 재검사를 할 때 가장 유용한 ```If-Modified-Since``` 와 ```If-None-Match```입니다. 모든 조건부 헤더는 If-* 입니다.

| 헤더 | 설명 |
|---|:---:|
| `If-Modified-Since: <date>` | 문서가 주어진 날짜 이후로 수정되었다면 요청 메서드를 처리, 콘텐츠가 변경된 경우에만 가져오기 위해 Last-Modified 서버 응답 헤더와 함께 사용 |
| `If-None-Match: <tags>` | 서버는 문서에 대한 일련번호와 같이 동작하는 태그, 캐시된 태그가 서버에 있는 문서의 태그와 다를때만 요청 처리 |

### 7.8.5 If-Modified-Since : 날짜 재검사

가장 흔히 쓰이는 ```캐시 재검사 헤더```는 If-Modified-Since 입니다.

- If-Modified-Since 헤더는 서버 응답 헤더의 Last-Modified 헤더와 함께 동작
- 원 서버는 제공하는 문서에 최근 변겨 일실르 붙이고, 캐시가 캐시된 문서를 재검사 하려고 할때, 캐시된 사본이 마지막으로 수정된 날짜가 담긴 If-Modified-Since 헤더를 포함

**날짜 재검사가 어려운 상황**

- 일정 시간 간격으로 다시 쓰여지지만 같은 데이터를 포함하고 있는 경우
- 전 세계의 캐시들이 그 데이터를 다시 읽어들이기엔 사소한 것일 수 있음
- 최근 변경 일시를 정확하게 판별 할 수 없는 경우
- 1초보다 작은 간격으로 갱신되는 문서는 변경일에 대한 1초의 정밀도가 충분하지 않을 수 있는 경우

### 7.8.6 If-None-Match: 엔티티 태그 재검사

- ```If-None-Match``` 헤더를 사용하여 원 서버에게 태그가 더 이상 동일하지 않을 때 새 객체를 달라고 요청하는 방법
- 태그가 여전히 변경되지 않았으면 304 Not Modified 와 함께 Etag에 동일한 태그를 반환
- 태그가 변경되었다면 200 OK 응답으로 새 Etag와 함께 반환
- If-None-Match 헤더에 여러 개의 엔티티 태그 포함 가능

## 7.9 캐시 제어 

### no-cache 와 no-store 응답 헤더

```no-cache```로 표시된 응답은 서버와 재검사를 통해 캐시에서 클라이언트로 제공될 수 있고, 로컬 캐시 저장소에 저장될 수 있습니다.

### Max-Age 응답 헤더

```Cache-Control: max-age``` 헤더는 문서가 버서로부터 온 이후로 소요된 시간이고, 초로 나타냅니다. 서버는 maximum aging 을 0으로 설정함으로써, 캐시가 매 접근마다 문서를 캐시하거나 리프레시하지 않도록 요청할 수 있습니다.

## 7.10 캐시 제어 설정

웹 서버들은 캐시 제어와 만료 HTTP 헤더들을 설정하는 서로 다른 메커니즘을 제공합니다.

### 아파치로 HTTP 헤더 제어하기

아파치 웹 서버는 HTTP 캐시 제어 헤더를 설정할 수 있는 여러 가지 메커니즘을 제공합니다.

- mod_headers
- mod_expires
- mod_cern_meta