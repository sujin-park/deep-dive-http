# 07. 캐시

* 웹 캐시는 자주 사용되는 문서의 사본을 자동으로 보관하는 HTTP 장치다.
* 캐시의 혜택
  * 캐시는 불필요한 데이터 전송을 줄여서, 네트워크 요금으로 인한 비용을 줄여준다.
  * 캐시는 네트워크 병목을 줄여준다. 대역폭을 늘리지 않고도 페이지를 빨리 불러올 수 있게 된다.
  * 캐시는 원 서버에 대한 요청을 줄여준다. 서버는 부하를 줄일 수 있으며 더 빨리 응답할 수 있게 된다.
  * 페이지를 먼 곳에서 불러올수록 시간이 많이 걸리는데, 캐시는 거리로 인한 지연을 줄여준다.

## 7.1 불필요한 데이터 전송

* 여러 클라이언트가 자주 쓰이는 원 서버 페이지에 접근할 떄, 서버는 같은 문서를 각각의 클라이언트에게 반복해서 전송하게 된다.
* 이런 불필요한 데이터 전송은 값비싼 네트워크 대역폭을 잡아먹고 전송을 느리게 만들며, 웹 서버에 부하를 준다.
* 캐시를 이용하면 첫 번째 서버 응답이 캐시에 보관되고, 캐시된 사본이 뒤이은 요청들의 응답으로 사용될 수 있다.
  * 원 서버가 중복해서 트리팩을 주고받는 낭비가 줄어든다.

## 7.2 대역폭 병목

* 캐시는 네트워크 병목을 줄여준다.
* 많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공한다.
* 클라이언트들이 서버에 접근할 때 속도는 그 경로의 가장 느린 네트워크의 속도와 같다.
* 만약 클라이언트가 빠른 LAN에 있는 캐시로부터 사본을 가져오면, 특히 큰 문서에 대해 캐싱은 성능을 대폭 개선할 수 있을 것이다.
* 대역폭은 큰 문서에 현저한 지연을 일으키며 속도는 네트워크 종류의 차이에 따라 극적으로 달라진다.

## 7.3 갑작스런 요청 쇄도(Flash Crowds)

* 캐싱은 많은 사람들이 거의 동시에 웹 문서에 접근할 때와 같은 갑작스런 요청 쇄도에 대처하기 위해 특히 중요하다.
* 이 결과 불필요한 트래픽이 급증하고 네트워크와 웹 서버의 심각한 장애를 야기시킨다.

## 7.4 거리로 인한 지연

* 대역폭이 문제가 되지 않더라도 거리가 문제가 될 수 있다. 모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킨다.
* 클라이언트와 서버 사이에 라우터가 그다지 많지 않아도 빛의 속도 그 자체가 유의미한 지연을 유발한다.
* 기계실 근처에 캐시를 설치해 문서가 전송되는 거리를 수천 킬로미터에서 수십 미터로 줄일 수 있다.

## 7.5 적중과 부적중

* 캐시가 모든 문서의 사본을 저장하지는 않는다.
* 캐시에 요청이 도착했을 때, 그에 대응하는 사본이 있다면 그를 이용해 요청이 처리될 수 있다: 캐시 적중(cache hit)
* 대응하는 사본이 없다면 그냥 원 서버로 전달되기만 한다: 캐시 부적중(cache miss)

### 7.5.1 재검사 Revalidation

* HTTP 재검사(신선도 검사): 원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 갖고 있는 사본이 여전히 최신인지 서버를 통해 때떄로 점검해야 한다.
* 캐시는 스스로 원할 때 언제든지 사본을 재검사할 수 있다.
  * 그러나 캐시는 흔히 문서를 수백만 개씩 가지고 있으나 네트워크 대역폭은 부족하므로, 대부분 캐시는 클라이언트가 사본을 요청했고, 사본이 충분히 오래된 경우에만 재검사를 한다.
* 재검사가 필요할 때 캐시는 원 서버에 작은 재검사 요청을 보내고, 콘텐츠가 변경되지 않았다면 서버는 아주 작은 `304 Not modified` 응답을 보낸다.
* 재검사 적중(느린 적중): 사본이 여전히 유효함을 알게 된 캐시는 즉각 사본이 신선함을 임시로 다시 표시한 뒤 사본을 클라이언트에게 제공한다.
  * 이는 원 서버와 검사를 할 필요가 있어서 순수 캐시 적중보다 느리다.
  * 캐시 부적중보다는 빠른데, 서버로부터 객체 데이터를 받아올 필요가 없기 떄문이다.
* HTTP는 캐시된 객체를 재확인하기 위해 몇 가지 도구를 제공하는데, 가장 많이 사용되는 것은 `If-Modified-Since` 헤더다.
  * 서버에 보내는 GET 요청에 이 헤더를 추가하면 캐시된 시간 이후 변경된 경우에만 사본을 보내달라는 의미이다.
* 다음은 `GET If-Modified-Since` 요청이 서버에 도착했을 때 일어날 수 있는 세 가지 상황이다.
  * 재검사 적중: 서버 객체가 변경되지 않았다면, 서버는 클라이언트에게 작은 `304 Not modified` 응답을 보낸다.
  * 재검사 부적중: 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 `HTTP 200 OK` 응답을 클라이언트에게 보낸다.
  * 객체 삭제: 서버 객체가 삭제되었다면, 서버는 `4040 Not Found` 응답을 돌려보내며, 캐시는 사본을 삭제한다.

### 7.5.2 적중률

* 캐시가 요청을 처리하는 비율을 캐시 적중률(캐시 적중비), 혹은 문서 적중률(문서 적중비)라고 부르기도 한다.
* 적중률은 0에서 1까지 값으로 되어있지만, 흔히 퍼센트로 표현되기도 한다.
  * 0%는 모든 요청이 캐시 부적중(네트워크 너머로 문서를 가져와야 했던 경우), 100%는 모든 요청이 캐시 적중(캐시에서 사본을 가져온 경우)임을 의미한다.
* 캐시 적중률은 캐시가 얼마나 큰지, 캐시 사용자들의 관심사가 얼마나 비슷한지, 캐시된 데이터가 얼마나 자주 변경되거나 개인화되는지, 캐시가 어떻게 설정되어 있는지에 달려있다.
* 적중률은 예측하기 어렵지만 오늘날 적중률이 40%면 웹 캐시로 괜찮은 편이다.
* 보통 크기의 캐시라도 충분히 자주 쓰이는 문서를 보관할 수 있으며 상당히 트래픽을 줄이고 성능을 개선할 수 있다.

### 7.5.3 바이트 적중률

* 문서들이 모두 같은 크기인 것은 아니기 때문에 문서 적중률이 모든 것을 말해주진 않는다.
* 몇몇 큰 객체는 덜 접근되지만 그 크기 때문에 전체 트래픽에는 더 크게 기여한다. 그래서 단위 적중률 측정값을 더 선호하기도 한다.
* 바이트 단위 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현한다. 이 측정값은 트래픽이 절감된 정도를 포착해낸다.
* 바이트 단위 적중률 100%는 모든 바이트가 캐시에서 왔으며 어떤 트래픽도 인터넷으로 나가지 않았음을 의마한다.
* 문서 적중률, 바이트 단위 적중률 둘다 캐시 성능에 대한 유용한 지표다.
* 문서 적중률은 얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지 보여준다.
* 트랜잭션은 고정된 소요 시간을 포함하는데, 종종 길 수도 있기 때문에(서버로의 TCP 커낵션을 맺는 경우), 문서 적중률을 개선하면 전체 대기시간(지연)이 줄어든다.
* 바이트 단위 적중률은 얼마나 많은 바이트가 인터넷으로 나가지 않았는지 보여주며, 이의 개선은 대역폭 절약을 최적화한다.

### 7.5.4 적중과 부적중의 구별

* HTTP는 클라이언트에게 응답이 캐시 적중이었는지, 원 서버 접근인지 말해줄 수 있는 방법을 제공하지 않는다.
  * 두 경우 모두 응답 코드는 응답이 본문을 갖고 있음을 의미하는 200 OK가 된다.
* 어떤 상용 프락시 캐시는 캐시에 무슨 일이 있어났는지 설명하기 위해 Via 헤더에 추가 정보를 붙인다.
* 클라이언트가 응답이 캐시에서 왔는지 알아내는 방법은 Date 헤더를 이용하는 것이다.
  * 응답의 Date 헤더 값을 현재 시각과 비교하여 응답의 생성일이 더 오래되었다면 클라이언트는 응답이 캐시된 것임을 알아낼 수 있다.
* 클라이언트가 캐시된 응답을 감지하는 또 다른 방법은 응답이 얼마나 오래되었는지 말해주는 Age 헤더를 이용하는 것이다.

## 7.6 캐시 토폴로지

* 캐시는 한 명의 사용자에게만 할당되거나 또는 수천 명의 사용자들 간에 공유될 수도 있다.
* 개인 전용 캐시(private cache): 한 명에게만 할당된 캐시다. 개인만을 위한 것으로, 한 명의 사용자가 자주 찾는 페이지를 담는다.
* 공용 캐시(public cache): 공유된 캐시다. 사용자 집단에게 자주 쓰이는 페이지를 담는다.

### 7.6.1 개인 전용 캐시

* 개인 전용 캐시는 많은 에너지나 저장 공간이 필요하지 않아 작고 저렴할 수 있다.
* 웹 브라우저는 개인 전용 캐시를 내장하고 있다. 대부분 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시하고, 사용자가 캐시 사이즈와 설정을 수정할 수 있게 한다.
* 캐시에 어떤 것이 있는지 조회할 수도 있다.
  * IE는 캐시된 문서를 '임시 파일'이라고 하며 연관된 URL 및 문서 만료 시각과 함께 파일 목록에 나열한다.
  * Chrome은 특별한 URL인 `about:cache`를 통해 연결되는 페이지에서 캐시 콘텐츠의 목록을 볼 수 있다.

### 7.6.2 공용 프락시 캐시

* 공용 캐시는 캐시 프락시 서버 혹은 흔히 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버다.
* 프락시 캐시는 로컬 캐시에서 문서를 제공하거나, 사용자 입장에서 서버에 접근한다.
* 공용 캐시에는 여러 사용자가 접근하기 때문에 불필요한 트래픽을 줄일 수 있는 더 많은 기회가 있다.
* 공용 캐시에서 캐시는 자주 찾는 객체를 단 한 번만 가져와 모든 요청에 대해 공유된 사본을 제공함으로써 네트워크 트래픽을 줄인다.
* 프락시 캐시는 프락시 규칙을 따른다. 수동 프락시를 지정하거나 프락시 자동설정 파일을 설정함으로써 브라우저가 프락시 캐시를 사용하게 설정할 수 있다.
* 인터셉트 프락시를 사용하여 브라우저의 설정 없이 HTTP 요청이 캐시를 통하도록 강제할 수 있다.

### 7.6.3 프락시 캐시 계층들

* 작은 캐시에서 캐시 부적중이 발생했을 때 더 큰 부모 캐시가 그 '걸러 남겨진' 트래픽을 처리하도록 하는 계층을 만드는 방식이 합리적인 경우가 많다.
* 클라이언트는 주위에 작고 저렴한 캐시를 사용하고 계층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하기 위해 더 크고 강력한 캐시를 사용자하는 것이다.
* 캐시 계층이 깊다면 요청은 캐시의 긴 연쇄를 따라가게 된다. 프락시 연쇄가 길어질수록 각 중간 프락시는 현저한 성능 저하가 발생한다.

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

* 몇몇 네트워크 아키텍처는 단순한 캐시 계층 대신 복잡한 캐시망을 만든다.
* 캐시망의 프락시 캐시는 복잡한 방법으로 서로 대화하여, 어떤 부모 캐시와 대화할 것인지, 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할 것인지 등 캐시 커뮤니케이션 결정을 동적으로 내린다.
* 캐시망 안에서 콘텐츠 라우팅을 위해 설계된 캐시들은 이런 일들을 한다.
  * URL에 근거하여 부모 캐시와 원 서버중 하나를 동적으로 선택한다.
  * URL에 근거하여 특정 부모 캐시를 동적으로 선택한다.
  * 부모 캐시에 가기 전에 캐시된 사본을 로컬에서 찾아본다.
  * 다른 캐시들이 그들의 캐시된 콘텐츠에 부분 접근할 수 있도록 허용하더ㅚ, 캐시를 통한 인터넷 트랜짓(Internet Transit)은 허용하지 않는다.
* 이런 캐시 사이의 관계는 서로 다른 조직들이 상호 이득을 위해 그들의 캐시를 연결하여 서로 찾아볼 수 있게 해준다.
* 선택적인 피어링을 지원하는 캐시는 형제 캐시라고 불린다.
* HTTP는 형제 캐시를 지원하지 않기 때문에 사람들은 인터넷 캐시 프로토콜(ICP)나 하이퍼텍스트 캐시 프로토콜(HTCP) 같은 프로토콜을 이용해 HTTP를 확장했다.

### 7.7 캐시 처리 단계

1. 요청 받기: 캐시는 네트워크로부터 도착한 요청 메시지를 읽는다.
2. 파싱: 캐시는 메시지를 파싱하여 URL과 헤더들을 추출한다.
3. 검색: 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없었다면 사본을 받아온다.(그리고 로컬에 저장한다)
4. 신선도 검사: 캐시는 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에 물어본다.
5. 응답 생성: 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.
6. 발송: 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려준다.
7. 로깅: 선택적으로, 캐시는 로그파일에 트랜잭션에 대해 서술한 로그 하나를 남긴다.

### 7.7.1 단계 1: 요청 받기

* 캐시는 네트워크 커넥션에서의 활동을 감지하고 들어오는 데이터를 읽어들인다.
* 고성능 캐시는 여러 개의 들어오는 커넥션들로부터 데이터를 동시에 읽어들이고 메시지 전체가 도착하기 전에 트랜잭션 처리를 한다.

### 7.7.2 단계 2: 파싱

* 캐시는 요청 메시지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료구조에 담는다.
* 이는 캐싱 소프트웨어가 헤더 필드를 처리하고 조작하기 쉽게 만들어준다.

### 7.7.3 단계 3: 검색

* 캐시는 URL을 알아내고 그에 해당하는 로컬 사본이 있는지 검사한다.
* 로컬 복사본은 메모리 혹은 디스크나 근처 다른 컴퓨터에 있을 수도 있다.
* 전문적 수준의 캐시는 객체를 로컬 캐시에서 가져올 수 있는지 판단하기 위해 빠른 알고리즘을 사용한다.
* 로컬에서 문서를 가져올 수 없다면, 캐시는 상황이나 설정에 따라 원 서버나 부모 프락시에서 가져오거나 혹은 실패를 반환한다.
* 캐시된 객체는 서버 응답 본문과 원 서버 응답 헤더를 포함하고 있으므로, 캐시 적중 동안 올바른 서버 헤더가 반환될 수 있다.
* 캐시된 객체는 객체가 얼마나 오래 캐시에 머무르고 있었는지 알려주는 기록이나 얼마나 자주 사용되었는지 등 몇몇 메타 데이터를 포함한다.

### 7.7.4 단계 4: 신선도 검사

* HTTP는 캐시가 일정 기간 동안 서버 문서의 사본을 보유할 수 있게 한다.
* 이 기간 동안 문서는 '신선'한 것으로 간주되고 캐시는 서버와 접촉 없이 문서를 제공할 수 있다.
* 캐시된 사본을 신서도 한계를 넘을 정도로 오래 갖고 있었다면 그 객체는 '신선하지 않은'것으로 간주되며, 캐시는 그것을 제공하기 전에 문서에 어떤 변경이 있었는지 검사하기 위해 서버와 재검사를 해야한다.
* HTTP의 신선도 검사 규칙은 매우 복잡한데, 캐시 제품들이 지원하는 많은 수의 설정 옵션과 비 HTTP 신선도 표준과응 상호작용은 상황을 더 복잡하게 만들었다.

### 7.7.5 단계 5: 응답 생성

* 캐시된 응답을 원 서버에서 온 것처럼 보이게 하려고 캐시는 캐시된 서버 응답헤더를 토대로 응답 헤더를 생성한다. 이 기저 헤더들은 캐시에 의해 수정되고 늘어난다.
* 캐시는 클라이언트에 맞게 이 헤더를 조정해야 하는 책임이 있다.
  * 클라이언트가 HTTP/1.1 응답을 기대하는 상황에서 서버가 HTTP/1.0 응답을 반환했다면 캐시는 반드시 헤더를 적절하게 번역해야 한다.
* 캐시는 캐시 신선도 정보를 삽입하며( 요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
* 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 따라 다르다.
* 클라이언트는 Cache-Control, Age, Expires 헤더), 요청이 프락시 캐시를 거쳐갔음을 알려주기 위해 종종 Via 헤더를 포함시킨다.
* 캐시는 Date 헤더를 조정해서는 안 된다. Date 헤더는 그 객체가 원 서버에서 최초로 생겨난 일시를 표현한다.

### 7.7.6 단계 6: 전송

* 응답 헤더가 준비되면 캐시는 응답을 클라이언트에게 돌려준다.
* 프락시 서버들과 마찬가지로 프락시 캐시는 클라이언트와의 커넥션을 유지할 필요가 있다.
* 고성능 캐시는 종종 로컬 저장장치와 네트워크 I/O 버퍼 사이에서 문서의 콘텐츠 복사를 피하여 데이터를 효과적으로 전송하기 위해 노력한다.

### 7.7.7 단계 7: 로깅

* 대부분 캐시는 로그 파일과 캐시 사용에 대한 통계를 유지한다.
* 각 캐시 트랜잭션 완료 후, 캐시는 통계 캐시 적중과 부적중 횟수(그리고 다른 관련 지표들)에 대한 통계를 갱신하고 로그 파일에 요청 종류, URL, 무엇이 일어났는지 알려주는 항목을 추가한다.
* 가장 많이 사용되는 캐시 로그 포맷은 스퀴드 로그 포맷(Squid log format)과 넷스케이프 확장 공용 로그 포맷(Netscape extended common log format)이지만, 많은 캐시 제품이 커스텀 로그 파일을 허용한다.

### 7.7.8 단계 8: 캐시 처리 플로 차트


## 7.8 사본을 신선하게 유지

* 캐시된 사본 모두 서버 문서와 항상 일치하는 것은 아니다. 결국 문서는 시간에 따라 변경된다.
* HTTP는 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도, 캐시된 사본이 서버와 충분히 일치하도록 유지할 수 있게 해주는 단순한 메커니즘을 갖고 있다: 문서 만료, 서버 재검사

### 7.8.1 문서 만료

* HTTP는  요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
* 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 따라 다르다.
* 클라이언트는 Cache-Control과 Expires라는 특별한 헤더들을 이용해 원 서버가 각 문서에 유효기간을 붙일 수 있게 해준다.
* 이 헤더들은 콘텐츠가 얼마나 오래 신선한 상태로 보일 수 있는지 좌우한다.
* 캐시 문서 만료 전, 캐시는 필요하면 서버와의 접촉 없이 사본을 제공할 수 있다.
* 캐시된 문서가 만료되면, 캐시는 반드시 서버와 문서에 변경된 것이 있는지 검사해야 하며, 그렇다면 신선한 사본을 새 유효기간과 함께 얻어와야 한다.

### 7.8.2 유효기간과 나이

* 서버는 응답 본문과 함께하는 HTTP/1.0+ Expires나 HTTP/1.1  요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
* 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 따라 다르다.
* 클라이언트는 Cache-Control: max-age 응답 헤더를 이용해 유효기간을 명시한다.
* Expire와  요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
* 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 따라 다르다.
* 클라이언트는 Cache-Control: max-age 헤더는 기본적으로 같은 일을 하지만, 절대 시간은 컴퓨터의 시계가 올바르게 맞춰져 있을 것을 요구한다.
*  요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
* 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 따라 다르다.
* 클라이언트는 Cache-Control: max-age
  * max-age 값은 문서의 최대 나이를 정의한다. 최대 나이는 문서가 처음 생성된 이후부터, 제공하기엔 더 이상 신선하지 않다고 간주될 때까지 경과한 시간의 합법적인 최댓값(초 단위)이다.
  * ` 요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
  * 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 따라 다르다.
  * 클라이언트는 Cache-Control: max-age=484200`
* Expires: 절대 유효기간을 명시한다. 유효기간이 경과했다면 그 문서는 더 이상 신선하지 않다.
  * `Expires: Fri, 05 Jul 2020, 05:00:00 GMT`

### 7.8.3 서버 재검사

* 캐시된 문서가 만료되었다는 것은, 그 문서가 원 서버에 현재 존재하는 것과 실제로 다르다는 것을 의미하지는 않으며, 이제 검사할 시간이 되었음을 뜻한다.
* 재검사 결과 콘텐츠가 변경되었다면, 캐시는 그 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게도 보내준다.
* 재검사 결과 콘텐츠가 변경되지 않았다면, 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신한다.
* 캐시는 매 요청마다 문서의 신선도를 검증할 필요가 없다. 문서 만료시 한 번만 서버와 재검사하면 된다.
* 신선하지 않은 콘텐츠는 제공하지 않으면서도, 서버 트래픽을 절약하고 사용자 응답 시간을 개선한다.
* HTTP 프로토콜은 캐시가 다음 중 하나를 반환하는 적절한 행동을 할 것을 요구한다.
  * 충분히 신선한 캐시된 사본
  * 원 서버와 재검사되었기 때문에, 충분히 신선하다고 확신할 수 있는 캐시된 사본
  * 에러 메시지(재검사해야하는 원 서버가 다운된 경우)
  * 경고 메시지가 부착된 캐시된 사본(부정확하다면)

### 7.8.4 조건부 메서드와의 재검사

* HTTP 조건부 메서드는 재검사를 효율적으로 만들어준다. HTTP는 캐시가 서버에게 '조건부 GET'이라는 요청을 보낼 수 있게 한다.
  * 이 요청은 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다른 경우에만 객체 본문을 보내달라고 하는 것이다.
  * 이렇게 신선도 검사와 객체를 받아오는 것은 하나의 조건부 GET으로 결합된다. 조건부 GET은 GET 요청 메시지에 특별한 조건부 헤더를 추가함으로써 시작된다.
  * 웹 서버는 조건이 참인 경우에만 객체를 반환한다.
* HTTP는 다섯 가지 조건부 요청 헤더를 정의한다. 그 중 If-Modified-Since와 If-None-Match는 캐시 재검사를 할 때 유용하다.
  * `If-Modified-Since: <date>`: 문서가 주어진 날짜 이후로 수정되었다면 요청 메서드를 처리한다. 캐시된 버전으로부터 콘텐츠가 변경된 경우에만 콘텐츠를 가져오기 위해 Last-Modified 서버 응답 헤더와 함께 사용된다.
  * `If-None-Match: <tags>`: 마지막 변경된 날짜를 맞춰보는 대신, 서버는 문서에 대한 일련번호와 같이 동작하는 특별한 태그를 제공할 수 있다. If-None-Match 헤더는 캐시된 태그가 서버에 있는 문서의 태그와 다를 때만 요청을 처리한다.

### 7.8.5 If-Modified-Since: 날짜 재검사

* If-Modified-Since 재검사 요청은 흔히 'IMS' 요청으로 불린다.
* IMS 요청은 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 한다.
* 문서가 주어진 날짜 이후에 변경되었다면 If-Modified-Since 조건은 참이 되고, GET 요청은 평범하게 성공한다. 새 문서가 새로운 만료 날짜와 그 외 다른 정보들이 담긴 헤더들과 함께 캐시에 반환된다.
* 문서가 주어진 날짜 이후에 변경되지 않았다면 조건은 거짓이고, 서버는 작은 304 Not Modified 응답 메시지를 클라이언트에게 돌려준다. 효율을 위해 본문은 보내지 않는다.
  * 응답은 헤더들을 포함하지만, 원래 돌려줘야 할 것에서 갱신이 필요한 것만 보내준다. ex) Content-Type 헤더는 잘 변하지 않기 때문에 대개 보내줄 필요가 없고, 새 만료 날짜는 보통 보내주게 된다.
* If-Modified-Since 헤더는 서버 응답 헤더의 Last-Modified 헤더와 함께 동작한다.
  * 원 서버는 제공하는 문서에 최근 변경 일시를 붙인다.
  * 캐시가 캐시된 문서를 재검사 하려고 할 때 캐시된 사본이 마지막으로 수정된 날짜가 담긴 If-Modified-Since 헤더를 포함한다. `If-Modified-Since: <캐시된 마지막 수정일>`
* 몇 웹 서버는 If-Modified-Since를 실제 날짜 비교로 구현하지 않는다. 대신 IMS 날짜와 최근 변경일 간의 문자열 비교를 수행한다.
  * "정확히 이 날짜에 마지막 변경이 일어난 것이 아니라면" 의 의미로 동작한다.
  * 일련번호 같은 것을 최근 변경 일시로 사용한다면, 시간에 대한 값으로 활용할 순 없지만, 캐시 만료와 관련된 동작에는 문제가 없다.

### 7.8.6 If-None-Match: 엔터티 태그 재검사

* 최근 변경 일시 재검사가 적절히 행해지기 어려운 상황
  * 어떤 문서는 백그라운드 프로세스와 같은 것에 의해 일정 시간 간격으로 다시 쓰여지지만, 실제로 같은 데이터를 포함하고 있다. 내용에 변화가 없더라도 변경 시각은 바뀔 수 있다.
  * 어떤 문서들의 변경은 전 세계의 캐시들이 그 데이터를 다시 읽어들이기엔 사소한 것일 수 있다. ex) 철자나 주석의 변경
  * 어떤 서버들은 갖고 있는 페이지에 대한 최근 변경 일시를 정확하게 판별할 수 없다.
  * 1초보다 작은 간격으로 갱신되는 문서를 제공하는 서버들에게는, 변경일에 대한 1초의 정밀도는 충분하지 않을 수 있다.
* 퍼블리셔가 문서를 변경하고 그 문서의 엔터티 태그를 새로운 버전으로 표현할 수 있다. 엔터티 태그가 변경되었다면 캐시는 새 문서의 사본을 얻기(GET)위해 If-None-Match 조건부 헤더를 사용할 수 있다.
* 캐시가 객체에 대한 여러 개 사본을 갖고 있는 경우, 그것을 서버에 알리기 위해 하나의 If-None-Match 헤더에 여러 개의 엔터티 태그를 포함시킬 수 있다.
  ```
  If-None-Match: "v2.6"
  If-None-Match: "v2.4", "v2.5", "v2.6"
  If-None-Match: "foobar", "A34FAC0095", "Profiles in Courage"
  ```

### 7.8.7 약한 검사기와 강한 검사기

* 캐시는 캐시된 버전이 서버가 갖고 있는 것이 최신인지 확인하기 위해 엔터티 태그를 사용한다.(최근 변경 일시를 사용하는 것과 비슷) 이 경우 엔터티 태그와 최근 변경일시는 둘 다 캐시 검사기이다.
* HTTP/1.1은 콘텐츠가 조금 변경되었더라도 "그 정도만 같다"고 서버가 주장할 수 있게 해주는 "약한 검사기(weak validator)"를 지원한다.
* 강한 검사기(strong validator)는 콘텐츠가 바뀔 때마다 바뀐다. 약한 검사기는 어느 정도 콘텐츠 변경을 허용하지만, 콘텐츠의 중요한 의미가 변경되면 함께 변경된다.
* 조건부 특정범위 가져오기 같은 몇 동작은 약한 검사기로는 불가능하기 때문에 서버는 `W/`접두사로 약한 검사기를 구분한다.
  ```
  ETag: W/"v2.6"
  If-None-Match: W/"v2.6"
  ```
* 강한 엔터티 태그는 대응하는 엔터티 값이 어떻게 바뀌든 매번 반드시 같이 바뀌어야 한다. 약한 엔터티 태그는 대응하는 엔터티에 유의미한 변경이 있을 때마다 같이 변경되어야 한다.
* 원 서버는 서로 다른 두 엔터티에 대해 강한 엔터티 태그 값을 재활용해서는 안되며, 약한 엔터티 태그 값이라고 해도 서로 의미가 다른 두 엔터티에 대해서는 재활용해서는 안 된다.
* 유효기간에 상관없이 캐시 항목은 임의의 긴 기간 동안 계속될 수 있다. 캐시가 과거의 특정 시점에서 얻은 검사기를 사용해서 캐시 항목을 다시 검사하려 시도하지 않을 것이라는 예상은 틀릴 수 있다.

### 7.8.8 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가

* HTTP/1.1 클라이언트는 서버가 엔터티 태그를 반환했다면, 반드시 엔터티 태그 검사를 사용해야 한다.
* 서버가 Last-Modified 값만을 반환했다면, 클라이언트는 If-Modified-Since 검사를 사용할 수 있다.
* 엔터티 태그와 최근 변경 일시가 모두 사용 가능하다면, HTTP/1.0과 HTTP/1.1 캐시 모두 적절히 응답할 수 있도록 클라이언트는 각각을 위해 두 가지 재검사 정책을 모두 사용해야 한다.
* HTTP/1.1 원 서버는 가능하면 엔터티 태그 검사기를 보내야 하며, 강한 엔터티 태그 대신 약한 엔터티 태그를 보낼 수도 있다. Last-Modified 값을 같이 보내는 것도 선호된다.
* HTTP/1.1 캐시나 서버가 If-Modified-Since와 엔터티 태그 조건부 헤더를 모두 받았다면 요청의 모든 조건부 헤더 필드의 조건에 부합되지 않는 한 304 Not Modified 응답을 반환해서는 안 된다.

## 7.9 캐시 제어

* HTTP는 문서가 만료되기 전까지 얼마나 오래 캐시될 수 있게 할 것인지 서버가 설정할 수 있는 여러 방법을 정의한다. 우선순위대로 보면
  *  요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
  * 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 따라 다르다.
  * 클라이언트는 Cache-Control: no-store 헤더를 응답에 첨부할 수 있다.
  *  요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
  * 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 따라 다르다.
  * 클라이언트는 Cache-Control: no-cache 헤더를 응답에 첨부할 수 있다.
  *  요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
  * 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 따라 다르다.
  * 클라이언트는 Cache-Control: must-revalidate 헤더를 응답에 첨부할 수 있다.
  *  요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
  * 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 따라 다르다.
  * 클라이언트는 Cache-Control: max-age 헤더를 응답에 첨부할 수 있다.
  * Expires 날짜 헤더를 응답에 첨부할 수 있다.
  * 아무 만료 정보도 주지 않고 캐시가 스스로 체험적인(휴리스틱) 방법으로 결정하게 할 수 있다.

### 7.9.1 no-cache와 no-store 응답 헤더

* HTTP/1.1은 신선도를 관리하기 위해, 객체 캐시를 제한하거나 캐시된 객체를 제공하는 여러 방법을 제공한다. no-store와 no-cache 헤더는 캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막는다.
  ```
   요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
   * 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 따라 다르다.
   * 클라이언트는 Cache-Control: no-store
   요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
   * 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 따라 다르다.
   * 클라이언트는 Cache-Control: no-cache
  Pragma: no-cache
  ```
* 'no-store': 캐시가 그 응답의 사본을 만드는 것을 금지한다. 캐시는 보통 캐시가 아닌 프락시 서버가 그러듯 클라이언트에게 no-store 응답을 전달하고 나면 객체를 삭제할 것이다.
* 'no-cache': 이 응답은 로컬 캐시 저장소에 저장될 수 있다. 다만 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없다. (Do not serce from cache without revalidation)
* Pragma: no-cache 헤더는 HTTP/1.0+와의 하위호환성을 위해 HTTP/1.1에 포함되어 있다. HTTP1.1 애플리케이션은 Pragma: no-cache만 이해할 수 있는 HTTP/1.0 애플리케이션에 대응해야 하는 경우가 아니라면  요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
* 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 따라 다르다.
* 클라이언트는 Cache-Control: no-cache를 사용해야 한다.

### 7.9.2 Max-Age 응답 헤더

```
 요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
 * 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 따라 다르다.
 * 클라이언트는 Cache-Control: max-age=3600
 요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
 * 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 따라 다르다.
 * 클라이언트는 Cache-Control: s-maxage=3600
```
*  요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
* 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 따라 다르다.
* 클라이언트는 Cache-Control: max-age 헤더는 신선하다고 간주되었던 문서가 서버로부터 온 후 흐른 시간이고, 초로 나타낸다.
* s-maxage 헤더는 max-age 처럼 행동하지만 공유된 공용 캐시에만 적용된다.
* 서버는 최대 나이먹음(maximum aging)을 0으로 설정함으로써 캐시가 매 접근마다 문서를 캐시하거나 리프레시하지 않도록 요청할 수 있다.

### 7.9.3 Expires 응답 헤더

```
Expires: Fri, 05 Jul 2020, 05:00:00 GMT
```

* 더 이상 사용하지 않기를 권하는 헤더다. 초 단위의 시간 대신 실제 만료 날짜를 명시한다.
* 부정확함 때문에 만료를 절대시각 대신 경과된 시간으로 표현하는 것이 낫다고 판단했다.
* 신선도 수명의 근사값은 만료일과 생성일의 초 단위 시간차를 계산해 얻을 수 있다.
* 몇 서버는 문서를 항상 만료되도록 하기 위해 Expires: 0 응답 헤더를 만들어 돌려보내지만, 이는 문법 위반이며 문제를 일으킬 수 있다.
  * 이런 값을 가급적 받아들일 수 있어야 하지만 생성해서는 안 된다.

### 7.9.4 Must-Revalidate 응답 헤더

* 캐시는 성능 개선을 위해 만료된 객체를 제공하도록 설정될 수 있다.
* 캐시가 엄격하게 만료 정보를 따르길 원하면, 원 서버는 ` 요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
* 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 따라 다르다.
* 클라이언트는 Cache-Control: muse-revalidate` 와 같은 것을 붙일 수 있다.
  * 캐시가 이 객체의 신선하지 않은 사본을 원 서버와의 최초의 재검사 없이 제공해서는 안됨을 의미한다.
  * 캐시는 자유롭게 신선한 사본을 제공할 수 있다.
  * 만약 캐시가 muse-revalidate 신선도 검사를 시도했을 때 원 서버가 사용할 수 없는 상태면 캐시는 반드시 504 Gateway Timeout error를 반환해야 한다.

### 7.9.5 휴리스틱 만료

* 응답이  요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
* 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 따라 다르다.
* 클라이언트는 Cache-Control: max-age 헤더나 Expires 헤더 중 어느 것도 포함하지 않으면, 캐시는 경험적인 방법(휴리스틱)으로 최대 나이를 계산한다.
  * 계산 결과로 얻은 최대 나이 값이 24시간보다 크면 Heuristic Expiration 경고 헤더가 응답 헤더에 추가되어야 한다. 다만 이 경고를 사용자가 볼 수 있게 해주는 브라우저는 거의 없다.
  * 유명 휴리스틱 만료 알고리즘 중 하나인 LM 인자 알고리즘은, 문서가 최근 변경 일시를 포함하고 있다면 사용할 수 있다.
    * LM 인자 알고리즘은 최근 변경 일시를 문서가 얼마나 자주 바뀌는지에 대한 추정에 사용한다.
    * 캐시된 문서가 마지막으로 변경된 것이 상당히 예전이라면, 그것은 안정적 문서이며, 갑자기 바뀔 가능성은 낮아 캐시에 더 오래 보관하고 있어도 안전하다.
    * 캐시된 문서가 최근 변경되었다면, 그것은 자주 변경될 것이고 그를 서버와 재검사하기 전까지 짧은 기간 동안만 캐시해야 한다.
* 실제 LM 인자 알고리즘은 캐시가 서버와 대화했을 떄, 서버가 문서의 최근 변경 일시를 말해줬을 때 시간차를 계사한고 이 일부를 취해 캐시의 신선도 지속기간으로 사용한다.
  ```
  $마지막_수정_이후로_경과한_시간 = max(0, $서버의_Date - $서버의_Last_Modified)
  $서버_신선도_한계 = int($마지막_수정_이후로_경과한_시간 * $lm_인자)
  ```
* 일반적으로 휴리스틱 신선도 유지기간에 상한을 설정하여 지나치게 커지는 것을 막는다. 보통 1주일, 짧으면 하루로 설정한다.
* 최근 변경일조차 없다면 캐시는 판단 근거가 될 정보를 그다지 갖지 못한 것이 된다. 캐시는 일반적으로 신선도에 대한 아무 단서가 없는 문서에 대해 기본 신선도 유지 기간을 설정한다.(보통 한 시간에서 하루)
  * 더 보수적인 캐시는 보통 이 휴리스틱 문서에 0의 신선도 수명을 설정해, 캐시가 클라이언트에게 데이터를 제공할 때마다 아직 신선한지 검사하도록 강제한다.
* 휴리스틱 신선도 계산은 생각보다 흔히 하게 된다. 많은 원 서버가 아직도 Expires와 max-age 헤더를 생성하지 못하므로 캐시의 만료 기본값을 신중하게 선택해라.

### 7.9.6 클라이언트 신선도 제약

* 웹 브라우저에는 브라우저나 프락시 캐시의 신선하지 않은 콘텐츠를 강제로 갱신시켜주는 리프레시나 리로드 버튼이 있다.
* 이 버튼은 Cache-Control 요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져온다.
* 정확한 리프레시 동작은 각 브라우저나 문서, 중간 캐시 설정에 따라 다르다.
* 클라이언트는 Cache-Control 요청 헤더를 사용해 만료 제약을 엄격하거나 느슨하게 할 수 있다.
* Cache-Control 요청 지시어
  * `Cache-Control: max-stale / Cache-Control: max-stale = <s>` : 캐시는 신선하지 않은 문서라도 자유롭게 제공할 수 있다. `<s>`의 매개변수가 지정되면 클라이언트는 만료시간이 그 매개변수 값만큼 지난 문서도 받아들인다. 캐싱 규칙을 느슨하게 한다.
  * `Cache-Control: min-fresh = <s>`: 클라이언트는 지금으로부터 적어도 `<s>`초 후까지 신선한 문서만을 받아들인다. 캐싱 규칙을 엄격하게 한다.
  * `Cache-Control: max-age = <s>`: 캐시는 `<s>`초보다 오래 캐시된 문서를 반환할 수 있다. 나이가 유효기간을 넘어서게 되는 max-stale 지시어가 함께 설정되지 않는 이상, 이것은 캐싱 규칙을 더 엄격하게 만든다.
  * `Cache-Control: no-cache / Pragma: no-cache` : 이 클라이언트는 캐시된 리소스를 재검사하기 전에는 받아들이지 않는다.
  * `Cache-Control: no-store` : 캐시는 저장소에서 문서의 흔적을 최대한 빨리 삭제해야 한다. 그 문서에는 민감한 정보가 포함되어 있기 때문이다.
  * `Cache-Control: only-if-cached`: 클라이언트는 캐시에 들어있는 사본만을 원한다.

### 7.9.7 주의할 점

* 문서 만료는 완벽한 시스템이 아니다. 만약 퍼블리셔가 유효기간을 까마득한 미래로 설정해버리면 만료 전까지 그 문서의 어떤 변경도 캐시에 반영되지 않을 것이다.
* 때문에 유효기간을 길게 잡지 않는다. 심지어 아예 유효기간을 사용하지 않아서 문서가 얼마나 오랫동안 신선할 것인지 캐시가 알기 어렵게 되는 경우도 있다.


## 7.10 캐시 제어 설정

* 웹 서버는 캐시 제어와 만료 HTTP 헤더들을 설정하는 서로 다른 매커니즘을 제공한다.

### 7.10.1 아파치로 HTTP 헤더 제어하기

* 아파치 웹 서버는 HTTP 캐시 제어 헤더를 설정하는 여러 매커니즘을 제공하는데, 이 대부분이 디폴트가 아니라 사용하려면 일단 활성화시켜야 한다. 일부는 아파치 확장 모듈이 필요하다.

##### mod_headers

* 개별 헤더들을 설정할 수 있게 한다.
* 한 번 이 모듈이 로드되면 개별 HTTP 헤더를 설정할 수 있는 지시어를 이용해 아파치 설정 파일에 설정을 추가할 수 있다.
* 개별 콘텐츠 헤더를 연결시키기 위해 아파치 정규식과 필터를 조합하여 사용할 수 있다.
* ex) 어떤 디렉토리 모든 HTML 파일을 캐시되지 않게 설정
  ```
  <Files *.html>
    Header set Cache-Control no-cache
  </Files>
  ```

##### mod_expires

```
ExpiresDefault A3600
ExpiresDefault M86400
ExpiresDefault "access plus 1 week"
ExpiresDefault text/html "modification plus 2 days 6 hours 12 minutes"
```

* 적절한 만료 날짜가 담긴 Expires 헤더를 자동으로 생성하는 프로그램 로직을 제공한다.
* 문서에 마지막으로 접근한 날 혹은 수정한 날 이후의 일정 시한으로 유효기간을 설정할 수 있게 한다.
* 파일 종류별로 다른 만료 날짜를 설정할 수 있게 하며, "access plus 1 month"와 같은 편리한 기술 형식을 사용할 수 있다.

##### mod_cem_meta

* HTTP 헤더들의 파일을 특정 객체와 연결시켜준다.
* 이 모듈을 켜면 제어하고자 하는 파일에 각각 대응되는 메타파일ㄷ르을 생성하게 되므로 각 메타파일에 원하는 헤더를 추가하면 된다.

### 7.10.2 HTTP-EQUIV를 통한 HTML 캐시 제어

* HTTP 서버 응답 헤더는 문서의 만료와 캐시 제어 정보를 돌려주기 위해 사용된다.
* 웹 서버는 제공할 문서에 올바른 캐시 제어 헤더들을 부여하기 위해 설정 파일들과 상호작용한다.
* 저자가 웹 서버 설정파일과 상호작용 없이 쉽게 HTML 문서에 HTTP 헤더 정보를 부여할 수 있도록 HTML 2.0은 `<META HTTP-EQUIV>` 태그를 정의했다. 이것은 문서 최상단에 위치하여 문서와 연동되어야 하는 HTTP 헤더들을 정의한다.

```html
<html>
<head>
  <title>Document</title>
  <meta http-equiv="Cache-control" content="no-cache">
</head>
```

* 이 HTTP-EQUIV 태그는 원래 웹 서버에 사용되도록 의도된 것이다. 웹 서버는 HTML에서 `<META HTTP-EQUIV>` 태그를 파싱하여 HTTP 응답에 정해진 헤더를 삽입한다,.
  * (RFC 1866) HTTP 서버는 문서를 처리하는 과정에서 이 정보를 사용한다. 특히 서버는 이 문서에 대한 요청의 응답 헤더 필드를 포함할 것이다. 헤더 이름은 HTTP-EQUIV의 속성 값에서 얻고 헤더 값은 CONTENT 속성 값에서 얻는다.
* 이 기능을 지원하는 웹 서버나 프락시는 거의 없다. 이것은 서버 부하를 가중시키고 설정값이 정적이며 HTML을 제외한 다른 타입 파일은 지원하지 않기 때문이다.
* 그러나 몇 브라우저는 HTML 콘텐츠 내의 HTTP-EQUIV 태그를 파싱하고 실제 HTTP 헤더처럼 다룬다. 그 브라우저들은 중간의 프락시 캐시와는 다른 캐시 제어 규칙을 적용할 것이고 이는 캐시 만료에 대한 동작에 혼란을 초래한다.
* `<META HTTP-EQUIV>` 태그는 문서의 캐시 동작을 제어하는 서투른 방법이다. 문서의 캐시 제어 요청과 커뮤니케이션하는 유일하게 확실한 방법은 올바르게 설정된 서버가 보내온 HTTP 헤더를 이용하는 것이다.

## 7.11 자세한 알고리즘

* HTTP 명세는 문서의 나이와 캐시 신선도를 계산하는 알고리즘을 제공한다.

### 7.11.1 나이와 신선도 수명

* 캐시된 문서가 제공하기 충분히 신선한지 알려주려면, 캐시는 두 값만 계산하면 된다: 캐시된 사본의 나이, 신선도 수명
* `$충분히 신선한가 = ($나이 < $신선도_수명);`
* 문서의 나이는 서버가 문서를 보낸(혹은 마지막으로 재검사한) 후 그 문서가 '나이를 먹은' 시간의 총합이다.
* 캐시는 문서 응답이 업스트림 캐시에서 왔는지 서버에서 왔는지 모를 수 있기 때문에, 문서가 완전히 새롭다고 가정하지 못한다.
* Age 헤더를 통해 명시적으로, 또는 서버가 생성한 Date 헤더를 통해 계산하여서 문서 나이를 판별해야 한다.(전자 추천)
* 문서 나이가 신선도 수명을 넘었다면 클라이언트에게 제공하기엔 충분히 신선하지 않다. 신선도 수명 계산에는 문서의 유효기간과 신선도에 영향을 주는 클라이언트의 모든 요청을 고려한다.
* 어떤 클라이언트는 약간 신선하지 않은 문서도 받아들이려거나(`Cache-Control: max-stale` 헤더를 사용해서), 곧 신선하지 않게될 문서조차 받지 않으려 할 수도 있다(`Cache-Control: min-fresh`).
* 캐시는 서버 만료 정보와 클라이언트 신선도 요구사항을 조합해 최대 신선도 수명을 판별한다.

### 7.11.2 나이 계산

* 응답의 나이는 응답이 서버에 생성되었을(혹은 서버로부터 재검사되었을) 때부터 지금까지의 총 시간이다.
  * 이 나이는 응답이 인터넷상의 라우터, 게이트웨이 사이를 떠돌아다닌 시간(중개 캐시에 기록되어 있음)과 응답이 캐시에 머무른 시간을 포함한다.

```
$응답_지연_추정값 = ($응답을_받은_시각 - $요청을_보낸_시각);
$문서가_우리의_캐시에_도착했을_때의_나이 = $보정된_겉보기_나이 + $응답_지연_추정값;
$사본이_우리의_캐시에_머무른_시간 = $현재_시각 - $응답을_받은_시각;

$나이 = $문서가_우리의_캐시에_도착했을_때의_나이 + $사본이_우리의_캐시에_머무른_시간;
```

* 캐시는 응답이 캐시에 도착했을 때 Date나 Age 헤더를 분석해 얼마나 오래되었는지 알 수 있다. 캐시는 또 그 문서가 로컬 캐시에 얼마나 오래 머물렀는지 알 수 있다. 이 둘을 합하면 이 값들은 응답 전체 나이가 된다.
* HTTP는 클록 스큐(Clock skew)와 네트워크 지연을 보상하기 위해 약간의 마법을 사용하지만 기본 계산은 이렇다.
  ```
  $나이 = $문서가_우리의_캐시에_도착했을_때의_나이 + $사본이_우리의_캐시에_머무른_시간;
  ```
* 캐시는 캐시된 사본이 로컬에서 얼마나 오래 캐시되었는지는 쉽게 알 수 있으나 캐시에서 온 응답의 나이를 알아내는 것은 더 어렵다. 모든 서버가 동기화된 시계를 갖고있지 않으며 응답이 어디에서 왔는지 모르기 때문이다. 완전한 나이 계산 알고리즘은 이것을 바로잡으려 시도한다.

#### 겉보기 나이는 Date 헤더에 기반한다

* 모든 컴퓨터가 정확히 똑같은 시계를 갖고 있다면 캐시된 문서 나이는 단순히 현재 시간에서 서버가 문서를 보낸 시간을 뺀, 문서의 '겉보기 나이'가 될 것이다.
* 서버는 시간을 단순히 Date 헤더 값으로 보낸다. 가장 단순하게는 그냥 겉보기 나이를 사용하는 것이다.

```
$겉보기_나이 = $응답_받은_시간 - $Date_헤더값;
$문서가_우리의_캐시에_도착했을_떄의_나이 = $겉보기_나이;
```

* 불행히도 모든 시계가 잘 동기화되지 않아 몇 시간에서 며칠이나 다를 수 있다.
* 웹 애플리케이션, 특히 캐시 프락시는 시계 값이 극단적으로 차이나는 서버와 상호작용 하는 경우를 대비해야 한다. 이처럼 두 컴퓨터의 시계 설정 차이로 인한 문제를 클록 스큐라고 한다.
  * 클록 스큐때문에 겉보기 나이는 종종 부정확하고 음수가 되기도 한다.
* 나이가 음수가 되면 우리는 바로 그것을 0으로 만들어야 한다. 겉보기 나이가 터무니없이 커지지 않도록 간단한 검사를 추가할 수도 있으나, 그 값이 실제 맞는 값일 수도 있다. 오래 문서를 캐시하고 있는(원래 Date 헤더를 보관하면서) 부모 캐시와 대화 중이었을 수도 있기 때문이다.

```
$겉보기_나이 = max(0, $응답_받은_시간 - $Date_헤더값);
$문서가_우리의_캐시에_도착했을_떄의_나이 = $겉보기_나이;
```

* Date 헤더는 원래 원 서버 날짜를 서술한다. 프락시와 캐시는 이 날짜를 절대 변경해서는 안 된다.

#### 점층적 나이 계산

* 클록 스큐를 초래하는 음수 나이를 제거할 수 있으나, 클록 스큐로 인한 정확도 손실 전반에 대해 할 수 있는 일이 별로 없다.
  * HTTP/1.1은 동기화된 시간이 존재하지 않는 문제의 우회책으로, 문서가 프락시나 캐시를 통과할 떄마다 그 장치가 Age 헤더에 상대적인 나이를 누적해서 더하도록 한다. 이것은 서버 간의 시간 비교나 종단 간 시간 비교를 할 필요가 없다.
* Age 헤더 값은 문서가 프락시를 통과하면서 점점 늘어난다. HTTP/1.1을 이해하는 애플리케이션은 문서가 각각에 머무른 시간과 네트워크 사이를 이동한 시간만큼 Age 헤더 값을 늘려야 한다. 각 중간 애플리케이션은 자신의 내부 시계를 이용하여 쉽게 문서 체류 시간을 계산할 수 있다.
* 응답 체인에 있는 비-HTTP/1.1 장치는 Age 헤더를 인식하지 못하고 그 헤더를 고치지 않거나 삭제해 버린다. 그 때문에 Age 헤더는 상대 나이에 대한 모자란 추정값인 상태로 남아있을 것이다.
* 상대 나이 값은  Date 기반 나이와는 별개로 계산되어 두 나이 추정값 중 보수적인(가장 큰) 것이 선택된다. 다른 서버에서 넘어온 Date 값이나 나이 계산값은 실제보다 작게 계산된 값일 수 있기 때문이다.
  * 여기서 HTTP는 신선한 콘텐츠를 얻을 수 있다면 Age 오류도 용인한다.

```
$겉보기_나이 = max(0, $응답_받은_시간 - $Date_헤더값);
$보정된_겉보기_나이 = max($겉보기_나이, $Age_헤더값);
$문서가_우리의_캐시에_도착했을_떄의_나이 = $보정된_겉보기_나이;
```

#### 네트워크 지연에 대한 보상

* 트랜잭션은 느려질 수 있다. 이는 캐시를 하는 주요 동기다.
* 매우 느린 네트워크나 과부하 걸린 서버에서 문서가 긴 시간 갇혀있었다면 상대 나이 계산은 문서의 나이에 대해 상당히 모자란 추정이 될 수 있다.
* Date 헤더는 문서가 원 서버를 언제 떠났는지 나타내지만 문서가 캐시로 옮겨가는 도중 얼마나 시간을 소비했는지는 말해주지 않는다.
* 서버에서 캐시로 단방향 네트워크 지연을 측정하는 쉬운 방법은 없지만, 왕복 지연을 계산하는 것은 상대적으로 쉽다. 캐시는 언제 문서를 요청했고 언제 도착했는지 알고있다.
  * HTTP/1.1은 이를 이용해 계산한 전체 왕복 시간을 더해 네트워크 지연을 보수적으로 교정한다.
  * 캐시 > 서버 > 다시 캐시로 오는 과정에서의 지연은 서버 > 캐시로 갈 때 발생한 지연을 보수적으로 크게 추정한 것이다. 오차가 있다면 문서를 실제보다 오래 보이게 만들어 불필요한 재검사를 하게 만들 것이다.

```
$겉보기_나이 = max(0, $응답_받은_시간 - $Date_헤더값);
$보정된_겉보기_나이 = max($겉보기_나이, $Age_헤더값);
$응답_지연_추정값 = ($응답을_받은_시각 - $요청을_보낸_시각);
$문서가_우리의_캐시에_도착했을_떄의_나이 = $보정된_겉보기_나이 + $응답_지연_추정값;
```

### 7.11.3 완전한 나이 계산 알고리즘

* 문서에 대한 요청이 캐시에 도착했을 때 그 문서의 현재 나이를 계산하기 위해 문서가 캐시에 얼마나 오래 머물렀는지 알아야 한다.
* 이것은 완전한 HTTP/1.1 나이 계산 알고리즘이다.

```
$나이 = $문서가_우리의_캐시에_도착했을_때의_나이 + $사본이_우리의_캐시에_머무른_시간;
```

### 7.11.4 신선도 수명 계산

* 캐시된 문서의 나이를 알아내고 서버와 클라이언트의 제약조건에 따라 신선도 수명을 계산해야 한다.
* 어떤 문서의 신선도 수명은 문서가 특정 클라이언트에게 제공해주기에 더 이상 신선하지 않게 될 때까지 얼마나 오랜 시간 동안 가져올 수 있도록 허용되는지 말해준다.
* 서버는 문서가 얼마나 자주 변경되어 발행되는지에 대한 정보를 갖고 있을 수 있다.
* 클라이언트는 다른 가이드를 갖고, 속도가 더 빠르다면 약간 신선하지 않은 콘텐츠도 받아들이려 하거나, 반대로 가능한 가장 최신 콘텐츠를 요구할 수도 있다.
* 캐시는 사용자를 위해 봉사한다. 반드시 그들의 요구에 충실히 따라야 한다.

### 7.11.5 완전한 서버 신선도 알고리즘

* (서버 신선도 제약 계산, 클라이언트 신선도 대조 계산)
* 전체 과정은 문서의 나이와 신선도 한계라는 두 변수가 관련되어 있다.
* 나이가 신선도 한계보다 작다면 문서는 충분히 신선하다.

## 7.12 캐시와 광고

* 캐시는 성능을 개선하고 트래픽을 줄인다.
* 캐시는 사용자를 도와 더 좋은 경험을 제공하고 네트워크 사업자들이 트래픽을 줄일 수 있게 한다.

### 7.12.1 광고 회사의 딜레마

* 캐시는 광고를 사용자에게 빠르면서 더 잘 보여주어 그들이 더 많은 콘텐츠를 소비하고 더 많은 광고를 보게 한다.
* 그러나 많은 콘텐츠 제공자는 사용자가 광고를 볼 때마다 돈을 번다.
* 캐시는 원 서버가 실제 접근 횟수를 알 수 없게 숨길 수 있다. 캐싱이 완벽히 동작한다면 원 서버는 HTTP 접근을 전혀 수신하지 않게 된다. 인터넷 캐시가 그 접근을 모두 흡수한다.

### 7.12.2 퍼블리셔의 응답

* 캐시가 광고 시청 수를 가로채지 못하게 모든 종류의 '캐시 무력화' 기법을 사용한다.
* 광고를 CGI 게이트웨이를 통해 제공한다. 매 접근마다 광고 URL을 고쳐 쓴다.
* 이 캐시 무력화 기법은 단지 프락시 캐시만에 대한 것이 아니다. 오늘날 주로 모든 웹브라우저에서 켜져 있는 캐시를 주요 대상으로 한다.
* 이상적으로는 캐시가 트래픽을 흡수하도록 내버려 두어야 하며 캐시는 그들에게 적중이 얼마나 많이 일어났는지 알려주어야 한다.
  * 그 중 한 방법은 모든 접근에 대해 원 서버와 재검사하도록 캐시를 설정하는 것이다.
  * 매 접근마다 원 서버에 캐시 적중이 있었음을 알리지만 보통 본문 데이터를 전송하지 않는다.
  * 이는 트랜잭션을 느리게 만든다.

### 7.12.3 로그 마이그레이션

* 이상적으로는, 서버로 요청이 가지 않도록 한다. 캐시는 모든 적중의 로그를 유지할 수 있다. 캐시는 이 로그를 서버에게 나누어 줄 수 있다.
* 적중 로그는 크기 때문에 옮기기 어렵고, 캐시 로그는 개별 콘텐츠 제공자별로 분리될 수 있게 표준화나 조직화 되어있지 않다. 인증, 프라이버시 문제도 있다.

### 7.12.4 적중 측정과 사용량 제한

* RFC 2227, "HTTP를 위한 간단한 캐시 적중량 측정과 사용량 제한(Simple Hit-Metering and Usage-Limiting for HTTP" 에서 더 간단한 방법을 정의한다.
* 이 프로토콜을 HTTP에 때때로 특정 URL에 대한 캐시 적중 횟수를 정기적으로 서버에게 돌려주는 Meter라는 새 헤더를 하나 추가한다.
* 서버가 캐시된 문서가 적중한 횟수의 정기적인 업데이트를 캐시로부터 받는다.
* 추가로, 서버는 캐시가 서버에게 보고하기 전까지 문서를 제공할 수 있는 횟수, 소모할 수 있는 처리시간을 제어할 수 있다.(사용량 제한) 이는 캐시된 리소스가 얼마나 많이 사용될 수 있는지 서버가 제어할 수 있게 한다.

## 7.13 추가 정보