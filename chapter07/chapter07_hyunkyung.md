# 7장 캐시
- 웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치
- 웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재한다면, 그 문서는 원 서버가 아니라 캐시로부터 제공됨
- 캐시의 혜택
	- 불필요한 데이터 전송을 줄여서, 네트워크 요금을 줄여줌
	- 네트워크 병목을 줄여줌
	- 원서버에 대한 요청을 줄여줌
	- 거리로 인한 지연을 줄여줌

## 7.1 불필요한 데이터 전송
- 캐시를 이용하면, 첫번째 서버 응답은 캐시에 보관됨
- 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용될 수 있기 때문에, 원 서버가 중복해서 트래픽을 주고받는 낭비가 줄어들게 됨

## 7.2 대역폭 병목
- 많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공함
- 클라이언트들이 서버에 접근할 때의 속도는, 그 경로에 있는 가장 느린 네트워크의 속도와 같음
- 만약 클라이언트가 빠른 LAN에 있는 캐시로부터 사본을 가져온다면, 캐싱은 성능을 대폭 개선할 수 있을 것

## 7.3 갑작스런 요청 쇄도
- 갑작스런 요청 쇄도에 대처하기 위해 중요

## 7.4 거리로 인한 지연
- 모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킴

## 7.5 적중과 부적중
- 캐시 적중: 캐시에 요청이 도착했을 때, 만약 그에 대응하는 사본이 있다면 그를 이용해 요청이 처리될 수 있음
- 캐시 부적중: 만약 대응하는 사본이 없다면 그냥 원서버로 전달됨

### 7.5.1 재검사
- 원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 때때로 점검해야 함
- 이러한 '신선도 검사'를 HTTP 재검사라 부름
- 효과적인 재검사를 위해 HTTP는 서버로부터 전체 객체를 가져오지 않고도 콘텐츠가 여전히 신선한지 빠르게 검사할 수 있는 특별한 요청을 정의했음
- 캐시는 스스로 원한다면 언제든지 사본을 재검사할 수 있음
- 그러나 대부분 네트워크 대역폭의 부족으로 충분히 오래된 경우에만 재검사를 함
- 캐시의 재검사
	- 캐시는 캐시된 사본의 재검사가 필요할 때, 원 서버에 작은 재검사 요청을 보냄
	- 콘텐츠가 변경되지 않았다면, 서버는 아주 작은 304 Not Modified 응답을 보냄
	- 그 사본이 여전히 유효함을 알게 된 캐시는 즉각 사본이 신선하다고 임시로 다시 표시한 뒤 그 사본을 클라이언트에 제공함
	- 이를 재검사 적중 혹은 느린 적중이라고 부름
	- 순수 캐시 적중보다 느리고 캐시 부적중보다는 빠름
- HTTP에서 캐시된 객체를 재확인하기 위한 몇가지 도구
	- If-Modified-Since 헤더 -> 서버에 보내는 GET 요청에 이 헤더를 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미가 됨
	- GET If-Modified-Since 요청이 서버에 도착했을 때 일어날 수 있는 세가지 상황
		- 서버 콘텐츠가 변경되지 않은 경우
			- 재검사 적중: 서버는 클라이언트에게 작은 HTTP 304 Not Modified 응답을 보냄
		- 서버 콘텐츠가 변경된 경우
			- 재검사 적중: 서버는 콘텐츠 전체와 함께 평범한 HTTP 200 OK 응답을 클라이언트에게 보냄
		- 객체가 삭제된 경우
			- 404 Not Found 응답을 돌려보내며 캐시는 사본을 삭제

### 7.5.2 적중률
- 캐시가 요청을 처리하는 비율을 캐시 적중률, 혹은 문서 적중률이라고 부르기도 함
- 적중률은 0에서 1까지의 값으로 되어있지만, 흔히 퍼센트로 표현되기도 함
- 0%는 모든 요청이 캐시 부적중임을, 그리고 100%는 모든 요청이 캐시 적중임을 의미
- 적중률은 예측하기 어렵지만 40% 정도면 괜찮은 편

### 7.5.3 바이트 적중률
- 문서들이 모두 같은 크기인 것은 아니기 때문에 문서 적중률이 모든 것을 말해주지는 않음
- 바이트 단위 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현함
- 이 측정값은 트래픽이 절감된 정도를 포착해냄
- 바이트 단위 적중률 100%는 모든 바이트가 캐시에서 왔으며, 어떤 트래픽도 인터넷으로 나가지 않았음을 의미
- 문서 적중률은 얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지 보여줌
- 바이트 단위 적중률은 얼마나 많은 바이트가 인터넷으로 나가지 않았는지를 보여줌

### 7.5.4 적중과 부적중의 구별
- 200 OK로는 캐시 적중이었는지 웹 서버 접근인지 말해줄 수 없음
- 어떤 상용 프락시 캐시는 캐시에 via 헤더에 추가 정보를 붙여서 설명
- age나 date 헤더를 이용해서 응답의 생성일이 얼마나 오래되었는지를 보고 응답이 캐시된 것인지를 알아낼 수 있음

## 7.6 캐시 토폴로지
- 캐시는 한 명의 사용자에게만 할당될 수 있고 반대로 수천명의 사용자들 간에 공유될 수도 있음
- 개인 전용 캐시 -> 한명
- 공용 캐시 -> 공용 캐시

### 7.6.1 개인 전용 캐시
- 많은 에너지나 저장 공간을 필요로 하지 않으므로, 작고 저렴할 수 있음
- 웹브라우저는 개인 전용 캐시를 내장하고 있음
- 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시해놓고 사용자가 캐시 사이즈와 설정을 수정할 수 있도록 허용

### 7.6.2 공용 프락시 캐시
- 공용 캐시는 캐시 프락시 서버 혹은 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버
- 프락시 캐시는 로컬 캐시에서 문서를 제공하거나, 혹은 사용자의 입장에서 서버에 접근함
- 공용 캐시에는 여러 사용자가 접근하기 때문에, 불필요한 트래픽을 줄일 수 있는 더 많은 기회가 있음

### 7.6.3 프락시 캐시 계충들
- 작은 캐시에서 캐시 부적중이 발생했을 때 더 큰 부모 캐시가 그 '걸러 남겨진' 트래픽을 처리하도록 하는 계층을 만드는 방식이 합리적인 경우가 많음
- 클라이언트 주변에는 작고 저렴한 캐시를 사용하고 계층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하기 위해 더 크고 강력한 캐시를 사용하자는 것

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링
- 몇몇 네트워크 아키텍처는 단순한 캐시 계층 대신 복잡한 캐시망을 만듦
- 캐시망의 프락시 캐시는 복잡한 방법으로 서로 대화하여, 어떤 부모 캐시와 대화할 것인지, 아니면 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할 것인지에 대한 캐시 커뮤니케이션 결정을 동적으로 내림
- 콘텐츠 라우팅을 위해 설계된 캐시들
	- URL에 근거하여 부모 캐시와 원 서버중 하나를 동적으로 선택
	- URL에 근거하여 특정 부모 캐시를 동적으로 선택
	- 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾아봄
	- 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 그들의 캐시를 통한 인터넷 트랜짓은 허용하지 않음

## 7.7 캐시 처리 단계
### 7.7.1 1: 요청 받기
- 캐시는 네트워크 커넥션에서의 활동을 감지하고, 들어오는 데이터를 읽어들임
- 고성능 캐시는 여러개의 들어오는 커넥션들로부터 데이터를 동시에 읽어들이고 메시지 전체가 도착하기 전에 트랜잭션 처리를 시작

### 7.7.2 단계 2: 파싱
- 캐시는 요청 메시지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료 구조에 담음
- 이는 캐싱 소프트웨어가 헤더 필드를 처리하고 조작하기 쉽게 만들어줌

### 7.7.3 단계 3: 검색
- 캐시는 URL을 알아내고 그에 해당하는 로컬 사본이 있는지 검사
- 로컬 복사본은 메모리에 저장되어 있을수도 있고 디스크나 근처의 다른 컴퓨터에 있을수도
- 캐시된 객체는 서버 응답 본문과 원서버 응답 헤더를 포함하고 있으므로, 캐시 적중 동안 올바른 서버 헤더가 반환될 수 있음
- 캐시된 객체는 또한 객체가 얼마나 오랫동안 캐시에 머무르고 있었는지를 알려주는 기록이나 얼마나 자주 사용되었는지 등에 대한 몇몇 메타데이터를 포함함

### 7.7.4 단계 4: 신선도 검사
- 너무 오래된 객체는 '신선하지 않은 것'

### 7.7.5 단계 5: 응답 생성
- 원 서버에서 온 것처럼 보이게 함. 캐시된 서버 응답 헤더를 토대로 응답 헤더 생성

### 7.7.6 단계 6: 전송
- 일단 응답 헤더가 준비되면, 캐시는 응답을 클라이언트에게 돌려줌
- 모든 프락시 서버들과 마찬가지로, 프락시 캐시는 클라이언트와의 커넥션을 유지할 필요가 있음
- 고성능 캐시는 종종 로컬 저장장치와 네트워크 I/O 버퍼 사이에서 문서의 콘텐츠 복사를 피함으로써 데이터를 효과적으로 전송하기 위해 노력함

### 7.7.7 단계 7: 로깅
- 대부분의 캐시는 로그 파일과 캐시 사용에 대한 통계를 유지함
- 각 캐시 트랜잭션이 완료된 후, 캐시는 통계 캐시 적중과 부적중 횟수에 대한 통계를 갱신하고 로그 파일에 요청 종류, URL 그리고 무엇이 일어났는지를 알려주는 항목을 추가함
- 가장 많이 쓰이는 캐시 로그 포맷은 스퀴드 로그 포맷과 넷스케이프 확장 공용 로그 포맷이지만 많은 캐시 제품이 커스텀 로그 파일을 허용함

## 7.8 사본을 신선하게 유지하기
### 7.8.1 문서 만료
- HTTP는 Cache-control과 Expires라는 특별한 헤더들을 이용해서 원 서버가 각 문서에 유효기간을 붙일 수 있게 해줌
### 7.8.3 서버 재검사
- 캐시된 문서가 만료되었다는 것은, 그 문서가 원 서버에 현재 존재하는 것과 실제로 다르다는 것을 의미하지는 않으며, 다만 이제 검사할 시간이 되었음을 뜻함
- 재검사 결과 콘텐츠가 변경되었다면 캐시는 그 문서의 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게도 보내준다
- 재검사 결과 콘텐츠가 변경되지 않았다면, 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신함

### 7.8.4 조건부 메서드와의 재검사
### 7.8.5 If-Modified-Since: 날짜 재검사
- 흔히 IMS 요청으로 불림
- 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 함
	- 만약 문서가 주어진 날짜 이후에 변경되었다면, If-Modified-Since 조건은 참이고, 따라서 GET 요청은 평범하게 성공함
	- 만약 문서가 주어진 날짜 이후에 변경되지 않았다면 조건은 거짓이고, 서버는 작은 304 Not Modified 응답 메시지를 클라이언트에게 돌려줌

### 7.8.6 If-None-Match: 엔터티 태그 재검사
- 최근 변경 일시 재검사가 적절히 행해지기 어려운 상황
	- 어떤 문서는 일정 시간 간격으로 다시 쓰여지지만 실제로는 같은 데이터를 포함하고 있음. 내용에는 아무런 변화가 없더라도 변경시각은 바뀔 수 있음
	- 어떤 문서들의 변경은 전 세계의 캐시들이 그 데이터를 다시 읽어들이기엔 사소한 것일 수도 있음
	- 어떤 서버들은 그들이 갖고 있는 페이지에 대한 최근 변경 일시를 정확하게 판별할 수 없음
	- 1초보다 작은 간격으로 갱신되는 문서를 제공하는 서버들에게는, 변경일에 대한 1초의 정밀도는 충분하지 않을 수 있음

- 엔터티 태그의 변경에 따라 검사가 이루어짐

### 7.8.7 약한 검사기와 강한 검사기
- 캐시는 캐시된 버전이 서버가 갖고 있는 것에 대해 최신인지 확인하기 위해 엔터티 태그를 사용함
- 이 경우 엔터티 태그와 최근 변경일시는 둘 다 캐시 검사기
- 살짝 고칠 수 있도록 허용하고 싶을 때 -> 약한 검사기
- 콘텐츠가 바뀔 때마다 바뀜 -> 강한 검사기

### 7.8.8 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가
- 서버가 뭘 반환했는지에 따라
- 둘다 사용가능하다면 두가지의 재검사 정책을 모두 사용

## 7.9 캐시 제어
### 7.9.1 no-cache와 no-store 응답 헤더
- HTTP/1.1은 신선도를 관리하기 위해, 객체를 캐시하는 것을 제한하거나 캐시된 객체를 제공하는 여러 가지 방법을 제공
- no-store가 표시된 응답은 캐시가 그 응답의 사본을 만드는 것을 금지함
- 캐시는 보통 캐시가 아닌 프락시 서버가 그러는 것처럼, 클라이언트에게 no-store 응답을 전달하고 나면 객체를 삭제할 것임
- no-cache로 표시된 응답은 사실 로컬 캐시 저장소에 저장될 수 있음
- 다만 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없을 뿐
### 7.9.2 Max-Age 응답 헤더
- 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간이고 초로 나타냄
- 서버는 최대 나이먹음을 0으로 설정함으로써, 캐시가 매 접근마다 문서를 캐시하거나 리프레시하지 않도록 요청할 수 있음
### 7.9.3 Expires 응답 헤더
- 더이상 사용하지 않기를 권하는 헤더로 초 단위의 시간 대신 실제 만료날짜를 명시
### Must-Revalidate 응답 헤더
- 캐시는 신선하지 않은 객체를 제공하도록 설정될 수 있음
- 만약 만료 정보를 엄격하게 따르길 원한다면 붙일 수 있음

### 7.9.5 휴리스틱 만료
- 만약 응답이 어느 헤더도 포함하고 있지 않다면 캐시는 경험적인 방법으로(heuristic) 최대 나이를 계산 할것

### 7.9.6 클라이언트 신선도 제약
- 웹 브라우저는 브라우저나 프락시 캐시의 신선하지 않은 콘텐츠를 강제로 갱신시켜 주는 리프레시나 리로드 버튼을 갖고 있음
- 이 리프레시 버튼은 cache-control 요청 헤더가 추가된 GET 요청을 발생시켜서, 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져옴
