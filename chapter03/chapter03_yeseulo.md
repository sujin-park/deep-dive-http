# 03. HTTP 메시지

이번 장에서 배울 내용은
* 메시지가 어떻게 흘러가는가
* HTTP 메시지의 세 부분: 시작줄, 헤더, 개체 본문
* 요청과 응답 메시지의 차이
* 요청 메시지가 지원하는 여러 기능(메서드)들
* 응답 메시지가 반환하는 여러 상태 코드들
* 여러 HTTP 헤더들은 무슨 일을 하는가


## 3.1 메시지의 흐름

* HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록들이다.
* 메시지는 클라이언트, 서버, 프락시 사이를 흐른다.
* `인바운드`, `아웃바운드`, `업스트림`, `다운스트림`은 메시지 방향을 의미하는 용어다.

### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다

* HTTP는 트랜잭션 방향 표현을 위해 인바운드, 아웃바운드라는 용어를 사용한다.
* 메시지가 원 서버로 향하는 것은 `인바운드`로 이동하는 것이고, 모든 처리가 끝난 후 메시지가 사용자 에이전트로 돌아오는 것은 `아웃바운드`로 이동하는 것이다.

### 3.1.2 다운스트림으로 흐르는 메시지

* HTTP 메시지는 강물과 같다. 요청 메시지냐 응답 메시지냐에 관계 없이 다운스트림으로 흐른다.
* 메시지의 발송자는 수신자의 업스트림이다.

## 3.2 메시지의 각 부분

* HTTP 메시지는 단순한, 데이터의 구조화된 블록이다.
* 각 메시지는 클라이언트의 요청이나 서버로부터의 응답 중 하나를 포함한다.
* 메시지는 시작줄, 헤더 블록, 본문 세 부분으로 이루어진다.
  * 시작줄은 이것이 어떤 메시지인지 서술한다.
  * 헤더 블록은 속성을 담고 있다.
  * 본문은 데이터를 담고 있으며, 아예 없을 수도 있다.
* 시작줄과 헤더는 줄 단위로 분리된 아스키 문자열이다. 각 줄은 캐리지 리턴(ASCII 13)과 개행 문자(ASCII 10)으로 구성된 두 글자의 줄바꿈 문자열(`CRLF`)로 끝난다.
* 엔터티 본문이나 메시지 본문(혹은 그냥 본문)은 단순히 선택적 데이터의 덩어리이다.
* 본문은 텍스트나 이진 데이터를 포함할 수도 있고, 그냥 비어있을 수도 있다.

### 3.2.1 메시지 문법

* 요청 메시지의 형식
  ```
  <메서드> <요청URL> <버전>
  <헤더>

  <엔터티 본문>
  ```
* 응답 메시지의 형식
  ```
  <버전> <상태코드> <사유 구절>
  <헤더>

  <엔터티 본문>
  ```
* 메서드
  * 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작이다.
  * `GET`, `HEAD`, `POST` 처럼 한 단어로 되어 있다.
* 요청 URL
  * 요청 대상 리소스를 지칭하는 완전한 URL 또는 URL의 경로 구성이다.
  * 경로 구성 요소가 절대경로라면 서버는 URL에서 생략된 호스트/포트가 자신을 가리키는 것으로 간주한다.
* 버전
  * 버전의 형식은 `HTTP/<메이저>.<마이너>`와 같이 표기하고 메이저, 마이너는 모두 정수이다.
* 상태 코드
  * 요청 중 무엇이 일어났는지 설명하는 세 자리 숫자다.
  * 각 코드 첫 번째 자릿수는 성공, 에러 등 상태의 일반적 분류를 나타낸다.
* 사유 구절 reason-phrase
  * 숫자로 된 상태 코드를 사람이 이해할 수 있게 설명하는 짧은 문구로, 상태 코드 이후부터 줄바꿈 문자열까지가 사유 구절이다.
  * 사유 구절은 오로지 사람이 읽는 목적으로만 존재한다.
* 헤더들
  * 이름, 콜론(`:`), 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들이다.
  * 헤더 목록은 빈 줄(CRLF)로 끝나 헤더 목록의 끝과 엔터티 본문의 시작을 표시한다.
  * HTTP/1.1과 같은 몇몇 버전의 HTTP는 요청이나 응답에 특정 헤더가 포함되어야만 유효한 것으로 간주한다.
* 엔터티 본문
  * 엔터티 본문은 임의의 데이터 블록을 포함한다.
  * 모든 메시지가 엔터티 본문을 갖는 것은 아니라서, 때때로 메시지는 그냥 CRLF로 끝난다.
  * 헤더나 엔터티 본문이 없어도 HTTP 헤더의 집합은 항상 빈 줄(그냥 CRLF)로 끝나야 한다.

### 3.2.2 시작줄

* 모든 HTTP 메시지는 시작줄로 시작한다. 요청 메시지의 시작줄은 무엇을 해야하는지 말해주고, 응답 메시지의 시작줄은 무슨 일이 일어났는지 말해준다.

#### 요청줄

* `GET /projects/list.txt HTTP/1.1`
* 요청 메시지의 시작줄(요청줄)에는 서버에서 어떤 동작이 일어나야 하는지 설명하는 메서드와 그 동작에 대한 대상을 지칭하는 요청 URL이 들어있다.
* 클라이언트가 어떤 HTTP 버전으로 말하고 있는지 서버에게 알려주는 HTTP 버전도 포함해야 한다.
* 모든 필드는 공백으로 구분된다.
* HTTP/1.0 이전에는 요청줄에 HTTP 버전이 들어있을 필요가 없었다.

#### 응답줄

* `HTTP/1.0 200 OK`
* 응답줄은 수행 결과의 상태 정보와 결과 데이터를 클라이언트에게 돌려준다.
* 응답 메시지에서 쓰인 HTTP의 버전, 숫자 상태 코드, 수행 상태를 설명하는 텍스트로 된 사유 구절이 들어있다.
* 모든 필드는 공백으로 구분된다.
* HTTP/1.0 이전에는 응답에 응답줄이 들어있을 필요가 없었다.

#### 메서드

* 요청의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야하는지 알려준다.
* HTTP 명세는 공통 요청 메서드 집합을 정의한다.
  * `GET`: 서버에서 어떤 문서를 가져온다 / 메시지 본문 없음
  * `HEAD`: 서버에서 어떤 문서에 대해 헤더만 가져온다 / 메시지 본문 없음
  * `POST`: 서버가 처리해야 할 데이터를 보낸다 / 메시지 본문 있음
  * `PUT`: 서버에 요청 메시지의 본문을 저장한다 / 메시지 본문 있음
  * `TRACE`: 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다 / 메시지 본문 없음
  * `OPTIONS`: 서버가 어떤 메서드를 수행할 수 있는지 확인한다 / 메시지 본문 없음
  * `DELETE`: 서버에서 문서를 제거한다 / 메시지 본문 없음
* 모든 서버가 위의 메서드를 모두 구현한 것은 아니며, HTTP는 쉽게 확장할 수 있게 설계되어 특정 서버만의 메서드를 추가로 구현했을 수 있다. 이 추가 메서드는 HTTP 명세를 확장하는 것이라서 확장 메서드라고 한다.

#### 상태 코드

* 클라이언트에게 무엇이 일어났는지 말해주는 것으로, 응답과 시작줄에 위치한다.
* 상태 코드는 세 자리 숫자로 된 코드값을 기준으로 묶인다.
* 현재 버전의 HTTP는 각 상태 분류에 대해 적은 수의 코드만 정의했다.
  * 프로토콜 확장으로 인식할 수 없는 상태 코드를 받게 되면, 그 상태 코드가 포함되는 범주의 일반적인 의미로 가정하고 다뤄야 한다.

  | 전체 범위 | 정의된 범위 | 정보 |
  |:---|:---|:---|
  | 100-199 | 100-101 | 정보 |
  | 200-299 | 200-206 | 성공 |
  | 300-399 | 300-305 | 리다이렉션 |
  | 400-499 | 400-415 | 클라이언트 에러 |
  | 500-599 | 500-505 | 서버 에러 |

#### 사유 구절

* 사유 구절은 응답 시작줄의 마지막 구성요소로, 상태 코드에 대한 텍스트 설명을 제공한다.
* 사유 구절은 상태 코드와 일대일로 대응되며, 상태코드의 사람이 이해하기 쉬운 버전이다.
* HTTP 명세는 사유 구절에 대한 엄격한 규칙이 없다.

#### 버전 번호

* `HTTP/x.y` 형식으로, 요청과 응답 메시지 모두에 기술된다.
* HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주는 수단으로, 대화 상대의 능력과 메시지 형식의 단서를 제공한다.
* 버전 번호는 해당 애플리케이션이 지원하는 가장 높은 HTTP 버전을 가리킨다.
* 응답 프로토콜의 버전이 `HTTP/1.1`이라는 것은 응답을 보낸 애플리케이션이 `HTTP/1.1`까지 이해할 수 있음을 의미한다.
* 버전 번호의 각 숫자는 분리된 숫자로 다루며, HTTP 버전을 비교할 때 각 숫자를 따로따로 비교해야 한다. HTTP/2.22는 HTTP/2.3보다 크다.

### 3.2.3 헤더

* 시작줄 다음에는 0개, 1개 혹은 여러 개의 HTTP 헤더가 온다.
* HTTP 헤더 필드는 메시지에 추가 정보를 더한다. 기본적으로 이름/값 쌍의 목록이다.

#### 헤더 분류

* HTTP 헤더 명세는 여러 헤더 필드를 정의하며, 애플리케이션은 자유롭게 자신만의 헤더를 만들 수 있다.
  * 일반 헤더: 요청, 등답 양쪽에 모두 나타날 수 있디
  * 요청 헤더: 요청에 대한 부가 정보를 제공한다.
  * 응답 헤더: 응답에 대한 부가 정보르르 제공한다.
  * Entity 헤더: 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술한다.
  * 확장 헤더: 명세에 정의되지 않은 새로운 헤더다.
* HTTP 헤더는 간단한 문법으로 이름, 쉼표, 공백(없어도 됨), 필드 값, CRLF가 순서대로 온다.

  | 헤더의 예 | 설명 |
  |:---|:---|
  | Date: Mon, 16 Nov 2020 10:10:10 GMT | 서버가 응답을 만들어 낸 시각 |
  | Content-length: 15040 | 15,040 바이트의 데이터를 포함한 엔터티 본문 |
  | Content-type: image/gif | 엔터티 본문은 GIF 이미지다 |
  | Accept: image/gif, image/jpeg, text/html | 클라이언트는 GIF, JPEG 이미지, HTML을 받아들일 수 있다 |

* 긴 헤더는 여러 줄로 쪼개서 더 읽기 좋게 할 수 있다. 추가 줄 앞에 최소 하나의 스페이스 또는 탭 문자가 와야 한다.
  ```
  HTTP/1.0 200 OK
  Content-Type: image/gif
  Content-length: 8572
  Server: Test Server
    Version 1.0
  ```

### 3.2.4 엔터티 본문

* 엔터티 본문은 HTTP가 수송하도록 설계된 메시지의 화물로, 선택적이다.
* HTTP 메시지는 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 디지털 데이터를 실어 나를 수 있다.

### 3.2.5 버전 0.9 메시지

* HTTP 프로토콜 초기 버전인 0.9는 오늘날 HTTP의 요청/응답 메시지의 시초이지만 단순한 프로토콜로 되어 있다.
* 요청과 응답으로 구성되어 있지만 요청은 메서드와 요청 URL만 갖고 있고, 응답은 오직 엔터티로만 되어 있다.
* 버전 정보, 상태 코드, 사유 구절도 없었고 헤더도 포함되어 있지 않다.
* 이런 단순함으로 다양한 상황에 대응할 수 없었다.

## 3.3 메서드

* 모든 서버가 모든 메서드를 구현하지 않는다. HTTP/1.1과 호환하려면 서버는 자신의 리소스에 대해 GET과 HEAD 메서드만들 구현해도 충분하다.
* 메서드 사용의 제한은 보통 서버 설정에 의해 정해지며, 사이트마다 서버마다 다를 수 있다.

### 3.3.1 안전한 메서드(Safe Method)

* HTTP는 안전한 메서드 집합을 정의한다. GET과 HEAD 메서드는 안전하다고 볼 수 있는데, 이 메서드를 사용할 때 HTTP 요청의 결과로 서버에 어떤 작용도 없어서 안전한 메서드라고 할 수 있다.
* 안전한 메서드가 서버에 작용을 유발하지 않는다는 보장은 없으며 이는 웹 개발자에게 달렸다.
* 안전한 메서드의 목적은, 안전하지 않은 메서드가 사용될 때 사용자에게 그 사실을 알려주는 HTTP 애플리케이션을 만들 수 있도록 하는 데에 있다.

### 3.3.2 GET

* 가장 흔히 쓰는 메서드다. 서버에게 리소스를 달라고 요청할 때 사용한다.
* HTTP/1.1은 서버가 이 메서드를 구분할 것을 요구한다.

### 3.3.3 HEAD

* HEAD 메서드는 GET처럼 행동하지만, 서버는 응답으로 헤더만 돌려주고 엔터티 본문은 반환되지 않는다.
* 리소스를 가져오지 않고도 그에 대한 무언가(타입 등)을 알아낼 수 있다.
* 응답 상태 코드를 통해 개채 존재를 확인할 수 있다.
* 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.
* 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야 한다.
* HTTP/1.1 준수를 위해 HEAD 메서드는 반드시 구현되어 있어야 한다.

### 3.3.4 PUT

* 서버에 문서를 쓴다. 예) PUT을 이용해 사용자가 웹페이지를 만들고 웹 서버에 직접 게시할 수 있게 함
* 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체한다.
* 콘텐츠를 변경할 수 있게 해주므로, 많은 웹 서버가 PUT 수행 전에 사용자 비밀번호를 입력하여 로그인을 하도록 요구할 것이다.

### 3.3.5 POST

* 서버에 입력 데이터를 전송하기 위해 설계되었다. 실제 HTML 폼을 지원하기 위해 흔히 사용한다.

### 3.3.6 TRACE

* 클라이언트가 어떤 요청을 할 떄, 그 요청은 방화벽, 프락시, 게이트웨이 등 애플리케이션을 통과할 수 있으며, 이들은 원래 HTTP 요청을 수정할 수 있다.
* TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.
* TRACE 요청은 목적지 서버에서 루프백 loopback 진단을 시작한다. 요청 전송 마지막 단계의 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 돌려준다.
* 클라이언트는 자신과 목적지 서버 사이의 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가며 자신이 보낸 메시지가 망가졌거나 수정되었는지, 그렇다면 어떻게 변경되었는지 확인할 수 있어서, 주로 진단을 위해 사용된다.
  * 진단이 아닌 경우, 중간 애플리케이션이 GET, HEAD, POST등 각 다른 메서드를 사용한 다른 종류의 요청을 일관되게 다룬다고 가정하는 문제가 있다.
  * 프락시는 POST 요청을 바로 서버로 통과시키는 반면, GET 요청은 웹 캐시와 같은 다른 HTTP 애플리케이션으로 전송한다.
* TRACE는 메서드를 구별하는 메커니즘을 제공하지 않는다. 중간 애플리케이션이 TRACE 요청을 어떻게 처리할지 결정한다.
* TRACE 요청은 엔터티 본문을 보낼 수 없다. TRACE 응답의 엔터티 본문에는 서버에서 받은 요청이 그대로 담겨있다.

### 3.3.7 OPTIONS

* 웹 서버에게 여러 가지 종류의 지원 범위, 즉 특정 리소스에 대해 어떤 메서드가 지원되는지를 OPTIONS 메서드로 물어볼 수 있다.
* 여러 리소스에 대해 직접 접근하지 않고도 어떻게 접근하는 것이 최선인지 확인할 수 있다.

### 3.3.8 DELETE

* 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다.
* HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 떄문에, 클라이언트는 삭제가 수행되는 것을 보장하지 못한다.

### 3.3.9 확장 메서드

* 필요에 따라 확장 메서드를 추가할 수 있으며, 새로 기능을 추가해도 과거에 구현한 소프트웨어의 오작동을 유발하지 않는다.
* 확장 메서드는 HTTP/1.1 명세에 정의되지 않은 메서드다.
* 확장 메서드를 다룰 때는 "엄격하게 보내고 관대하게 받아들여라"라는 오랜 규칙을 따르는 것이 가장 좋다.

## 3.4 상태 코드

* HTTP 상태 코드는 크게 다섯 가지로 나뉘며, 상태 코드는 클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공한다.

### 3.4.1 100-199: 정보성 상태 코드

* 정보성 상태 코드는 HTTP/1.1에서 도입되었다. 비교적 새로운 것이며 복잡함을 감수할 만한 가치가 있는지 논란이 되고 있다.

| 상태 코드 | 사유 구절 | 의미 |
|:---|:---|:---|
| 100 | Continue | 요청의 시작 부분 일부가 받아들여졌으ㅇ며, 클라이언트는 나머지를 계속 이어서 보내야 함을 의미. |
| 101 | Switching Protocols | 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꿨음을 의미. |

* `100 Continue`: 클라이언트가 서버에 엔터티 본문을 전송하기 전 그 엔터티 본문을 서버가 받아들일 것인지 확인하려고 할 때, 그 확인 작업을 최적화하기 위한 의도로 도입되었다.
* 클라이언트와 `100 Continue`
  * 클라이언트는 엔터티를 서버에 보낼 떄, 값을 `100-continue`로 하는 Expect 요청 헤더를 보낼 필요가 있다. 만약 엔터티를 보내지 않을거면 헤더를 보내지 않아야 서버에 혼란이 없다.
  * 클라이언트는 100-continue를 서버가 다루거나 사용할 수 없는 큰 엔터티를 서버에게 보내지 않으려는 목적으로만 사용해야한다.
  * 서버가 `100 Continue` 응답을 보내주기를 기다리기만 해서는 안되고, 약간의 타임아웃 후 클라이언트는 그냥 엔터티를 보내야한다.
  * 클라이언트 개발자는 예상치 못한 `100 Continue` 응답에도 대비해야 한다.
* 서버와 `100 Continue`
  * 서버가 100-continue값이 담긴 Expect 헤더 요청을 받는다면, `100 Continue` 응답 혹은 에러 코드로 답해야 한다.
  * 서버는 절대로 100-continue 응답을 받을 것을 의도하지 않은 클라이언트에게 `100 Continue` 상태 코드를 보내서는 안된다.
* 프락시와 `100 Continue`
  * 클라이언트로부터 100-continue 응답을 의도한 요청을 받은 프락시는 해야할 일이 있다.
  * 다음 홉 next-hop 서버가 HTTP/1.1을 다르거나 또는 어떤 버전을 따르는지 모른다면, Expect 헤더를 포함시켜 요청을 다음으로 전달해야 한다.
  * 만약 다음 홉의 서버가 1.1보다 이전 버전을 따른다는 것을 알고 있다면 프락시는 `417 Expectation Failed` 에러로 응답해야 한다.
  * 프락시가 HTTP/1.0이나 이전 버전을 따르는 클라이언트를 대신해 Expect 헤더와 100-continue 값을 요청에 포함시키기로 했다면, 프락시는 `100 Continue` 응답을 클라이언트에게 전달해서는 안 된다. 클라이언트는 그것을 어떻게 해야하는지 모르기 때문이다.

### 3.4.2 200-299: 성공 상태 코드

| 상태 코드 | 사유 구절 | 의미 |
|:---|:---|:---|
| 200 | OK | 요청은 정상이고, 엔터티 본문은 요청된 리소스를 포함. |
| 201 | Created | 서버 개체를 생성하라는 요청(예: PUT)을 위한 것. 응답은, 생성된 리소스에 대한 최대한 구체적인 참조가 담긴 Location 헤더와 함께, 그 리소스를 참조할 수 있는 여러 URL을 엔터티 본문에 포함해야 함. |
| 202 | Accepted | 요청은 받아들여졌으나 서버는 아직 그에 대한 어떤 동작도 수행하지 않음. 서버는 엔터티 본문에 요청에 대한 상태와 가급적이면 요청의 처리가 언제 완료 될 것인지에 대한 추정(어디서 정보를 얻을 수 있는지)도 포함해야 함.|
| 203 | Non-Authoritative Information | 엔터티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔음. 중개자가 리소스 사본을 갖고 있었으나 리소스의 메타 정보(헤더)를 검증하지 못/안 한 경우 이런 일이 발생할 수 있음. 이 응답 코드는 필수적으로 사용되어야 하는 것은 아니고, 엔터티 헤더가 원래 서버에서 온 것이었다면 응답이 200 상태였을 애플리케이션을 위한 선택사항. |
| 204 | No Content | 응답 메시지는 헤더와 상태줄을 포함하지만 엔터티 본문은 포함하지 않음. 주로 웹 브라우저를 새 문서로 이동시키지 않고 갱신하고자 할 때(폼을 리프레시) 사용함. |
| 205 | Reset Content | 브라우저에게 현재 페이지에 있는 HTML 폼에 채워진 모든 값을 비우라고 말함. |
| 206 | Partial Content | 부분 혹은 범위 요청이 성공했다. 206 응답은 Content-Rage와 Date 헤더를 반드시 포함해야 하며, Etag와 Content-Location 중 하나의 헤더도 반드시 포함해야함. |

### 3.4.3 300-399: 리다이렉션 상태 코드

* 클라이언트가 관심있는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공한다.
* 리소스가 옮겨졌다면, 클라이언트에게 리소스가 옮겨졌고 어디서 찾을 수 있는지 알려주기 위해 상태 코드와 (선택적으로) Location 헤더를 보낼 수 있다.
* 리다이랙션 상태 코드 중 몇몇은 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인할 때 사용된다.
* 일반적으로 HEAD가 아닌 요청에 대해 리다이렉션 상태 코드를 포함한 응답을 할 때, 리다이렉트될 URL의 링크와 설명을 포함하는 것은 좋은 습관이다.

| 상태 코드 | 사유 구절 | 의미 |
|:---|:---|:---|
| 300 | Multiple Choices | 클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우, 그 리소스의 목록과 함께 반환 |
| 301 | Moved Permanently | 요청한 URL이 옮겨졌을 때 사용. 응답은 Location 헤더에 현재 리소스가 존재하고 있는 URL을 포함해야 함. |
| 302 | Found | 301과 같다. 그러나 클라이언트는 Location 헤더로 주어진 URL을 임시로 리소스를 가리키기 위한 목적으로 사용해야 함. |
| 303 | See Other | 클라이언트에게 리소스를 다른 URL에서 가져와야 한다고 말해주고자 할 때. 주 목적은 POST 요청에 대한 응답으로 클라이언트에게 리소스의 위치를 알려줌. |
| 304 | Not Modified | 클라이언트는 헤더를 이용해 조건부 요청을 만들 수 있음. 클라이언트가 GET과 같은 조건부 요청을 보냈고 그 요청한 리소스가 수정된 일이 없다면, 리소스가 수정되지 않았음을 의미. 이 상태 코드를 동반한 응답은 엔터티 본문을 가져서는 안 됨. |
| 305 | Use Proxy | 리소스가 반드시 프락시를 통해서 접근되어야 함을 나타내기 위해 사용. 프락시 위치는 Location 헤더를 통해 주어짐. |
| 306 | (사용되지 않음) | 현재 사용되지 않음. |
| 307 | Temporary Redirect | 301과 비슷. Location 헤더로 주어진 URL을 임시로 리소스를 가리키기 위한 목적으로 사용해야 함. |

* 302, 303, 307 상태 코드 사이 중복되는 부분이 있는데, 이 코드가 어떻게 사용되는가에 대해 차이가 있다. 이는 HTTP/1.0과 1.1 애플리케이션이 상태 코드를 다루는 방식의 차이점에 기인한다.
  * 302: HTTP/1.0 클라이언트가 POST 요청을 보내고 302 리다이렉트 응답을 받으면, 클라이언트는 Location 헤더에 있는 리다이렉트 URL을 GET 요청으로 따라간다. HTTP/1.0 서버가 HTTP/1.0 클라이언트에게 POST 요청을 받은 뒤 302 상태 코드를 보내는 상황이면, 서버는 클라이언트가 리다이렉션 URL에 대한 GET 요청으로 리다이렉트를 따라가길 기대한다.
  * 303: HTTP/1.1 명세는 이런 리다이렉션을 위해 303 상태 코드를 사용한다. 서버는 뒤이어 GET 요청이 오도록 POST 요청을 리다이렉션하기 위해 303 상태 코드를 보낼 수 있다.
  * 307: 혼란을 막기 위해 HTTP/1.1 명세는 HTTP/1.1 클라이언트의 일시적인 리다이렉트를 위해 302 대신 307 상태 코드를 사용하라고 한다. 서버는 302 상태 코드를 HTTP/1.0 클라이언트에게 사용하기 위해 남겨둘 수 있다.
* 서버는 리다이렉트 응답에 들어갈 가장 적절한 리다이랙트 상태 코드를 선택하기 위해 클라이언트의 HTTP 버전을 검사할 필요가 있다.

### 3.4.4 400-499: 클라이언트 에러 상태 코드

* 가끔 클라이언트는 서버가 다룰 수 없는 무언가를 보내는데, 잘못 구성된 요청 메시지거나, 흔히 존재하지 않는 URL에 대한 요청이 있다.

| 상태 코드 | 사유 구절 | 의미 |
|:---|:---|:---|
| 400 | Bad Request | 클라이언트가 잘못된 요청을 보냈다고 말해줌. |
| 401 | Unauthorized | 리소스를 얻기 전 클라이언트에게 스스로를 인증하라고 요구하는 내용의 응답을 적절한 헤더와 함께 반환. |
| 402 | Payment Required | 현재 사용되지 않지만 미래에 사용 가능성을 위해 준비해 둠. |
| 403 | Forbidden | 요청이 서버에 의해 거부되었음을 알려줌. 서버가 거부 사유를 알려주고자 한다면 이유를 설명하는 엔터티 본문을 포함시킬 수 있음. 그러나 보통 서버가 거절 이유 숨길 때 사용 |
| 404 | Not Found | 서버가 요청한 URL을 찾을 수 없음을 알림. 종종 클라이언트 애플리케이션이 사용자에게 보여주기 위한 엔터티가 포함 |
| 405 | Method Not Allowed | 요청한 URL에 대해, 지원하지 않는 메서드로 요청받았을 때 사용. 요청에 어떤 메서드가 사용 가능한지 알려주는 Allow 헤더를 포함해야 함 |
| 406 | Not Acceptable | 클라이언트 자신이 어떤 종류의 엔터티를 받아들일건지 매개변수로 명시할 수 있다. 주어진 URL에 대한 리소스 중 클라이언트가 받아들일 수 있는 것이 없는 경우 사용. |
| 407 | Proxy Authentication Required | 401 상태 코드와 같으나, 리소스에 대해 인증을 요구하는 프락시 서버를 위해 사용. |
| 408 | Request Timeout | 클라이언트 요청 완수에 시간이 너무 많이 걸리는 경우, 서버는 이 상태 코드로 응답하고 연결을 끊을 수 있음. |
| 409 | Conflict | 요청이 리소스에 대해 일으킬 수 있는 몇몇 충돌을 지칭하기 위해 사용. 응답은 충돌에 대해 설명하는 본문을 포함해야 함. |
| 410 | Gone | 404와 비슷하나, 서버가 한때 그 리소스를 갖고 있었다는 점이 다름. 웹사이트를 유지보수하면서 서버 관리자가 클라이언트에게 리소스가 제거 됐을 때 알려주기 위해 사용 |
| 411 | Length Required | 서버가 요청 메시지에 Content-Length 헤더가 있을 것을 요구할 때 사용 |
| 412 | Precondition Failed | 클라이언트가 조건부 요청을 했는데 그 중 하나가 실패했을 때 사용, 조건부 요청은 클라이언트가 Expect 헤더를 포함했을 때 발생 |
| 413 | Request Entity Too Large | 서버가 처리할 수 있는/처리하고자 하는 한계를 넘은 크기의 요청을 클라이언트가 보냈을 때 사용 |
| 414 | Request URI Too Long | 서버가 처리하고자 하는 한계를 넘은 길이의 요청 URL이 포함된 요청을 클라이언트가 보냈을 때 사용 |
| 415 | Unsupported Media Type | 서버가 이해하거나 지원하지 못하는 내용 유형의 엔터티를 클라이언트가 보냈을 때 사용 |
| 416 | Requested Range Not Satisfiable | 요청 메시지가 리소스의 특정 범위를 요청했는데, 그 범위가 잘못되었거나 맞지 않을 때 사용 |
| 417 | Expectation Failed | 요청에 포함된 Expect 요청 헤더에 서버가 만족시킬 수 없는 기대가 담겨있는 경우 사용 |

### 3.4.5 500-599: 서버 에러 상태 코드

* 클라이언트가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생하는 경우가 있다. 클라이언트가 서버의 제한에 걸린 것일 수 있고 혹은 게이트웨이 리소스 같은 서버의 보조 구성 요소에서 발생한 에러일 수도 있다.
* 프락시는 클라이언트 입장에서 서버와 대화를 시도할 때 자주 에러를 만난다. 프락시는 문제 설명을 위해 5XX 서버 에러 상태 코드를 생성한다.

| 상태 코드 | 사유 구절 | 의미 |
|:---|:---|:---|
| 500 | Internal Server Error | 서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때 사용 |
| 501 | Not Implemented | 클라이언트가 서버의 능력을 넘은 요청을 했을 때 사용 |
| 502 | Bad Gateway | 프락시나 게이트웨이처럼 행동하는 서버가 요청 응답 연쇄에 있는 다음 링크로부터 가짜 응답에 맞닥뜨렸을 때 사용 |
| 503 | Service Unavailable | 현재는 서버가 요청을 처리해 줄 수 없지만 나중에는 가능함을 의미하고자 할 때 사용 |
| 504 | Gateway Timeout | 상태 코드 408과 비슷하지만, 다른 서버에게 요청을 보내고 응답을 기다리다 타임아웃이 발생한 게이트웨이나 프락시에서 온 응답이라는 점이 다름 |
| 505 | HTTP Version Not Supported | 서버가 지원할 수 없거나 지원하지 않으려는 버전의 프로토콜로 된 요청을 받았을 때 사용 |


## 3.5 헤더

* 특정 종류의 메시지에만 사용할 수 있는 헤더와, 더 일반 목적으로 사용할 수 있는 헤더, 그 응답과 요청 메시지 양쪽 모두에서 정보를 제공하는 헤더가 있다.
* 확장 헤더는 애플리케이션 개발자들에 의해 만들어졌지만 아직 승인된 HTTP 명세에 추가되지 않은 비표준 헤더이다.

### 3.5.1 일반 헤더 General Headers

* 클라이언트와 서버 모두가 사용한다. 클라이언트, 서버, 그리고 어딘가에 메시지를 보내는 다른 애플리케이션들을 위해 다양한 목적으로 사용된다.
* 메시지가 어떤 종류이든 상관 없이 유용한 정보를 제공한다.
* 예: `Date: Tue, 17 Nov 2020 23:13:00 GMT`
  * Date 헤더는 서버/클라이언트 가리지 않고 메시지가 만들어진 일시를 지칭하기 위해 사용하는 일반 목적 헤더이다.

| 헤더 | 설명 |
|:---|:---|
| Connection | 클라이언트와 서버가 요청/응답 연결에 대한 옵션을 정할 수 있게 함 |
| Date | 메시지가 생성된 날짜 시간 |
| MIME-Version | 발송자가 사용한 MIME의 버전 |
| Trailer chunked transfer | 인코딩으로 인코딩된 메시지의 끝 부분에 위치한 헤더들의 목록을 나열 |
| Transfer-Encoding | 수신자에게 안전한 전송을 위해 메시지에 어떤 인코딩이 적용되었는지 알려줌 |
| Upgrade | 발송자가 '업그레이드'하길 원하는 새 버전이나 프로토콜을 알려줌 |
| Via | 이 메시지가 어떤 중개자(프락시, 게이트웨이)를 거쳐 왔는지 보여줌 |

* 일반 캐시 헤더
  * HTTP/1.0은 HTTP 어플리케이션에게 매번 원 서버로부터 객체를 가져오는 대신 로컬 복사본으로 캐시할 수 있게 해주는 최초의 헤더를 도입했다.

| 헤더 | 설명 |
|:---|:---|
| Cache-Control | 메시지와 함께 캐시 지시자를 전달하기 위해 사용 |
| Pragma | 메시지와 함께 지시자를 전달하는 또 다른 방법. 캐시에 국한되지 않는다. |

### 3.5.2 요청 헤더 Request Headers

* 요청 메시지를 위한 헤더. 서버에게 클라이언트가 받고자 하는 데이터 타입이 무엇인지와 같은 부가 정보를 제공한다.

| 헤더 | 설명 |
|:---|:---|
| Client-IP | 클라이언트가 실행된 컴퓨터의 IP 제공 |
| From | 클라이언트 사용자의 메일 주소 제공 |
| Host | 요청의 대상이 되는 서버의 호스트 명과 포트를 줌 |
| Referer | 현재의 요청 URI가 들어있었던 문서의 URL을 제공 |
| UA-Color | 클라이언트 기기 디스플레이의 색상 능력에 대한 정보 제공 |
| UA-CPU | 클라이언트 CPU의 종류나 제조사 알려줌 |
| UA-Disp | 클라이언트 디스플레이 능력에 대한 정보 제공 |
| UA-OS | 클라이언트 기기에서 동작 중인 운영체제의 이름과 버전 알려줌|
| UA-Pixels | 클라이언트 기기 디스플레이에 대한 픽셀 정보 제공 |
| User-Agent | 요청을 보낸 애플리케이션 이름을 서버에 말해줌 |

#### Accept 관련 해더

* 클라이언트는 Accept관련 헤더를 이용해 무엇을 원하고 우엇을 할 수 있는지, 원치 않는 것은 무엇인지 알려줄 수 있다.

| 헤더 | 설명 |
|:---|:---|
| Accept | 서버에게 서버가 보내도 되는 미디어 종류 |
| Accept-Charset | 서버에게 서버가 보내도 되는 문자집합 |
| Accept-Encoding | 서버에게 서버가 보내도 되는 인코딩 |
| Accept-Language | 서버에게 서버가 보내도 되는 언어 |
| TE (Transfer Encoding) | 서버에게 서버가 보내도 되는 확장 전송 코딩 |

#### 조건부 요청 해더

* 클라이언트는 서버에게 요청에 응답하기 전 먼저 조건이 참인지 확인하게 하는 제약을 포함시킬 수 있다.

| 헤더 | 설명 |
|:---|:---|
| Expect | 클라이언트가 요청에 필요한 서버의 행동을 열거할 수 있게 해줌 |
| If-Match | 문서의 엔터티 태그가 주어진 엔터티 태그와 일치하는 경우에만 문서를 가져옴 |
| If-Modified-Since | 주어진 날짜 이후에 리소스가 변경되지 않았따면 요청을 제한 |
| If-None-Match | 문서의 엔터티 태그가 주어진 엔터티 태그와 일치하지 않는 경우에만 문서를 가져옴 |
| If-Range | 문서의 특정 범위에 대한 요청 |
| If-Unmodified-Since | 주어진 날짜 이후에 리소스가 변경되었다면 요청 제한 |
| Range | 서버가 범위 요청을 지원한다면, 리소스에 대한 특정 범위를 요청 |

#### 요청 보안 헤더

* HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 갖고 있다. 요청하는 클라이언트가 어느 정도 리소스에 접근하기 전, 자신을 인증하게 함으로써 트랜잭션을 좀 더 안전하게 만들고자 한다.

| 헤더 | 설명 |
|:---|:---|
| Authorization | 클라이언트가 서버에게 제공하는 인증 그 자체를 담고 있음 |
| Cookie | 클라이언트가 서버에게 토큰을 전달할 때 사용 |
| Cookie2 | 요청자가 지원하는 쿠키의 버전을 알려줄 때 사용 |

#### 프락시 요청 헤더

| 헤더 | 설명 |
|:---|:---|
| Max-Forwards | 다른 프락시나 게이트웨이로 전달될 수 있는 최대 횟수. TRACE 메서드와 사용 |
| Proxy-Authorization | Authorization과 같으나 프락시에서 인증을 할 때 쓰임 |
| Proxy-Connection | Connection과 같으나 프락시에서 연결을 맺을 때 쓰임 |

### 3.5.3 응답 헤더 Response Headers

* 응답 메시지는 클라이언트에게 정보 제공을 위해 자신만의 헤더를 갖고 있다.
* 응답 헤더는 클라이언트에게 부가 정보를 제공한다.
* 예) ```Server: TIki-Hut/1.0``

| 헤더 | 설명 |
|:---|:---|
| Age | 응답이 얼마나 오래되었는지 |
| Public | 서버가 특정 리소스에 대해 지원하는 요청 메서드의 목록 |
| Retry-After | 현재 리소스가 불가능한 상태일 때, 언제 가능한지 날짜 또는 시각 |
| Server | 서버 애플리케이션의 이름과 버전 |
| TItle | HTML 문서에서 주어진 것과 같은 제목 |
| Warning | 사유 구절에 있는 것보다 더 자세한 경고 메시지 |

#### 협상 헤더

* HTTP/1.1은 서버와 클라이언트가 어떤 표현을 택할 것인지 협상할 수 있도록 지원한다.

| 헤더 | 설명 |
|:---|:---|
| Accept-Ranges | 서버가 자원에 대해 받아들일 수 있는 범위의 형태 |
| Vary | 서버가 확인해 보아야 하고 응답에 영향을 줄 수 있는 헤더들의 목록 |

#### 응답 보안 헤더

| 헤더 | 설명 |
|:---|:---|
| Proxy-Authenticate | 프락시에서 클라이언트로 보낸 인증요구의 목록 |
| Set-Cookie | 서버가 클라이언트를 인증할 수 있도록 클라이언트 측에 토큰을 설정하기 위해 사용 |
| Set-Cookie2 | Set-Cookie와 비슷하게 RFC 2965로 정의된 쿠키 |
| WWW-Authenticate | 서버에서 클라이언트로 보낸 인증요구의 목록 |

### 3.5.4 엔터티 헤더 Entity Headers

* 엔터티 본문에 대한 헤더를 말한다. 엔터티 헤더는 엔터티 본문에 들어있는 데이터 타입이 무엇인지 알려줄 수 있다.
* `Content-Type: text/html; charset=iso-latin-1`

| 헤더 | 설명 |
|:---|:---|
| Allow` | 엔터티에 대해 수행될 수 있는 요청 메서드들을 나열 |
| Location | 클라이언트에게 엔터티가 실제로 어디에 위치하고 있는지 알려줌. 수신자에게 리소스에 대한 (아마도 새로운) 위치(URL)을 알려줄 때 사용 |

#### 콘텐츠 헤더

* 엔터티의 콘텐츠에 대한 구체적인 정보를 제공한다. 콘텐츠의 종류, 크기, 기타 콘텐츠를 처리할 때 유용하게 활용될 수 있는 것들이다.
* 예) 웹브라우저는 내용 유형을 기술한 Content-Type 헤더를 보고 그 객체를 어떻게 보여줄 지 결정할 수 있다.

| 헤더 | 설명 |
|:---|:---|
| Content-Base | 본문에 사용된 상대 URL을 확인하기 위한 기저 URL |
| Content-Encoding | 본문에 적용된 인코딩 |
| Content-Language | 본문을 이해하는데 가장 적절한 자연어 |
| Content-Length | 본문의 길이나 크기 |
| Content-Location | 리소스의 실제 위치 |
| Content-MD5 | 본문의 MD5 체크섬checksum |
| Content-Range | 전체 리소스에서 엔터티가 해당하는 범위를 바이트 단위로 표현 |
| Content-Type | 본문이 어떤 종류 객체인지 |


#### 엔터티 캐싱 헤더

* 일반 캐싱 헤더는 언제 어떻게 캐시가 되어야하는지 지시자를 제공한다.
* 엔터티 캐싱 헤더는 엔터티 캐싱에 대한 정보를 제공한다: 리소스 캐시 사본이 아직 유효한지, 캐시된 리소스가 더 이상 유효하지 않게 되는 시점을 더 잘 추정하기 위한 단서

| 헤더 | 설명 |
|:---|:---|
| ETag | 이 엔터티에 대한 엔터티 태그 |
| Expires | 엔터티가 더 이상 유효하지 않아 원본을 다시 받아와야 하는 일시 |
| Last-Modified | 가장 최근 엔터티가 변경된 일시 |

## 3.6 추가 정보

* [RFC 2515, Hypertext Transfer Protocol](https://www.w3.org/Protocols/rfc2616/rfc2616.txt)
* [HTTP - Hypertext Transfer Protocol](https://www.w3.org/Protocols/)
