# 18. 웹 호스팅

* 공용 웹 서버에 리소스를 올려두면 인터넷을 통해 이용할 수 있다.
* 각 조직이 가진 다양한 종류의 리소스를 웹 사이트에 편하게 배포하거나, 적절한 가격에 좋은 성능을 가진 웹 서버에 배치하는 것은 중요하다.
* 콘텐츠 리소스를 저장, 중개, 관리하는 일을 통틀어 웹 호스팅이라고 한다. 이는 웹 서버의 가장 중요한 기능 중 하나다.
* 직접 필요한 하드웨어와 소프트웨어 관리가 어렵다면 호스팅 서비스나 호스팅 업체가 필요할 것이다.
* 호스팅 업체는 서버와 웹 사이트 관리 프로그램을 대여해주고 다양한 등급의 보안, 리포트, 사용 편의를 제공한다.
* 보통 호스팅 업체는 경제적이면서 믿을 수 있고 성능 좋은 웹 사이트 제공을 위해 잘 손상되지 않는 공용 웹 서버에 올린다.
* 이 장에서 다루는 내용
  * 여러 웹 사이트를 같은 서버에 '가상 호스팅'하는 방법, 그리고 그것이 HTTP에 끼치는 영향
  * 트래픽이 많은 상황에서 안정적인 사이트를 구축하는 방법
  * 웹 사이트 로딩을 더 빠르게 하는 방법

## 18.1 호스팅 서비스

* 월드 와이드 웹 초기에는 각 회사가 자체 컴퓨터 하드웨어를 구매하고 자체적으로 컴퓨터 망을 구축하여 네트워크 망, 웹 서버 소프트웨어를 관리했다.
* 웹이 대세가 되면서 자체적으로 서버를 구축하고 관리하는 시간을 절약하기 위해 전문적으로 웹 호스팅 서비스를 제공하는 신사업이 만들어졌다. 물리적인 장비 관리(공간, 냉난방, 연결)부터 고객이 직접 콘텐츠를 제공할 수 있는 총체적인 웹 호스팅까지 다양한 서비스가 있다.

### 18.1.1 간단한 예: 전용 호스팅

* 고성능 웹 서버로 구성된 랙을 가진 곳의 전용 웹 호스팅 서비스에 가입하여 웹 서버를 대여해 규모가 큰 사이트를 운영할 수 있다.
* 이미 대량으로 장비를 갖춘 곳의 안정적이고 저렴한 장비를 선택할 수 있으며, 필요하다면 추가 서버를 즉시 제공받을 수 있다.
* 이런 웹 서버는 여러 곳에 웹 서버를 임대한다. 브라우저는 각각의 서버 IP 주소를 가리키는 곳에 HTTP 요청을 한다.

## 18.2 가상 호스팅

* 일부 시간에만 활용되는 웹 공간이 필요한 경우, 비용이 큰 전용 웹 서버는 낭비다.
* 많은 웹 호스팅 업자는 컴퓨터 한 대를 여러 고객이 공유하게 하여 저렴한 웹 호스팅 서비스를 제공한다. 이를 공유 호스팅 혹은 가상 호스팅이라고 부른다.
* 각 웹사이트는 다른 서버에서 호스팅하는 것처럼 보이지만, 사실 물리적으로 같은 서버에서 호스팅되는 것이다. 최종 사용자 입장에서는 가상 호스팅에 있는 웹 사이트와 물리적으로 분리된 전용 서버에서 호스팅하는 사이트와 구분할 수 없어야 한다.
* 가상 호스팅은 비용, 공간, 관리에 이점이 있어 가상 호스팅 제공 업자는 한 서버에 수십에서 수천 개 웹사이트를 호스팅하려고 한다.
  * 호스팅 업자는 복제 서버 더미(서버 팜이라 부르는)를 만들고 서버 팜에 부하를 분산할 수 있다.
  * 팜에 있는 각 서버는 다른 서버를 복제한 것이며, 수많은 가상 웹사이트를 호스팅하고 있기 때문에 관리자는 더 편해진다.
* 사이트를 운영하는 입장에서 별도 웹 서버를 구축해야 할 정도로 트래픽이 올라가기 전까지는 비용 절약을 위해 가상 호스팅을 이용할 것이다.

### 18.2.1 호스트 정보가 없는 가상 서버 요청

* HTTP/1.0에는 가상 호스팅 업자가 골머리를 앓을 설계 관련 결함이 있다. HTTP/1.0 명세는 공용 웹 서버가 호스팅하고 있는 가상 웹 사이트에 누가 접근하고 있는지 식별하는 기능을 제공하지 않는다.
* HTTP/1.0 요청은 요청 메시지에 URL의 경로 컴포넌트만 전송한다.
  * 만약 `http://abc.com/index.html`을 요청하면 브라우저는 `abc.com`에 연결하지만, HTTP/1.0 요청은 호스트 명 언급 없이 `GET /index.html` 요청을 하고, 이는 abc.com과 공유하고 있는 공용 웹 서버에 전송된다.
  * 서버가 여러 개 사이트를 가상 호스팅하고 있으면, 사용자가 어떤 가상 웹사이트로 접근하려는지 정보가 충분치 않다.
  * 서로 다른 웹 사이트에 대한 두 요청이 완전히 다른 문서를 요청하더라도, 요청 자체는 똑같이 생겼다. 문제는 웹 사이트 호스트 정보가 요청에서 제거된다는 것이다.
  * 이 문제를 해결하고자 HTTP/1.1은 Host 헤더를 지원한다.
* HTTP 대리 서버(리버스 프락시)와 인터셉트 프락시 또한 어떤 사이트를 요청하는지에 관한 정보가 필요하다.

### 18.2.2 가상 호스팅 동작하게 하기

* 호스트 정보를 HTTP 요청 명세에 넣지 않은 것은, 각 웹 서버가 정확히 한 웹사이트만 호스팅할 것이라고 잘못 예측한 HTTP 명세의 실수다.
  * 가상 호스팅을 고려하지 않아, URL에 있는 호스트 명 정보는 필요 없는 것으로 여거 명세에서 제거하고 단순히 경로 컴포넌트만 전송하도록 설계했다.
* 이런 초기 명세 때문에 웹 호스팅 업자는 공용 가상 호스팅을 지원에 필요한 차선책과 컨벤션을 개발해야 했다.
  * 모든 HTTP 요청 메시지에 경로 컴포넌트만 보내는 것이 아니라 완전한 URL도 포함해 보내서 해결했다.
  * HTTP/1.1 지원 서버는 HTTP 요청 메시지에 있는 전체 URL을 처리할 수 있어야 한다.
* 그러나 기존 모든 애플리케이션이 이 명세에 맞춰 업그레이드하기까지 오랜 시간이 걸릴 것이다. 그 사이 다음 네 가지 기술이 나타났다.

##### URL 경로를 통한 가상 호스팅

* 서버가 어떤 사이트를 요청하는 것이지 알 수 있게 URL에 특별한 경로 컴포넌트를 추가한다.
* 예를 들어 논리적인 웹 사이트마다 특정 경로를 앞에 붙일 수 있다.
  ```
  http://www.abc.com/a/index.html
  http://www.xyz.com/z/index.html
  ```
* 서버에 요청이 도착하면 호스트 명 정보가 요청에 포함되어 있진 않지만, 경로의 정보를 통해 이해한다.
  ```
  GET /a/index.html --- abc.com에 대한 요청
  GET /z/index.html --- xyz.com에 대한 요청
  ```
* 그러나 이는 좋은 해결책이 아니다. 이런 접두어는 불필요하고 혼란스럽다. 게다가 일반적으로 홈페이지에 접속할 때 사용하는 ~.com, ~.com/index.html 같은 URL이 동작하지 않는다.
* 일반적으로 URL 기반 가상 호스팅은 좋지 않은 방법이라 거의 사용하지 않는다.

##### 포트번호를 통한 가상 호스팅

* 각 사이트에 다른 포트번호를 할당하여, 분리된 앱 서버의 인스턴스가 요청을 처리한다.
* 그러나 URL 기반과 같은 문제가 있는데, 사용자는 URL에 비표준 포트를 쓰지 않고서도 리소스를 찾길 원하기 때문이다.

##### IP 주소를 통한 가상 호스팅

* 훨씬 더 좋은 방법은, 각 가상 사이트에 별도의 유일한 IP 주소를 할당하는 것이다.
* 모든 IP 주소는 공용 서버 장비 하나에 연결된다. 서버는 HTTP 커넥션의 목적지 IP 주소를 보고 클라이언트가 어떤 웹사이트에 접속할지 알 수 있다.
* 웹 서버는 특정 주소에 대한 IP 주소로 사이트 이름을 식별한다.
  * 해당 주소에 대한 IP 주소를 찾고, 그 서버에 TCP  커넥션을 맺어 요청을 보낸다.
* 가상 IP 호스팅은 잘 동작하지만, 규모가 아주 큰 호스팅 업자에게는 어려움이 있다.
  * 일반적으로 컴퓨터 시스템이 연결할 수 있는 장비의 IP 개수에는 제한이 있다. 수백 혹은 수천 개의 가상 사이트를 포함하는 공용 서버를 제공할 때 문제가 된다.
  * IP 주소는 희소 상품이다. 가상 사이트를 많이 가진 호스팅 업자는 모든 웹 사이트에 할당할 가상 IP 주소를 충분히 얻지 못할 수 있다.
  * IP 주소가 부족한 문제는 호스팅 업자가 용량을 늘리려고 서버를 복제하면서 더 심각해진다. 부하 균형의 구조상, 각 복제된 서버에 IP 주소를 부여해야 하므로 복제 서버 개수만큼 IP 주소가 더 필요하다.
* 이런 IP 주소 부족 문제에도 불구하고 널리 쓰이는 방식이다.

##### Host 헤더를 통한 가상 호스팅

* 가상 IP 제한 문제를 피하기 위해, 가상 사이트들이 같은 IP를 사용하더라도 각 사이트가 어디에 속해 있는지 알 수 있어야 한다.
* 브라우저와 서버 개발자는 서버가 원 호스트 명을 받아볼 수 있게 HTTP를 확장했다. 웹 서버는 Host 헤더로 가상 사이트를 식별할 수 있다.
  * 하지만 대부분 서버가 경로 컴포넌트만 받아 요청을 처리하기 때문에 브라우저가 전체 URL을 보내도 소용이 없다. 대신, 모든 요청에 호스트 명(그리고 포트)을 Host 확장 헤더에 기술해서 전달한다.
* Host 헤더는 HTTP/1.0+와 HTTP/1.1 공식 버전에 소개되었다.
* HTTP/1.1 명세를 따르려면 Host 헤더를 반드시 기술해야 한다.
  * 이름 기반의 가상 호스팅을 지원하는 일반 서버에서는 유실될 수 있다.
  * 현재는 거의 모든 브라우저가 Host 헤더를 지원한다.

### 18.2.3 HTTP/1.1 Host 헤더

* Host 헤더는 [RFC 2068](https://tools.ietf.org/html/rfc2068)에 정의된 HTTP/1.1 요청 헤더다.
* 가상 서버는 매우 흔해서, 대부분 HTTP 클라이언트가 HTTP/1.1과 호환되지 않아도 Host 헤더는 구현한다.

##### 문법과 사용 방법

* Host 헤더에는 원본 URL에 있는 요청 리소스에 대한 인터넷 호스트와 포트번호를 기술한다.
  ```
  Host = "Host" ":호스트[":"포트]
  ```
* Host 헤더에 포트가 기술되어 있지 않으면 해당 스킴의 기본 포트를 사용한다.
* URL에 IP주소가 있으면 Host 헤더는 같은 주소를 포함해야 한다.
* URL에 호스트 명이 기술되어 있으면, Host 헤더는 같은 호스트 명을 포함해야 한다.
* URL에 호스트 명이 기술되어 있으면, Host 헤더는 URL의 호스트 명이 가리키는 IP 주소를 포함해서는 안 된다.
  * 여러 개 가상 사이트를 한 개의 IP 주소에 연결한 가상 호스트 서버에서 문제가 될 수 있다.
* 클라이언트가 특정 프락시 서버를 사용한다면, Host 헤더에 프락시 서버가 아닌 원 서버의 호스트 명과 포트를 기술해야 한다.
  * 과거에 여러 웹 클라이언트가 프락시 설정이 활성화되어 있을 때 전송하는 Host 헤더에 프락시의 호스트 명을 넣는 버그가 있었다. 이는 프락시와 원 서버를 오동작시키는 원인이 된다.
* 웹 클라이언트는 모든 요청 메시지에 Host 헤더를 기술해야 한다.
* HTTP/1.1 웹 서버는 Host 헤더 필드가 없는 HTTP/1.1 요청 메시지를 받으면 `400` 상태 코드로 응답해야 한다.

```
GET http://www.abc.com/index.html HTTP/1.0
Connection: Keep-Alive
User-Agent: Mozilla/4.51 [en] (X11; U; IRIX 6.2 IP22)
Accept: image/gif, image/x-xbitmap. image/jpeg, image/pjpeg, image/png, */*
Accept-Encoding: gzip
Accept-Language: en
Host: www.abc.com
```

##### Host 헤더의 누락

* 현재는 거의 없지만, 일부 Host 헤더를 보내지 않는 낡은 브라우저의 경우, 서버는 사용자를 기본 웹페이지로 보내거나 브라우저를 업그레이드하라고 제안하는 에러페이지를 반환할 수 있다.

##### Host 헤더 해석하기

* 가상 호스팅을 지원하지 않는 원 서버는 요청 받는 호스텡 따라 리소스가 달라지지 않기 때문에 Host 헤더 값을 무시할 것이다.
* 호스트를 기준으로 리소스를 구분하는 모든 웹 서버는 HTTP/1.1을 통해 오는 리소스를 결정하기 위해 다음 규칙을 사용한다.
  1. HTTP 요청 메시지에 전체 URL이 기술되어 있으면(예: 스킴과 호스트 컴포넌트가 기술되어 있을 때), Host 헤더에 있는 값은 무시하고 URL을 사용한다.
  2. HTTP 요청 메시지에 있는 URL에 호스트 명이 기술되어 있지 않고 요청에 Host 헤더가 있으면, 호스트 명과 포트를 Host 헤더에서 가져온다.
  3. 1이나 2단계에서 호스트를 결정할 수 없으면 클라이언트에게 `400 Bad Request` 응답을 반환한다.

##### Host 헤더와 프락시

* 어떤 브라우저 버전은 특히 프락시를 사용하게 설정했을 때 부정확한 Host 헤더를 보낸다.
* 프락시를 사용하도록 구성할 때 버전이 오래된 클라이언트는 실수로 원 서버 이름이 아닌 프락시 이름을 Host 헤더에 담아 전송한다.

## 18.3 안정적인 웹 사이트 만들기

* 웹 사이트에 장애가 생기는 상황
  * 서버 다운
  * 트래픽 폭증: 갑자기 많은 사람이 특정 뉴스 방송을 보려고 하거나 할인 행사 때문에 몰려드는 상황. 갑작스런 트래픽 폭증은 웹 서버에 과부하를 주어 느려지게 하거나 완전히 멈춰버리게 한다.
  * 네트워크 장애나 손실

### 18.3.1 미러링 된 서버 팜

* 서버 팜은 서로 대신할 수 있고 식별할 수 있게 설정된 웹 서버들의 집합이다.
* 서버 팜의 서버에 있는 콘텐츠는 한 곳에 문제가 생기면 다른 한 곳에서 대신 전달할 수 있게 미러링 할 수 있다.
* 보통 미러링 된 서버는 계층적인 관계에 있다. 원본 콘텐츠를 가진 한 서버를 마스터 원 서버라 부른다. 이 서버로부터 콘텐츠를 받은 미러링 된 서버는 복제 원 서버라 부른다.
* 서버 팜에 배포하는 간단한 방법은 네트워크 스위치를 사용해 서버에 분산 요청을 보내는 것이다. 서버에 호스팅 되고 있는 각 웹사이트 IP 주소는 스위치의 IP 주소가 된다.
* 외부에서 볼 때 콘텐츠를 가리키는 IP 주소는 스위치의 IP 주소다. 스위치는 서버에게 요청을 전송해야 하는 책임이 있다.
* 미러링 된 웹 서버에는 다른 위치에 있는 콘텐츠와 정확히 같은 복제본이 있다. 마스터 서버는 관할 지역의 클라이언트에게 콘텐츠를 제공하면서 복제 서버들에게 콘텐츠를 퍼트리는 일을 한다.
* 분산된 미러링 된 서버에서 클라이언트의 요청이 특정 서버로 가는 방법
  1. HTTP 리다이렉션: 콘텐츠에 대한 URL은 마스터 서버의 IP를 가리키고, 마스터 서버는 요청을 받는 즉시 복제 서버로 리다이렉트 시킨다.
  2. DNS 리다이렉션: 콘텐츠의 URL은 n개의 IP 주소를 가리킬 수 있고, DNS 서버는 클라이언트에게 전송할 IP 주소를 선택할 수 있다.

### 18.3.2 콘텐츠 분산 네트워크

* 콘텐츠 분산 네트워크(CDN)는 특정 콘텐츠의 분산을 목적으로 하는 단순한 네트워크다.
* 네트워크의 노드는 서버, 대리 서버, 혹은 프락시 서버가 될 수 있다.

### 18.3.3 CDN의 대리 캐시

* 대리 캐시는 복제 원 서버를 대신해 사용될 수 있다.
* 리버스 프락시라고도 불리는 대리 서버는 미러링된 웹 서버처럼 콘텐츠에 대한 요청을 받는데, 특정 원 서버 집합을 대신해 요청을 받는다.
  * 이는 콘텐츠에 대한 IP 주소가 알려졌기 때문에 가능하다.
  * 보통 원 서버와 대리 서버가 연결되며, 대리 서버는 특정 원 서버를 가리키는 요청을 받는다.
* 대리 서버와 미러링 된 서버의 차이점은,
  * 대리 서버는 보통 수요에 따라 동작한다는 것이다.
  * 대리 서버는 원 서버의 전체 콘텐츠를 복사하지 않는다. 클라이언트가 요청하는 콘텐츠만 저장할 뿐이다.
  * 대리 서버의 캐시에 콘텐츠가 분산되는 방식은 받는 요청에 따라 달라진다.
  * 원 서버는 그들의 콘텐츠를 업데이트해줄 의무는 없다.
* 많은 요청이 있는 콘텐츠를 빠르게 제공하기 위해 사용자가 요청하기도 전에 콘텐츠를 가져오는 '미리 가져오기'기능의 대리 서버도 있다.
* CDN이 대리 서버보다 캐시를 계층화하기 더 어렵다.

### 18.3.4 CDN의 프락시 캐시

* 대리 서버와 다르게, 전통적인 프락시 캐시는 어떤 웹 서버 요청이든 다 받을 수 있다.
  * 프락시 캐시와 원 서버 간 연동이나 IP 주소 합의가 필요 없다.
* 대리 서버를 사용하면, 프락시 캐시의 콘텐츠는 요청이 있을 때만 저장될 것이고, 원본 서버 콘텐츠를 정확히 복제한다는 보장이 없다. 어떤 프락시는 요청을 많이 받는 콘텐츠를 미리 로딩하기도 한다.
* 요청이 있을 떄만 저장하는 프락시 캐시는 조금 다르게 동작하는데, 레이어2 혹은 레이어3 장비(스위치 혹은 라우터)가 중간에서 웹 트래픽을 가로채 처리하기도 한다.
* 가로채기 설정은 클라이언트와 서버 사이 모든 HTTP 요청이 물리적으로 캐시를 거치게 네트워크 설정을 할 수 있는지에 따라 달라진다(20장 참고). 콘텐츠는 받는 요청에 따라 캐시에서 분산된다.

## 18.4 웹 사이트 빠르게 만들기

* 서버 팜이나 분산 프락시 캐시나 대리 서버는 혼잡을 조절하고 네트워크 트래픽을 분산시킨다.
* 콘텐츠를 분산시키면 사용자에게 더 가깝게 만들어, 주어 서버에서 클라이언트로 전송하는 시간이 단축된다.
* 어떻게 요청과 응답이 클라이언트와 서버 사이에서 연결을 맺고 인터넷을 가로질러 데이터를 전송하는지에 따라 리소스의 로딩 속도는 좌우된다.
* 웹 사이트 속도를 높이는 또 다른 방법은 콘텐츠를 인코딩하는 것이다. 예를 들어 클라이언트가 받은 압축을 해제할 수 있다는 가정하에, 콘텐츠를 압축하는 것이다(15장 참고).

## 18.5 추가 정보