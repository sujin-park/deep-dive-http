- 웹 호스팅: 웹 서버에서 중요한 기능 중 하나로 콘텐츠 리소스를 저장, 중개, 관리하는 일의 통틀어 말함

## 18.1 호스팅 서비스

- WWW 초기에는 각 회사가 자체적으로 컴퓨터 하드웨어, 컴퓨터 망, 웹 서버 소프트웨어를 관리했지만, 웹이 빠르게 대세가 되면서 전문적으로 관리하는 웹 호스팅 서비스를 제공하는 사업이 만들어 짐

### 18.1.1 간단한 예: 전용 호스팅

- 직접 자체 서버를 구매하고 서버를 유지보수 하는 대신 전용 웹 호스팅 서비스에 가입
    - 서비스에서 구매해 유지보수하는 전용 웹 서버를 임대하고, 필요시에 서버를 추가 임대 할 수 있음

## 18.2 가상 호스팅

- 가상 호스팅(=공유 호스팅): 컴퓨터 한 대를 여러 고객이 공유하게 함.
    - 트래픽이 높지 않은 사이트를 위해 전용 웹 서버를 제공하는 것은 낭비
    - 저렴한 웹 호스팅 서비스 제공 가능
- 최종 사용자 관점에서는 다른 서버에서 호스팅하는 것으로 보이지만, 물리적으로 같은 서버에서 호스팅
- 가상 호스팅은 비용, 공간, 관리에 이점이있어 한 서버에 수십~수천의 많은 웹 사이트를 호스팅
    - PC 한대에 수천개씩 구축한다는 뜻이아니라, 복제 서버 더미(=서버 팜)을 만들고 부하를 분산.
    - 팜에 있는 각 서버는 다른 서버를 복제한 것이며, 수많은 가상 웹 사이트를 호스팅하므로 관리가 편함

### 18.2.1 호스트 정보가 없는 가상 서버 요청

- HTTP/1.0에서는 가상 웹사이트에 누가 접속하는지 식별하는 기능이 없어서, 가상호스팅 업자에게 문제였음
    - URL의 경로 컴포넌트만 전송하여, 어떤 가상 웹사이트의 경로인지 알 수 없어 정보가 충분치 않음
        - 예: `http://joes-hardware.com/index.html` → `GET /index.html`
    - 완전히 다른 문서를 요청하더라도 요청 자체는 똑같을 수 있음

### 18.2.2 가상 호스팅 동작하게 하기

- 각 웹 서버가 정확히 한 웹 사이트만 호스팅할것이라고 잘못 예측한 HTTP 명세 실수.
    - 초기에는 웹 호스팅 업자가 가상 호스팅을 지원하기 위해 별도 컨벤션을 개발해야 했음
- HTTP/1.1은 완전한 URL을 포함하여 보내도록하여 간단하게 해결
- 이전 HTTP/1.0을 대응하는 4가지 기술
    1. URL 경로를 통한 가상 호스팅
        - 각 가상 사이트에 서로 다른 URL경로를 할당하여 각각을 강제로 구분
        - 예: `http://www.joes-hardware.com/joe/index.html` , 
        `http://www.marys-antiques.com/mary/index.html`
        - 불필요한 경로가 하나 더 추가되고, base URL로 접근시 문제가 생기므로 거의 사용하지 않음
    2. 포트 번호를 통한 가상 호스팅
        - 각 가상 사이트마다 포트번호를 할당.
        - 비표준 포트를 사용하므로 문제가 있음.
    3. IP 주소를 통한 가상 호스팅
        - 각 가상 사이트마다 가상 IP를 할당하여, 서버는 HTTP 커넥션의 IP 주소를 보고 어떤 사이트에 연결하려는지 확인
        - 잘 동작하지만 규모가 매우 큰 호스팅업자에게는 약간 문제가 발생.
            - 컴퓨터 시스템마다 연결할 수 있는 장비의 IP 개수 제한
            - IP주소는 희소상품이므로 원하는 만큼 할당 받을 수 없을 수 있음.
            - 용량을 늘리려고 서버를 복제하면, 복제 서버의 개수만큼 IP 개수가 추가적으로 필요하게 됨.
        - 단점에도 불구하고 많이 쓰였던 방식
    4. Host 헤더를 통한 가상 호스팅
        - 호스트명을 받아볼 수 있도록 HTTP를 확장하여 Host 확장헤더에 기술해서 전달
        - HTTP/1.0+에서 처음 소개되었으며, HTTP/1.1 명세에 추가. 현재 모든 브라우저가 지원

### 18.2.3 HTTP/1.1 Host 헤더

- Host 헤더는 [RFC 2068](https://tools.ietf.org/html/rfc2068)에 정의된 HTTP/1.1 요청 헤더.
    - 가상 서버가 매우 흔했으므로, HTTP/1.1과 호환되지 않아도 구현되어 있었음

***문법과 사용*** 

- Host 헤더에는 원본 URL에 있는 요청 리소스에 대한 인터넷 호스트와 포트 번호 기술

```
Host: <host>:<port>
```

- Host 헤더에는 다음과 같은 규칙이 있음
    - 포트가 기술되어있지 않으면, 해당 스킴의 기본 포트 사용
    - URL에 IP 주소가 있으면, Host 헤더는 같은 주소를 포함해야 함
    - URL에 호스트 명이 기술되어 있으면, Host 헤더는 IP 주소가 아닌 같은 호스트명을 포함해야 함.
    - 클라이언트가 특정 프락시 서버를 사용한다면, Host 헤더에는 프락시 서버가 아닌 원 서버의 호스트 명, 포트를 기술 해야 함. 과거에는 프락시 서버를 기술하는 버그가 있어 오작동했음.
    - 웹 클라이언트는 모든 요청 메시지에 Host 헤더를 기술해야 함
    - 웹 프락시는 요청을 전달하기 전에 요청 메시지에 Host 헤더를 추가해야 함
    - HTTP/1.1 웹 서버는 Host 헤더 필드가 없는 HTTP/1.1 요청을 받으면 400 상태코드로 응답해야 함

***Host 헤더의 누락***

- 아주 오래된 브라우저는 Host 헤더를 보내지 않으며, 이 경우 가상 호스팅 서버는 사용자를 기본 웹 페이지로 보내거나 브라우저를 업그레이드하라고 제안하는 에러 페이지를 반환할 수 있음

***Host 헤더 해석하기***

- HTTP/1.1을 통한 Host 헤더 해석에는 다음과 같은 규칙을 사용해야 함
    1. 요청 메시지에 전체 URL이 기술되어있으면, Host 헤더를 무시하고 URL 사용
    2. 요청 메시지의 URL에 호스트명이 없고, Host 헤더가 있으면 호스트명, 포트는 Host 헤더 것을 사용 
    3. 1, 2단계에서 호스트를 결정할 수 없다면 `400 Bad Request` 응답 반환 

***Host 헤더와 프락시***

- 어떤 브라우저는 부정확한 Host 헤더를 보내며, 특히 프락시와 사용하면 프락시 이름을 Host 에 담아 보내기도 함

## 18.3 안정적인 웹 사이트 만들기

- 웹 사이트에 장애가 생기는 몇가지 상황이 있으며, 이를 예측하고 대응하는 몇 가지 방법에 대해 안내
    - 서버 다운
    - 트래픽 폭증
    - 네트워크 장애나 손실

### 18.3.1 미러링 된 서버 팜

- 서버 팜: 서로 대신할 수 있고 식별할 수 있게 설정된 웹 서버들의 집합
    - 서버 팜의 서버에 있는 콘텐츠는 한 곳에 문제가 생기면 다른 한곳에서 대신 전달할 수 있게 미러링 가능
- 미러링 된 서버는 보통 계층적 관계에 있음
    - 원본 컨텐츠를 갖는 서버는 **마스터 원 서버**
    - 마스터 원 서버로부터 콘텐츠를 받은 미러링 된 서버는 **복제 원 서버**
- 서버 팜에 배포하는 간단한 방법 하나는 네트워크 스위치를 사용하여 서버에 분산 요청을 보내는 것
- 마스터 원 서버는 복제 원 서버에 콘텐츠를 보낼 책임이 있음
- 서버에 호스팅 되고 있는 각 웹 사이트의 IP 주소는 스위치 IP의 주소가 됨
    - = 외부에서 볼 때 콘텐츠를 가리키는 IP주소는 스위치의 주소
- 클라이언트의 요청이 특정 서버로 가는 방법
    1. HTTP 리다이렉션
        - 콘텐츠에 대한 URL은 마스터 서버의 IP를 가리키고, 마스터 서버는 요청을 복제 서버로 리다이렉트
    2. DNS 리다이렉션
        - 콘텐츠의 URL은 마스터 원 서버나 복제 원 서버를 가리킬 수 있고, DNS 서버는 클라이언트에게 전송할 IP 주소 선택.

### 18.3.2 콘텐츠 분산 네트워크

- 콘텐츠 분산 네트워크(CDN): 특정 콘텐츠의 분산을 목적으로 하는 단순한 네트워크
    - 네트워크의 노드는 서버, 대리 서버, 프락시 서버가 될 수 있음

### 18.3.3 CDN의 대리 캐시

- 대리 캐시는 복제 원 서버를 대신해 사용될 수 있음.
    - 리버스 프락시라고도 불리며, 미러링 된 웹 서버처럼 콘텐츠에 대한 요청을 받음
    - 특정 원서버 집합을 대신해 요청을 받음.
        - 콘텐츠에 대한 IP주소가 알려져있으며, 원 서버와 대리서버가 연결됨.
- 대리 서버는 미러링 된 서버의 차이점
    - 대리 서버는 수요에 따라 동작
        - 원 서버의 전체 콘텐츠를 복사하지 않고, 클라이언트가 요청하는 컨텐츠만 저장.
    - 원 서버는 그들의 콘텐츠를 업데이트할 의무가 없음
- 많은 요청이 있는 콘텐츠를 빠르게 제공하고, 사용자가 요청하기 전에 콘텐츠를 가져오는 '미리 가져오기(prefetching)' 기능을 가진 대리서버도 있음
- CDN이 대리 서버보다 캐시 계층화하기 어려움

### 18.3.4 CDN의 프락시 캐시

- 프락시 캐시로도 동일하게복제 원 서버를 대신하여 설정해 배포할 수 있음
    - 전통적인 프락시 캐시는 대리서버와 다르게 어떤 웹 서버 요청이든지 다 받을 수 있음.
    - 프락시 캐시와 원 서버간의 연동이나 IP 주소 합의 필요 없음
- 프락시 캐시도 대리 서버와 마찬가지로 콘텐츠 요청이 있을 때만 저장되고, 원본 서버 콘텐츠를 정확히 복제한다는 보장이 없음. 또한 어떤 프락시는 요청을 많이 받은 콘텐츠를 미리 로딩(preload)하기도 함
- 요청이 있을 때만 저장하는 프락시 캐시는 레이어 2나 3 장비(스위치 혹은 라우터)가 중간에서 웹 트래픽을 가로채 처리하기도 함
    - 가로채는 설정은 클라이언트와 서버 사이의 모든 HTTP 요청이 물리적으로 캐시를 거치게 네트워크를 설정할 수 있는지에 따라 달라짐.
    - 콘텐츠는 받는 요청에 따라 캐시에 분산됨

## 18.4 웹 사이트 빠르게 만들기

- 서버 팜, 분산 프락시 캐시, 대리 서버는 웹 사이트를 빠르게 하는데 도움이됨
    - 혼잡 조절하고 네트워크 트래픽을 분산시킴
    - 콘텐츠를 분산시키면 그 콘텐츠를 사용자에게 더 가깝게 만드므로 콘텐츠의 전송시간이 단축됨
- 웹 사이트 속도를 높이는 또 다른 방법은 콘텐츠 인코딩
    - 클라이언트가 받은 압축을 해제할 수 있다는 가정 하에, 콘텐츠를 압축하는 것