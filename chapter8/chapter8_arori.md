## 8.1 게이트웨이

- 게이트웨이: 서로 다른 프로토콜과 애플리케이션 간의 HTTP 인터페이스
    - 리소스 게이트웨이와 프로토콜 게이트웨이가 있음

### 8.1.1 클라이언트 측 게이트웨이와 서버 측 게이트웨이

- 웹 게이트웨이는 HTTP ↔ 비 HTTP 프로토콜로 통신
    - 다른 버전의 HTTP를 변환하는 웹 프락시는 게이트웨이와 같지만, 양쪽이 HTTP라 기술적으론 프락시
- `<클라이언트 측 프로토콜>/<서버측 프로토콜>` 로 구분하여 표기. 예: HTTP/FTP
- 서버 측 게이트웨이: 클라이언트와 HTTP 통신
- 클라이언트 측 게이트웨이: 서버와 HTTP 통신

## 8.2 프로토콜 게이트웨이

- 프로토콜 게이트웨이: HTTP 트래픽을 다른 프로토콜로 자동 변환해, HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 함
- 게이트웨이에 HTTP 트래픽 바로 전송 가능. 프락시에 트래픽을 바로 전송하는 것과 유사.
    - 보통 브라우저에 명시적으로 게이트웨이를 설정해 트래픽이 게이트웨이를 거쳐가게 하거나, 게이트웨이를 대리 서버(리버스 프락시)로 설정할 수도 있음
- 게이트웨이 설정시 일반적인 HTTP 요청에는 원 서버로 보내고 FTP URL을 포함한 요청을 게이트웨이로 보냄

### 8.2.1 HTTP/* 서버측 웹 게이트웨이

- 서버측 웹 게이트웨이: HTTP 요청이 원 서버 영역으로 돌아오는 시점에 HTTP 요청을 외부 프로토콜로 전환
- HTTP/FTP 서버 측 FTP 게이트웨이:
    - HTTP 클라이언트 ↔ HTTP/FTP 인바운드 변환 게이트웨이 ↔ FTP 서버
    - 게이트웨이는 HTTP 요청을 받아 FTP 커넥션을 맺고 적절한 명령 전송
        - USER 와 PASS 명령을 보내 서버에 로그인
        - 서버에서 적절한 디렉터리 변경하기 위한 CWD 명령
        - 다운로드 형식을 ASCII 로 설정
        - MDTM으로 최근 수정 시간 가져옴
        - PASV로 서버에 수동형 데이터 검색 요청
        - RETR로 객체를 검색
        - 제어 채널에서 반환된 포트로 FTP 서버에 데이터 커넥션 맺기. 데이터 채널이 열리는대로 객체가 게이트웨이로 전송 됨

### 8.2.2 HTTP/HTTPS: 서버 측 보안 게이트웨이

- HTTP 클라이언트 ↔ HTTP/HTTPS 인바운드 보안 게이트웨이 ↔ 보안 웹 서버
- 클라이언트는 일반 HTTP를 사용해 웹을 탐색할 수 있지만, 게이트웨이는 HTTPS로 자동으로 암호화.

### 8.2.3 HTTPS/HTTP 클라이언트 측 보안 가속 게이트웨이:

- HTTP 클라이언트 ↔ HTTPS/HTTP 보안 가속 게이트웨이 ↔ 웹 서버
- 게이트웨이는 HTTPS 트래픽을 받아 복호화하고, 일반 HTTP 요청을 목적지 서버로 전달
    - HTTPS 해독은 게이트웨이에 해당 서버 인증서 설치 필요
- 이런 게이트 웨이는 보안 트래픽을 복호화하는 효율적인 암호화 하드웨어를 내장하여 원 서버 부하 경감
    - 게이트웨이 ↔ 원 서버간에는 비암호화 트래픽을 전송하므로 그 사이에 있는 네트워크 안전성 확인 필

## 8.3 리소스 게이트웨이

- 리소스 게이트웨이: 리소스와 애플리케이션을 연결하는 역할
    - 인터프리터와 같이 리소스를 받기 위한 경로를 안내.
        - 모든 리소스를 한 개의 어플리케이션으로 처리할 수 없어 고안
    - 게이트웨이는 동적인 콘텐츠를 생성하거나 데이터베이스에 질의를 보낼 수 있음.
- 애플리케이션 서버:
    - 게이트웨이의 가장 일반적인 형태로, 목적지 서버와 게이트웨이를 한개의 서버로 결합
        - 예: 클라이언트 ↔ 애플리케이션 서버(서버 ↔ 게이트웨이) ↔ 데이터베이스
    - HTTP를 통해 클라이언트와 통신하고, 서버 측 애플리케이션 프로그램에 연결하는 서버 측 게이트웨이
    - 애플리케이션 서버는 게이트웨이의 API(Application Programming Interface)를 통해 애플리케이션에 요청 전달

### 8.3.1 공용 게이트웨이 인터페이스

- 공용 게이트 웨이 인터페이스(Common Gateway Interface, CGI):
    - 특정 URL에 대한 HTTP 요청에 따라 프로그램 실행, 출력 수집, HTTP 응답 회신하는데 웹 서버가 사용하는 표준화된 인터페이스 집합
    - 애플리케이션 게이트웨이에서 유명했던 최초의 API
- 장점:
    - CGI 애플리케이션이 서버와 분리되면서 수많은 언어로 구현할 수 있게 됨
    - 단순하여 거의 모든 HTTP 서버가 지원
    - CGI 내부 처리는 사용자에게 보이지 않음
    - 거의 모든 리소스 형식과 서버의 접점에 있으면서 필요에 따라 어떤 변형도 처리해내는 단순한 기능 제공
    - 인터페이스는 문제가 많은 확장으로부터 서버를 보호
- 단점:
    - 모든 CGI 요청마다 새 프로세스를 만드는데 부하가 따름
    - CGI를 사용하는 서버는 성능을 제한하며 서버 장비에 부담을 줌
- 단점을 보완하여 Fast CGI를 개발.
    - CGI와 유사하지만 데몬으로 동작하여 요청마다 새 프로세스를 만들고 제거하면서 생기는 성능 저하 문제 해결

### 8.3.2 서버 확장 API

- 서버 자체 동작 변경이나 처리 능력을 끌어올리기 위해 서버 개발자는 자신의 모듈은 HTTP 와 직접 연결할 수 있는 강력한 인터페이스인 서버 확장 API를 제공함.
    - 이를 이용하여 자신의 코드를 서버와 연결하거나, 서버의 컴포넌트를 자신이 만든 것으로 교체 가능
- 유명 서버의 대부분은 확장 API를 제공하며, 개발자에게 매우 유용.

## 8.4 애플리케이션 인터페이스와 웹 서비스

- 데이터를 교환하는 두 애플리케이션 사이에서 프로토콜 인터페이스를 맞추는것은 까다로운 이슈
    - HTTP 헤더로는 표현하기 힘든 정보를 교환해야 할 수도 있음
    - HTTP를 확장하거나, HTTP 위에 프로토콜을 덧씌워 맞춤 정보를 교환(19장 참조)
- 웹 서비스(web services): 각 웹 애플리케이션이 서로 통신하는데 사용할 표준과 프로토콜 집합
    - 원래는 웹 서비스는 웹 애플리케이션 그 자체를 의미하지만, 이렇게 통용되게 됨
    - 여기서 말하는 웹 서비스는 애플리케이션이 정보를 공유하는데 사용하는 새로운 매커니즘 의미
- 웹 서비스는 SOAP를 통해 XML을 사용하여 정보 교환.
    - XML(eXtensible Markup Language): 데이터 객체를 담는 데이터를 생성하고 해석 방식 제공
    - SOAP(Simple Object Access Protocol): HTTP 메시지에 XML데이터를 담는 방식의 표준
    - 현대에는 SOAP대신 REST, XML대신 JSON을 많이 사용

## 8.5 터널

- 웹 터널(Web tunnel):
    - HTTP 프로토콜을 지원하지 않는 애플리케이션에서 HTTP 애플리케이션을 사용해 접근하는 방법 제공
    - HTTP 커넥션을 통해 HTTP 가 아닌 트래픽 전송 가능하고, 다른 프로토콜을 HTTP에 올릴 수 있음
- 일반적인 사용은 HTTP 커넥션에 HTTP가 아닌 트래픽을 얹기 위해서임
    - 웹 터널을 사용하면 웹 트래픽만 허락하는 방화벽이라도 HTTP가 아닌 트래픽 전송 가능

### 8.5.1 CONNECT로 HTTP 터널 커넥션 맺기

- 웹 터널은 HTTP의 `CONNECT` 메서드를 사용하여 커넥션을 맺음
- `CONNECT` 메서드는 터널 게이트웨이가 임의의 목적 서버와 포트에 TCP 커넥션을 맺고 클라이언트와 서버 간에 오는 데이터를 무조건 전달하기를 요청
- `CONNECT` 메서드를 이용한 SSL 터널 연결
    1. 클라이언트는 게이트웨이(터널 끝단)에 터널을 연결하려고 CONNECT 요청 전송
        - 클라이언트의 CONNECT 메서드는 TCP 커넥션을 위해 게이트웨이에 터널 연결 요청
    2. 게이트웨이는 서버와 443 포트로 TCP 커넥션을 연다 
    3. 서버와 게이트웨이의 커넥션 생성 완료
    4. 게이트웨이는 클라이언트에게 HTTP 200 Connection Established 응답을 전송하여 연결 됨을 알림
    5. 이 시점에 터널이 연결되어, 커넥션이 끊길 때까지 모든 데이터가 양방향으로 전달 됨

***CONNECT 요청***

- 시작줄을 제외하고 다른 HTTP 메서드와 동일.
    - 요청 URI는 호스트 명이 대신하며 콜론에 이어 포트 기술
    - 시작줄 다음에 다른 HTTP와 동일하게추가적인 HTTP 요청해더가 0+개 있음.
    - 각 행은 CRLF로 끝나고, 해더의 목록의 끝은 빈줄의 CRLF로 끝남

```
CONNECT home.netscape.com:443 HTTP/1.0
User-agent: Mozilla/4.0
```

***CONNECT 응답***

- 일반 HTTP 메시지와 같이 200 응답 코드는 성공이며, 편의상 사유 구절은 'Connect Established' 로 기술
- 일반적인 HTTP 응답과 달리 `Content-Type` 헤더를 포함할 필요는 없음
    - 커넥션에 메시지 대신 바이트를 그대로 전달하기 떄문에 포함할 필요가 없음

```
HTTP/1.0 200 Connection Established
Proxy-agent: Netscape-Proxy/1.1
```

### 8.5.2 데이터 터널링, 시간, 커넥션 관리

- 터널을 통해 전달되는 데이터는 게이트웨이에서 볼 수 없으므로, 게이트웨이는 패킷의 순서, 흐름에 대한 가정 불가능.
- 터널이 일단 연결 되면, 데이터는 언제 어디로든 흘러가버릴 수 있음
    - 터널 양 끝단에서는 두 커넥션으로부터 언제든 패킷을 받도록 준비하고, 그 데이터를 즉시 전달해야 함.
    - 터널링된 프로토콜은 데이터 의존성을 포함하고 있거나, 터널의 한 쪽에서 입력받은 데이터를 무시할 수도 있기 때문
    - 터널의 한쪽 끝 단에서 데이터를 소비하지 않으면 터널의 다른 끝단의 데이터 생산자는 행(hang)에 걸리게 되어 교착상태가 일어남
- 클라이언트는 성능 향상을 위해 CONNECT 요청을 보낸 다음 응답 받기 전에 터널 데이터를 전송할 수 있음
    - 서버에 빨리 데이터를 보낼 수 있지만, 게이트웨이가 요청에 이어 데이터를 잘 처리할 수 있어야 가능
    - 특히 게이트웨이는 네트워크 I/O 요청이 헤더 데이터만을 반환할거라 가정할 수 없어, 게이트웨이는 커넥션이 맺어지는 대로 헤더를 포함해서 읽어들인 모든 데이터를 서버에 전송해야 함.
    - 요청 후 터널을 통해 데이터를 전송한 클라이언트는 인증요구(authentication challenge)나 200 외 응답이 왔을 때 요청 데이터를 다시 보낼 준비가 되어있어야 함
        - TCP 요청 패킷이 차지한 영역 외의 나머지 영역보다 더 큰 데이터를 파이프라인을 통해 전송하면 안됨.
        - 위 경우 게이트웨이가 파이프라인을 통해 모든 TCP 패킷을 받기 전에 커넥션을 었다면 클라이언트는 TCP 리셋을 일으킬 수 있음
        - TCP 리셋은 클라이언트가 게이트웨이에서 받은 응답을 잃어, 통신실패가 네트워크 에러인지 접근 제어나 인증요구 때문인지 알 수 없게 됨
- 터널 끝단의 어느 부분이든 커넥션이 끊어지면 그 끊어진 곳으로 부터 온 데이터는 반대편으로 전달 됨.
    - 그 뒤 커넥션이 끊어졌던 터널의 끝단 반대편의 커넥션도 프락시에 의해 끊어짐
    - 끊긴 한 쪽에 아직 전송하지 않은 데이터는 버려짐

### 8.5.3 SSL 터널링

- 웹 터널은 원래 방화벽을 통해 암호화된 SSL 트래픽을 전달하려고 개발됨
    - 과거에 강력한 보안을 위해 모든 트래픽이 패킷을 필터링하는 라우터와 프락시를 지나도록 함
    - SSL과 같은 암호화된 프로토콜은 정보가 암호화되어있어 낡은 방식의 프락시에서는 처리되지 않음
- 터널을 사용하면 SSL 트래픽을 HTTP 커넥션으로 전송해, HTTP만 허용하는 방화벽을 통과시킬 수 있음
    - HTTP에 터널링 기능이 추가됨. 암호화된 날(raw) 데이터담아 HTTP 채널을 통해 데이터 전송
- 터널은 비 HTTP 트래픽이 방화벽을 통과하게 해, 악의적인 트래픽이 들어오는 경로가 될 수 있음

### 8.5.4 SSL 터널링 vs HTTP/HTTPS 게이트웨이

- HTTPS 프로토콜(SSL 상의 HTTTP)는 다른 프로토콜과 같은 방식으로 게이트웨이 통과 가능
    - 원격 HTTPS 서버와 SSL 세션을 시작하는 게이트웨이(클라이언트 대신)를 두고 클라이언트측의HTTPS 트랜잭션 수행
    - 응답은 프락시가 받아 복호화한 후, HTTP를 통해 클라이언트로 전송
- 이 방식은 단점이 있음
    - 클라이언트-게이트웨이 사이에는 보안 미적용된 HTTP 커넥션이 맺어짐
    - 프띿시가 인증을 담당하므로, 클라이언트는 원격 서버에 SSL 클라이언트 인증을 할 수 없음
    - 게이트웨이는 SSL을 완벽히 지원해야 함
- 이 경우에 SSL 터널링을 사용하면, 프락시에 SSL을 구현할 필요가 없음.
    - SSL 세션은 클라이언트가 생성한 요청과 목적지(보안이 적용된) 웹 서버간에 생성됨
    - 프락시 서버는 트랜잯션의 보안에 관여하지않고 암호화된 데이터를 그대로 터널링

### 8.5.5 터널 인증

- HTTP의 다른 기능들은 터널과 함께 사용 가능. 특히 프락시 인증 기능은 클라이언트의 터널 사용 권한 검사용으로 사용 가능
    1. 클라이언트 → 게이트웨이 : CONNECT 요청 전송
    2. 게이트웨이 → 클라이언트 : 인증요구 반환
    3. 클라이언트 → 게이트웨이: 적절한 인증과 함께 CONNECT 요청 전송
    4. 게이트웨이 → 서버: 443 포트로 TCP 커넥션 열기
    5. 서버 → 게이트웨이: 커넥션이 맺어짐
    6. 게이트웨이 → 클라이언트: HTTP 커넥션 준비 메시지 반환

### 8.5.6 터널 보안에 대한 고려사항들

- 터널 게이트웨이는 통신하고 있는 프로토콜이 터널을 올바른 용도로 사용하는지 검증 불가.
- 터널 오용을 최소화 하기 위해 게이트웨이는 HTTPS 전용 포트인 443과 같이 잘 알려진 특정 포트만 터널링 하도록 허용해야 함

## 8.6 릴레이

- HTTP 릴레이: HTTP 명세를 완전히 준수하지는 않는 간단한 HTTP 프락시
    - 컨넥션을 맺기 위한 HTTP 통신 후 바이트를 맹목적으로 전달
    - HTTP는 복잡하므로 구현이 쉬운 이 방식이 더 유용할 때가 있음.
    - 단순 필터링, 진단, 콘텐츠 변환용으로 사용되기도 하지만 잠재적 상호 운용문제를 갖고 있으므로 주의해서 배포해야 함
- 맹목적 릴레이(blind relay) 구현 시 Connection 헤더 처리를 못해서 keep-alive 커넥션이 행(hang)에 걸리는 일반적이고 악명 높은 문제가 있음
    1. 웹 클라이언트는 `Connection: Keep-Alive` 헤더를 보내 릴레이에 keep-alive 커넥션을 맺기 원한다는 내용의 요청 메시지 전송 후 응답 대기
    2. 릴레이는 요청을 받았지만 이해하지 못하므로 서버에 바로 넘김. 
        - 하지만 Connection 헤더는 홉과 홉(hop-by-hop)에만 사용되는 헤더이므로, 단일 전송 링크만 지원하고 체인에 따라 전달 불가.
    3. 웹 서버에 요청이 도착하고, 일반적인 클라이언트-서버 처럼 keep-alive 하겠다는 잘못된 결론을 내려 `Connection: Keep-Alive` 응답 헤더 반환
        - 이 시점에서 웹 서버는 릴레이와 함께 keep-alive 통신을 하고 그 규칙에 맞게 동작함. 하지만 릴레이는 아무것도 모름
    4. 릴레이는 웹 서버로부터 받은 응답을 클라이언트에게 전달
    5. 클라이언트는 응답을 통해 릴레이가 keep-alive 통신을 동의했다고 판단. 
    6. 릴레이는 keep-alive에 대해 모르므로, 원 서버가 커넥션을 끊기를 기다리며 받은 데이터를 전부 클라이언트에 전달
        - 하지만 원 서버는 계속 커넥션을 맺도록 요청했다고 판단하여 끊지 않음
        - 릴레이는 커넥션이 끊기기를 기다리며 계속 커넥션을 맺고 있는 행(hang)상태에 있음
    7. 클라이언트는 응답 메시지를 받으면 바로 다음 요청을 keep-alive 커넥션을 통해 릴레이에 전송. 하지만 릴레이는 같은 커넥션으로 또 다른 요청이 오는 것을 예측하지 못함
        - 브라우저는 돌고 있지만 아무 작업도 진행되지 않음
- 위를 예방하기 위해, 릴레이를 약간 더 똑똑하게 만드는 방법이 있지만, 상호 운용 문제가 발생할 가능성 있음
- 신중히 고민해봐야하며, 여러 문제 예방을 위헤 HTTP를 제대로 준수하는 프락시 사용을 권장