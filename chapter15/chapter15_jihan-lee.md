# HTTP 완벽가이드 정리
## 15장 엔터티와 인코딩
### 15.1 메시지는 컨테이너, 엔터티는 화물

```Plain
HTTP/1.0 200 OK
Server: Netscape-Enterprise/3.6
Date: Sun, 17 Sep 2000 00:01:05 GMT
// 엔터티
Content-type: text/plain            // 엔터티 헤더
Content-length: 18                  // 엔터티 헤더
                                    // CRLF
Hi! I'm a message!                  // 엔터티 본문
```

다음은 10가지 주요 엔터티 헤더 필드이다.

* **Content-Type**   
  엔터티에 의해 전달된 객체의 종류

* **Content-Length**   
  전달되는 메시지의 길이나 크기   

* **Content-Language**   
  전달되는 객체와 가장 잘 대응되는 자연어   

* **Content-Encoding**   
  객체 데이터에 대해 행해진 변형(압축 등)   

* **Content-Location**   
  요청 시점을 기준으로, 객체의 또 다른 위치   

* **Content-Range**   
  엔터티가 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의   

* **Content-MD5**   
  엔터티 본문의 콘텐츠에 의한 체크섬   

* **Last-Modified**   
  서버에서 이 콘텐츠가 생성 혹은 수정된 날   

* **Expires**   
  엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각   

* **Allow**   
  이 리소스에 대해 어떤 요청 메소드가 허용되는지   

* **ETag**   
  이 인스턴스에 대한 고유한 검사기. ETag 헤더는 엔터티 헤더로 정의되어 있지는 않지만   
  엔터티와 관련된 많은 동작을 위해 중요한 헤더   

* **Cache-Control**   
  어떻게 이 문서가 캐시될 수 있는지에 대한 지시자. Cache-Control도 엔터티 헤더로 정의되어 있지는 않음

#### 15.1.1 엔터티 본문

엔터티 본문은 가공되지 않은 날 데이터에 불과하기 때문에 엔터티 헤더는 그 데이터의 의미에 대해   
설명해주어야 한다.   

예를 들어, Content-Type 헤더는 데이터(이미지, 텍스트)를 어떻게 해석해야 하는지를 말해주며   
Content-Encoding 헤더는 데이터가 압축되었거나 또는 추가적인 인코딩이 되었는지 알려준다.

---

### 15.2 Content-Length: 엔터티의 길이

> 엔터티 본문의 크기를 바이트 단위로 나타낸다.   

* 메시지를 청크 인코딩으로 전송하지 않는 이상, **엔터티 본문이 있는 메시지에서는 필수적**이어야 한다.   
* **서버 충돌로 인한 메시지 잘림** 및 **지속 커넥션을 공유하는 메시지를 분할** 할 때 필요하다.

#### 15.2.1 잘림 검출

* 메시지 잘림은 캐싱 프락시 서버에서 특히 취약   
* 캐싱 프락시 서버는 명시적으로 Content-Length 헤더를 갖고 있지 않은 HTTP 본문은 캐시하지 않음

#### 15.2.2 잘못된 Content-Length

* HTTP/1.1 사용자 에이전트는 잘못된 길이를 받고 그 사실을 인지했을 때 사용자에게 알려주게 되어있다.

#### 15.2.3 Content-Length와 지속 커넥션(Persistent Connection)

* Content-Length 헤더는 클라이언트에게 메시지 하나가 어디서 끝나고 다음 시작이 어디인지 알려준다.

#### 15.2.4 콘텐츠 인코딩

* 엔터티 본문이 인코딩 되었다면 Content-Length 헤더의 길이는 인코딩된 본문의 길이를 바위트 단위로 정의한다.

#### 15.2.5 엔터티 본문 길이 판별을 위한 규칙

다음은 엔터티 본문의 길이와 끝나는 위치를 바르게 판별하는 상황별 규칙들이다.   
규칙들은 반드시 나열된 순서대로 적용되어야 한다.   

1. 본문이 허용되지 않는 특정 타입의 HTTP 메시지에서는, 본문 계산을 위한 ```Content-Length 헤더가 무시```된다.   
2. 메시지가 Transfer-Encoding 헤더를 포함하고 있다면, 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상   
   엔터티는 ```'0 바이트 청크'```라 불리는 특별한 패턴으로 끝나야 한다.
3. **Content-Length 헤더와 Transfer-Encoding 헤더**를 갖고 있는 메시지를 받았다면,   
   반드시 ```Content-Length를 무시```해야 한다. 이유는 전송 인코딩은 엔터티 본문을 표현하고 전송하는 방식을   
   바꿀 것이기 때문이다.
4. 위의 어떤 규칙에도 해당되지 않으면, 엔터티는 커넥션이 닫힐 때 끝난다.
5. 엔터티 본문을 갖고 있는 HTTP/1.1 요청은 반드시 유효한 Content-Length 헤더도 갖고 있어야 한다.

---

### 15.3 엔터티 요약

* 최초 엔터티가 생성될 때 송신자는 **데이터에 대한 체크섬**을 생성할 수 있으며, 수신자는 모든 의도하지 않은   
  엔터티의 변경을 잡기 위해 그 **체크섬으로 기본적인 검사**를 함   
* Content-MD5 헤더는 서버가 엔터티 본문에 MD5 알고리즘을 적용한 결과를 보내기 위해 사용   

---

### 15.4 미디어 타입과 차셋(Charset)

> Content-Type 헤더는 **엔터티 본문의 MIME 타입**을 기술한다.

Content-Type의 값은 인터넷 할당 번호 관리기관(Internet Assigned Numbers Authority, IANA)에   
등록된 표준화된 MIME 타입이다.

* Content-Type 헤더는 원본 엔터티 본문의 미디어 타입을 명시한다.
* 인코딩을 한 후라도, Content-Type 헤더는 여전히 인코딩 전의 본문 유형이다.

#### 15.4.1 텍스트 매체를 위한 문자 인코딩

내용 유형을 더 자세히 지정하기 위한 선택적인 매개변수도 지원

```
Content-Type: text/html; charset=iso-8859-4
```

'charset'이 대표적인 예이다.

#### 15.4.2 멀티파트 미디어 타입

HTTP는 멀티파트 본문도 지원한다. 그러나 일반적으로 폼을 채워서 제출할 때, 문서의 일부분을 실어   
나르는 범위 응답을 할 때의 두 경우만 사용된다.

#### 15.4.3 멀티파트 폼 제출

멀티파트 본문은 여러 다른 종류와 길이의 값으로 채워진 폼을 허용한다.   

```
Content-Type: multipart/form-data; boundary=[abcdefghijklmnopqrstuvwxyz]
```

이때, boundary는 본문의 서로 다른 부분을 구분하기 위한 구분자로 쓰인다.

#### 15.4.4 멀티파트 범위 응답

범위 요청에 대한 HTTP 응답 또한 멀티파트가 될 수도 있다.   
Content-Type:multipart/byteranges 헤더 및 각각 다른 범위를 담고 있는 멀티파트 본문이 함께 온다.

---

### 15.5 콘텐츠 인코딩

#### 15.5.1 콘텐츠의 인코딩 과정

1. 웹 서버가 원본 Content-Type과 Content-Length 헤더를 수반한 응답 메시지를 생성   
2. 콘텐츠 인코딩 서버가 인코딩된 메시지를 생성한다. 인코딩된 메시지는 Content-Type은 같지만   
   **Content-Length는 다르다**. 서버는 **Content-Encoding 헤더**를 인코딩된 메시지에 추가하여,   
   수신 측 애플리케이션이 그것을 디코딩 할 수 있도록 한다.   
3. 수신 측 프로그램은 인코딩된 메시지를 받아서 디코딩하고 원본을 얻는다.

다음은 인코딩된 응답의 예를 보여준다.

```
HTTP/1.1 200 OK
Date: Sun, 17 Jan 2021 18:32:11 GMT
Server: Apache/1.2.4
Content-Length: 6096
Content-Type: image/gif
Content-Encoding: gzip
[...]
```

#### 15.5.2 콘텐츠 인코딩 유형

콘텐츠 인코딩 값|설명
:---|:---
gzip|엔터티에 GNU zip 인코딩 적용
compress|엔터티에 유닉스 파일 압축 프로그램인 'compress'가 적용
deflate|엔터티에 zlib 포맷으로 압축
identity|엔터티에 어떤 인코딩도 수행되지않음. 헤더가 존재하지 않으면 이 값으로 간주

위의 인코딩은 대부분 전송되는 메시지의 크기를 정보의 손실 없이 줄이기 위한 무손실 압축 알고리즘이다.   
gzip이 일반적으로 효율적이고 가장 널리 쓰인다.

#### 15.5.3 Accept-Encoding 헤더

클라이언트가 지원하지 않는 인코딩을 사용하는 것을 막기 위해, 클라이언트는 자신이 지원하는 인코딩의 목록을   
Accept-Encoding 요청 헤더를 통해 전달한다.

```
Accept-Encoding: *                  // 모두 가능
Accept-Encoding: compress, gzip     // 2개 가능
Accept-Encoding: compress;q=0.5, gzip;q=1.0     // 선호도 추가표현
```

q는 선호도를 나타내는데 0.0(가장 원치않음) ~ 1.0(가장 선호함)의 범위가 존재한다.

---

### 15.6 전송 인코딩과 청크 인코딩

#### 15.6.1 안전한 전송

전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 **안전한 전송**을 위해 존재했다.   
HTTP에서 전송된 메시지의 본문이 문제를 일으키는 경우 중 두 가지를 들면 다음과 같다.

* **알 수 없는 크기**   
* **보안**   

#### 15.6.2 Transfer-Encoding 헤더

전송 인코딩 제어 및 서술하기 위해 정의된 헤더는 다음과 같다.

* **Transfer-Encoding**   
  안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려준다.   

* **TE**   
  어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 사용한다.   

```
GET /new_products.html HTTP/1.1
Host: www.joes-hardware.com
User-Agent: Mozilla/4.61 [en] (WinNT; I)
TE: trailers, chunked
```

```
HTTP/1.1 200 OK
Transfer-Encoding: chunked
Server: Apache/3.0
```

#### 15.6.3 청크 인코딩

청크 인코딩은 메시지를 일정 크기의 청크 여럿으로 쪼갠다.   
서버는 각 청크를 순차적으로 보낸다.

* **청크와 지속 커넥션**   
  지속 커넥션에서는, 본문을 쓰기 전에 반드시 Content-Length 헤더에 본문의 길이를 담아 보내야 한다.   
  콘텐츠가 서버에서 동적으로 생성되는 경우에는, 보내기 전에 본문의 길이를 알아내는 것이 불가능하다.   
       
  청크 인코딩은 서버가 본문을 여러 청크로 쪼개 보낼 수 있게 해줌으로써 이 딜레마에 대한 해법을 제공한다.   
     
  다음은 청크 분할 응답 이다.
  ```
  HTTP/1.1 200 OK
  Content-Type: text/plain
  Transfer-Encoding: chunked
  7\r\n
  Mozilla\r\n
  9\r\n
  Developer\r\n
  7\r\n
  Network\r\n
  0\r\n
  \r\n
  ```
     
  참고 : https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Transfer-Encoding
   
* **청크 인코딩된 메시지의 트레일러**   
  다음 중 하나 이상의 조건을 만족하면 청크 메시지에 트레일러를 추가할 수 있다.  

  * 클라이언트의 TE 헤더가 트레일러를 받아들일 수 있음   
  * 트레일러가 응답을 만든 서버에 의해 추가됐고, 그 트레일러의 콘텐츠는 클라이언트가 이해하고 사용할   
    필요가 없는 선택적 메타데이터일 경우   
   
  트레일러로 보낼 수 있는 헤더의 예로는 Content-MD5 헤더가 있다.   
  Transfer-Encoding, Trailer, Content-Length를 제외한 어떤 HTTP 헤더도 트레일러로 보낼 수 있다.

#### 15.6.4 콘텐츠와 전송 인코딩의 조합

콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다.

#### 15.6.5 전송 인코딩 규칙

전송 인코딩이 메시지 본문에 적용될 때, 몇 가지 규칙이 적용되어야 한다.

* 전송 인코딩의 집합은 반드시 'chunked'를 포함   
* 청크 전송 인코딩이 사용되었다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야함
* 청크 전송 인코딩은 반드시 본문에 한 번 이상 적용되어야 함

---

### 15.7 시간에 따라 바뀌는 인스턴스

웹 객체는 정적이지 않다. 같은 URL은 시간에 따라 다른 버전의 객체를 가리킬 수 있다.   

HTTP 프로토콜은 어떤 특정한 종류의 요청이나 응답을 다루는 방법들을 정의하는데,   
이것은 **인스턴스 조작(instance manipluation)** 이라 불리며 객체의 인스턴스에 작용한다.

대표적인 두 방법이 ```범위 요청```과 ```델타 인코딩```이다.

---

### 15.8 검사기와 신선도

#### 15.8.1 신선도

서버는 Expires나 Cache-Control 헤더를 통해 클라이언트에게 캐시의 신선도 판단 정보를 제공한다.   

Expires의 경우 시계가 반드시 동기화 되어있을 때만 정확한 결과를 기대할 수 있다.   
그러나, 항상 쉽지는 않다. 따라서 절대적인 시간보다는 상대시간을 이요해 만료를 정의하는   
메커니즘이 더 쓸만하다.   

**Cache-Control 헤더**는 문서의 최대 수명을 문서가 **서버를 떠난 후로부터의 총 시간을 초 단위**로 정한다.   

수명은 시계 동기화에 의존하지 않으므로 더 정확한 결과를 말해줄 수 있다.

> 💡 Cache-Control 헤더 지시자 종류는 책 p.416 참고

#### 15.8.2 조건부 요청과 검사기

HTTP는 클라이언트에게 **리소스가 바뀐 경우에만 사본을 요청**하는 **조건부 요청 방법**을 제공한다.   
평범함 HTTP 요청이지만, 특정 조건이 참일 때에만 수행된다.   

조건부 요청은 ```'If-'```로 시작하는 조건부 헤더에 의해 구현된다.   
   
각 조건부 요청은 특정 검사기 위에서 동작한다.   
검사기는 문서의 테스트된 특정 속성이다. 개념적으로, 일련변호나 버전 번호 혹은 무서의 최종 변경일과   
같은 검사기이다.   
   
If-Modified-Since 헤더는 문서 인스턴스의 마지막 수정된 날짜를 검사하므로,   
마지막 수정 날짜를 검사기라고 말할 수 있다.
   
다음은 각 조건부 헤더와 그 유형에 사용되는 검사기이다.

요청 유형|검사기|설명
:---|:---|:---
If-Modified-Since|Last-Modified|지난 Last-modified 응답 헤더에 들어있었던 시각에 마지막으로 수정된<br>버전이 더 이상 최신 버전이 아니라면, 그 리소스의 사본을 보내라.
If-Unmodified-Since|Last-Modified|지난 Last-modified 응답 헤더에 들어있었던 시각에 마지막으로 수정된<br>버전에서 변한 것이 없다면, 그 리소스의 사본을 보내라.
If-Match|ETag|지난 ETag 응답 헤더에 들어있던 것과 엔터티 태그가 같다면, 그 리소스의 사본을 보내라.
If-None-Match|ETag|지난 ETag 응답 헤더에 들어있던 것과 엔터티 태그가 다르다면, 그 리소스의 사본을 보내라.

검사기는 약한 검사기와 강한 검사기 두 가지로 분류된다.   

* 약한 검사기
  * 리소스의 인스턴스를 고유하게 식별하지 못하는 경우가 있음
  * 객체의 바이트 단위의 크기는 콘텐츠 크기가 같더라도 내용이 다를 수 있다.
* 강한 검사기
  * 언제나 고유하게 식별한다.
  * 리소스의 콘텐츠에 대한 암호 체크섬(MD5같은)

```
GET /announce.html HTTP/1.1
If-None-Match: W/"v4.0"
```

위의 예는 클라이언트가 약한 엔터티 태그를 사용해서 서버와 재검사 한다.   
서버는 콘텐츠가 문서 버전 4.0 이후로 의미있는 변경이 있었을 때만 본문을 반환한다.

---

### 15.9 범위 요청

다운로드를 받다가 네트워크의 문제로 실패했을 경우, 범위 요청을 이용하여 특정 범위 이후부터   
데이터 요청을 할 수 있다.

```
GET /bigfile.html HTTP/1.1
Host: www.joes-hardware.com
Range: bytes=4000-
```
클라이언트는 처음 4000 바이트 이후의 부분을 요청하는 예 이다.

모든 서버가 범위 요청을 받아들일 수 있는 것은 아니지만 대부분의 많은 경우 가능하다.   
응답에 **Accept-Ragne** 헤더를 포함시키는 방법으로 알려줄 수 있다.   
```
HTTP/1.1. 200 OK
Date: Sun, 17 Jan 2021 20:00 GMT
Server: Apache/1.2.4
Accept-Ranges: bytes
```

---

### 15.10 델타 인코딩

> 객체 전체가 아닌 변경된 부분에 대해서만 통신하여 전송량을 최적화하는, HTTP 프로토콜의 확장

아래는 델타 인코딩의 문서 요청, 생성, 적용에 대한 메커니즘이다.   

1. 클라이언트는 서버에게 페이지를 요청한다.   
   ```
   GET /bigfile.html HTTP/1.1
   Date: Sun, 17 Jan 2021 20:15:00 GMT
   ```
      
2. 서버는 요청에 대한 응답 메시지를 보낸다.
   ```
   HTTP/1.1 200 OK
   Content-type: text/html
   Expires: Sur, 17 Jan 2021 21:00:00 GMT
   ETag: abcdefghijk
   ...
   ```
      
3. 응답을 받아서 캐시 후, 다음날 같은 페이지로 접근을 했지만 캐시된 사본이 만료되어 서버에게 재요청한다.   
   이미 캐시된 사본이 있으므로 델타를 받아들이겠다는 의사를 밝히는 ```델타 요청 메시지```를 보낸다.   
   * If-None-Match에 식별자인 ETag값   
   * A-IM 헤더 -> 인스턴스 조작의 종류 명시, 델타 알고리즘 정보  
   ```
   GET /bigfile.html HTTP/1.1
   If-None-Match: abcdefghijk
   A-IM: diffe
   Date: Mon, 18 Jan 2021 09:15:00 GMT
   ```
      
4. 서버는 델타 응답 메시지를 보내준다.   
   * 특별한 응답 코드(226 IM Used)   
   * 델타 알고리즘 IM 헤더   
   * 새 ETag 헤더   
   * 델타를 계산한 기반 문서의 ETag값인 Delta-Base 헤더   
   ```
   HTTP/1.1 226 IM Used
   IM: diffe
   ETag: hijklmnop
   Delta-base: abcdefghijk
   ...
   ```
      
5. 클라이언트는 델타 메시지를 받고 페이지의 캐시된 버전에 적용하여 최신 버전을 생성한다.

#### 15.10.1 인스턴스 조작, 델타 생성기 그리고 델타 적용기

* 클라이언트는 A-IM 헤더를 사용해서 자신이 받아들일 수 있는 인스턴스 조작의 종류를 명시   
* 서버는 IM 헤더에 사용한 인스턴스 조작의 종류를 명시

다음의 표는 IANA에 등록된 인스턴스 조작의 종류를 몇 가지 나열한다.   

종류|설명
:---|:---
vcdiff|vcdiff 알고리즘을 이용한 델타
diffe|유닉스 diff -e 명령을 이용한 델타
gdiff|gdiff 알고리즘을 이용한 델타
gzip|gzip 알고리즘을 이용한 압축
deflate|deflate 알고리즘을 이용한 압축
range|현재 응답이 범위 선택에 대한 결과인 부분 콘텐츠 임을 말해주기 위해 서버 응답에서 사용
identity|클라이언트가 identity 인스턴스 조작을 받아들일 의사가 있음을 말해주기 위해 클라이언트 요청의<br>A-IM 헤더에서 사용

> 💡 책의 표 15-6 **'identit'** 오타 있음 [IANA 인스턴스 조작 종류](https://www.iana.org/assignments/inst-man-values/inst-man-values.xhtml#inst-man-values-1)
