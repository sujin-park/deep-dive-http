# 15. 엔터티와 인코딩

* HTTP는 메시지가 올바르게 수송, 식별과 추출 및 처리되는 것을 보장한다.
  * 객체는 올바르게 식별되므로(`Content-Type` 미디어 포맷과 `Content-Language` 헤더를 이용해서) 브라우저나 다른 클라이언트는 콘텐츠를 바르게 처리할 수 있다.
  * 객체는 올바르게 압축이 풀릴 것이다(`Content-Length`와 `Content-Encoding` 헤더를 이용해서).
  * 객체는 항상 최신이다(엔터티 검사기와 캐시 만료 제어를 이용해서).
  * 사용자의 요구를 만족할 것이다(내용 협상을 위한 Accept 관련 헤더들에 기반하여).
  * 네트워크 사이를 빠르고 효율적으로 이동할 것이다(범위 요청, 델타 인코딩, 그 외 데이터 압축을 이용해서).
  * 조작되지 않고 온전하게 도착할 것이다(전송 인코딩 헤더와 `Content-MD5` 체크섬을 이용해서).
* 이 모든 것을 가능하게 하려고 HTTP는 콘텐츠를 나르기 위한 잘 라벨링된 엔터티를 사용한다.
* 이 장에서 다루는 내용
  * HTTP 데이터를 담는 컨테이너인 HTTP 메시지 엔터티의 포맷과 동작 방식
  * 어떻게 HTTP가 엔터티 본문의 크기를 기술하며, 크기를 측정하기 위해 HTTP가 무엇을 요구하는지
  * 클라이언트가 콘텐츠를 바르게 처리할 수 있도록 제공되는 엔터티 헤더들(콘텐츠의 포맷, 문자, 언어를 기술하기 위해 사용된다)
  * 공간을 적게 차지하고 더 안전하게 만들기 위해 발송자가 콘텐츠 데이터 포맷을 변형할 때 사용하는 디코딩 가능한 콘텐츠 인코딩
  * 특정 종류의 콘텐츠 송수신을 개선하기 위해 HTTP가 데이터를 실어 나르는 방식을 수정하는 전송 인코딩. 그중에서도 길이를 알 수 없는 콘텐츠를 안전하게 전송하기 위해 데이터를 여러 조각으로 쪼개 전달하는 청크 인코딩
  * 클라이언트가 요청한 콘텐츠의 최신 버전을 가져올 수 있도록 도와주는 태그, 라벨, 시간, 체크섬의 모음
  * 콘텐츠의 버전 번호처럼 동작하는 검사기들(웹 애플리케이션에게 그들이 최신 콘텐츠를 가지고 있음을 확신할 수 있게 해준다). 그리고 객체를 최신으로 유지하기 위해 설계된 HTTP 헤더 필드
  * 중단되었던 다운로드를 중단된 지점에서부터 재개하고자 할 때 유용한 범위 요청
  * 클라이언트가 전에 본 적이 있었던 웹 페이지를 다시 볼 때, 그때 이후로 변경이 있는 부분만 요청할 수 있게 해주는 HTTP 델타 인코딩 확장
  * 엔터티 콘텐츠가 프락시를 지나는 과정에서 변경된 곳이 있지 않은지 탐지하기 위해 사용하는 엔터티 본문의 체크섬

## 15.1 메시지는 컨테이너, 엔터티는 화물

* HTTP 메시지를 인터넷 운송 시스템의 컨테이너라고 생각하면, HTTP 엔터티는 메시지의 실질적인 화물이다.
* 빈 줄(CRLF)은 헤더 필드와 본문의 시작을 나누고, HTTP 엔터티 헤더는 HTTP 메시지의 내용물을 설명한다.
* HTTP/1.1의 10가지 주요 엔터티 헤더 필드
  * `Content-Type`: 엔터티에 의해 전달된 객체 종류
  * `Content-Length`: 전달되는 메시지 길이나 크기
  * `Content-Language`: 전달되는 객체와 가장 잘 대응되는 자연어
  * `Content-Encoding`: 객체 데이터에 관해 행해진 변형(압축 등)
  * `Content-Location`: 요청 시점을 기준으로 객체의 또 다른 위치
  * `Content-Range`: 이 엔터티가 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의
  * `Content-MD5`: 엔터티 본문의 콘텐츠에 대한 체크섬.
  * `Last-Modified`: 서버에서 이 콘텐츠가 생성 혹은 수정된 날
  * `Expires`: 이 엔터티 데이터가 더 신선하지 않은 것으로 간주되기 시작하는 날짜와 시간
  * `Allow`: 이 리소스에 관해 어떤 요청 메서드가 허용되는지. 예) GET과 HEAD
  * `ETag`: 이 인스턴스에 대한 고유한 검사기. 엄밀히 말해 ETag 헤더는 엔터티 헤더로 정의되어 있진 않지만 엔터티와 관련된 많은 동작을 위해 중요한 헤더다.
  * `Cache-Control`: 어떻게 이 문서가 캐시될 수 있는지에 대한 지시자. ETag 헤더와 마찬가지로 엔터티 헤더로 정의되어 있지는 않다.

### 15.1.1 엔터티 본문

* 엔터티 본문은 가공되지 않은 데이터만을 담고 있다. 다른 정보는 모두 헤더에 담겨 있다.
  * 따라서 엔터티 헤더는 그 데이터의 의미에 관해 설명할 필요가 있다. `Content-Type` 엔터티 헤더는 우리에게 그 데이터(이미지, 텍스트 등)를 어떻게 해석해야 하는지 말해주며 `Content-Encoding` 엔터티 헤더는 그 데이터가 압축되었거나 추가적인 인코딩이 되었는지 알려준다.
* 엔터티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF 줄 바로 다음부터 시작한다.
  * 콘텐츠가 텍스트든 바이너리든, 문서든 이미지든, 압축 여부나 언어에도 상관없이 항상 CRLF 바로 다음에 위치한다.

## 15.2 Content-Length: 엔터티의 길이

* `Content-Length` 헤더는 메시지의 엔터티 본문 크기를 바이트 단위로 나타낸다. 인코딩에 상관없이 크기를 표현할 수 있다.
  * gzip로 압축된 텍스트 파일이라면 원래 크기가 아니라 압축 후 크기다.
* `Content-Length` 헤더는 메시지를 청크 인코딩으로 전송하지 않는 이상 엔터티 본문을 포함한 메시지에서 필수적으로 있어야 한다.
* `Content-Length`는 서버 충돌로 인해 메시지가 잘렸는지 감지하고자 할 때, 지속 커넥션을 공유하는 메시지를 올바르게 분할하고자 할 때 필요하다.

### 15.2.1 잘림 검출

* 옛날 버전 HTTP는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인지했다. 그러나 `Content-Length`가 없다면 클라이언트는 커넥션이 정상적으로 닫힌 것인지, 메시지 전송 중 서버에 충돌이 발생한 것인지 구분하지 못한다. 클라이언트에서 메시지 잘림 검출을 위해 `Content-Length`가 필요하다.
* 메시지 잘림은 캐싱 프락시 서버에서 특히 취약하다. 캐시가 잘린 메시지를 수신했으나 잘렸다는 것을 인식하지 못하면, 캐시는 결함이 있는 콘텐츠를 저장하고 계속 제공하게 된다.
  * 잘린 메시지를 캐시하는 위험을 줄이기 위해 캐싱 프락시 서버는 보통 명시적으로 `Content-Length` 헤더를 갖고 있지 않은 HTTP 본문은 캐시하지 않는다.

### 15.2.2 잘못된 Content-Length

* `Content-Length`가 잘못된 값을 갖고 있으면 아예 빠진 것보다 더 큰 피해를 유발할 수 있다.
* 초창기 클라이언트와 서버 중 일부는 `Content-Length`의 계산과 관련된 잘 알려진 버그가 있어서, 몇몇 클라이언트, 서버, 프락시는 서버가 이런 오작동을 했는지 탐지하고 교정을 시도한다.
* 공식적으로 HTTP/1.1 사용자 에이전트는 잘못된 길이를 받고 그 사실을 인지했을 때 사용자에게 알려주게 되어 있다.

### 15.2.3 Content-Length와 지속 커넥션(Persistent Connection)

* `Content-Length`는 지속 커넥션을 위해 필수다.
* 응답이 지속 커넥션을 통해 온 것이면, 또 다른 HTTP 응답이 즉시 그 뒤를 따른다.
* `Content-Length`헤더는 클라이언트에게 메시지 하나가 어디서 끝나고 그다음 시작은 어딘지 알려준다.
* 커넥션이 지속적이라, 클라이언트가 커넥션이 닫힌 위치를 근거로 메시지 끝을 인식하는 것은 불가능하다. `Content-Length` 헤더 없이는 어디까지가 엔터티 본문이고 어디서부터가 다음 메시지인지 알 수 없다.
* `Content-Length` 헤더 없는 지속 커넥션을 만날 수 있는 상황은 청크 인코딩을 사용할 때다.
  * 청크 인코딩은 데이터를 각각이 특정한 크기를 갖는 일련의 청크로 쪼개어 보낸다.
  * 서버가 헤더 생성 시점에서 엔터티 전체의 크기를 알 수 없어도(엔터티가 동적으로 생성되는 중일 수도 있으므로), 서버는 청크 인코딩을 이용해 엔터티를 잘 정의된 크기의 조각들로 전송할 수 있다.

### 15.2.4 콘텐츠 인코딩

* HTTP는 보안 강화나 압축을 통해 공간을 절약할 수 있도록 엔터티 본문을 인코딩할 수 있게 해준다.
* 본문 콘텐츠가 인코딩되어 있다면 `Content-Length` 헤더는 인코딩되어 있지 않은 원본의 길이가 아닌 인코딩된 본문의 길이를 바이트 단위로 정의한다.
* 어떤 HTTP 애플리케이션은 이를 잘못해서 인코딩 전의 크기를 보내기도 하는데, 이는 특히 지속 커넥션일 경우 심각한 오류를 유발한다.
* 불행히도 HTTP/1.1 명세에 서술된 어떤 헤더도 인코딩 되지 않은 원 본문의 길이를 보내기 위해 사용될 수 없는데, 이는 클라이언트가 자신이 수행한 디코딩 과정에 문제가 없는지 검증하기 어렵게 만든다.

### 15.2.5 엔터티 본문 길이 판별을 위한 규칙

* 다음은 엔터티 본문의 길이와 끝나는 위치를 바르게 판별하는 상황별 규칙으로, 반드시 이 순서대로 적용되어야 한다.
  1. 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP 메시지에서는, 본문 계산을 위한 `Content-Length` 헤더가 무시된다. `Content-Length`헤더는 부가 정보에 불과하며 실제 본문 길이를 서술하지 않는다. (안이하게 만든 HTTP 애플리케이션은 `Content-Length`가 언제나 본문이 있음을 의미한다고 가정하여 난감한 상황에 빠지기도 한다.)
      * 가장 중요한 예는 HEAD 응답으로, HEAD 메서드는 GET 요청을 보냈다면 받게될 응답에서 본문은 제외하고 헤더들만 보내라고 서버에 요청한다.
      * GET 응답은 `Content-Length` 헤더를 돌려주기 때문에 HEAD 응답 또한 그럴 것이다. 그러나 GET 응답과 달리 HEAD 응답은 본문이 없다.
      * `1XX`, `204`, `304` 응답 또한 정보성 `Content-Length`를 갖지만 본문이 없다.
      * 엔터티 본문을 금하는 메시지는 어떤 엔터티 헤더 필드가 존재하느냐와 상관없이 반드시 헤더 이후 첫 번째 빈 줄에서 끝나야 한다.
  2. 메시지가 `Transfer-Encoding` 헤더를 포함하고 있다면(기본 HTTP "identity" 인코딩과는 다른), 메시지가 커넥션이 닫혀 먼저 끝나지 않는 이상 엔터티는 '0바이트 청크'라 불리는 특별한 패턴으로 끝나야 한다.
  3. 메시지가 `Content-Length` 헤더를 갖는다면(그리고 메시지 유형이 엔터티 본문을 허용하면), `Transfer-Encoding` 헤더가 존재하지 않는 이상 `Content-Length` 값은 본문 길이를 담게 된다.
      * `Content-Length` 헤더 필드와 identity가 아닌 `Transfer-Encoding` 헤더 필드를 가진 메시지를 받았다면 반드시 `Content-Length` 헤더를 무시해야 한다. 전송 인코딩은 엔터티 본문을 표현하고 전송하는 방식(아마 전송된 바이트 크기도)을 바꿀 것이기 때문이다.
  4. 메시지가 `multipart/byteranges` 미디어 타입을 사용하고 엔터티 길이가 별도로 정의되지 않았다면(`Content-Length`헤더로), 멀티파트 메시지의 각 부분은 각자 스스로 크기를 정의한다.
      * 멀티파트 유형은 자신의 크기를 스스로 결정할 수 있는 유일한 엔터티 본문 유형이다.
      * 이 미디어 타입은 수신자가 이것을 해석할 수 있다는 사실을 송신자가 알기 전까지 절대로 보내지 말아야 한다.
  5. 위의 어떤 규칙에도 해당하지 않으면, 엔터티는 커넥션이 닫힐 때 끝난다. 실질적으로 오직 서버만이 메시지가 끝났음을 알리기 위해 커넥션을 닫을 수 있다.
      * 클라이언트는 클라이언트 메시지가 끝났다는 신호를 위해 커넥션을 닫을 수 없다. 커넥션을 닫아버리면 서버가 응답을 돌려줄 방법이 없기 때문이다.
  6. HTTP/1.0 애플리케이션과의 호환을 위해 엔터티 본문을 가진 HTTP/1.1 요청은 반드시 유효한 `Content-Length` 헤더도 갖고 있어야 한다.(서버가 HTTP/1.1과 호환된다고 알려지지 않았다면)
      * HTTP/1.1 명세는 요청에 본문은 있으나 `Content-Length` 헤더는 없는 경우, 메시지 길이 판별을 할 수 없다면 `400 Bad Request` 응답을 보내고, 유효한 `Content-Length`를 요구하고 싶다면 `411 Length Required` 응답을 보내라고 조언한다.

## 15.3 엔터티 요약

* HTTP가 일반적으로 TCP/IP와 같이 신뢰할 수 있는 전송 프로토콜 위에서 구현됨에도 불구하고, 불완전한 트랜스코딩 프락시나 버그 많은 중개자 프락시를 비롯한 여러 이유로 메시지 일부분이 전송 중 변형되기도 한다.
* 엔터티 본문 데이터에 대한 의도치 않은 변경을 감지하기 위해, 최초 엔터티가 생성될 때 송신자는 데이터에 대한 체크섬을 생성할 수 있으며, 수신자는 모든 의도치 않은 엔터티 변경을 잡아내기 위해 그 체크섬으로 기본적 검사를 할 수 있다.
* `Content-MD5` 헤더는 서버가 엔터티 본문에 MD5 알고리즘을 적용한 결과를 보내기 위해 사용된다. 오직 응답을 처음 만든 서버만이 이 헤더를 계산해서 보낸다.
  * 중간의 프락시와 캐시는 그 헤더를 변경하거나 추가하지 않는다. 종단 간(end-to-end) 무결성 검정 목적을 손상시킬 것이기 때문이다.
* `Content-MD5` 헤더는 콘텐츠 인코딩의 적용은 끝났지만 전송 인코딩은 아직 적용하지 않는 엔터티 본문에 대한 MD5를 담고 있다.
* 메시지 무결성을 검증하려는 클라이언트는 먼저 전송 인코딩을 디코딩한 뒤, 그 디코딩 된 엔터티 본문에 관해 MD5를 계산해야 한다.
  * 어떤 문서를 gzip 알고리즘으로 압축하여 청크 인코딩으로 보냈다면, MD5 알고리즘은 압축된 본문 전체에 관해 수행된다.
* MD5는 문서의 위치를 빠르게 알아내고 콘텐츠 중복 저장을 방지하기 위한 해시 테이블의 키로 이용될 수 있다. 이런 활용 가치에도 불구하고 `Content-MD5` 헤더는 그다지 자주 전송되지 않는다.
* HTTP 확장들은 IETF 초안으로 다른 요약 알고리즘들을 제안했다.
  * 이 확장들은 클라이언트가 응답에 관해 기대하는 요약 유형을 정의할 수 있는 새 헤더인 `Want-Digest`를 제안했다.
  * 이 헤더에 품질값(quality value)을 이용해 여러 요약 알고리즘을 제안하고 각각 선호도를 지정할 수 있다.

## 15.4 미디어 타입과 차셋(Charset)

* `Content-Type` 헤더 필드는 엔터티 본문의 MIME 타입을 기술한다.
* MIME 타입은 전달되는 데이터 매체의 기저 형식(HTML, MS word, MPEG 비디오 등)의 표준화된 이름이다.
* 클라이언트 애플리케이션은 콘텐츠를 적절히 해독하고 처리하기 위해 MIME 타입을 이용한다.
* `Content-Type` 값은 인터넷 할당 번호 관리기관(Internet Assigned Numbers Authority, IANA)에 등록된 표준화된 MIME 타입이다.
  * MIME 타입은 주 미디어 타입(텍스트, 이미지, 오디오 등)으로 시작해서 뒤이어 빗금(/), 미디어 타입을 더 구체적으로 서술하는 부 타입(subtype)으로 구성된다.
* 흔히 쓰이는 MIME 타입
  * `text/html`, `text/plain`, `image/gif`, `image/jpeg`, `audio/x-wav`, `model/vrml`, `application/vnd.ms-powerpoint`, `multipart/byteranges`, `message/http`
* `Content-Type` 헤더가 원본 엔터티 본문의 미디어 타입을 명시한다는 것은 중요하다. 엔터티가 콘텐츠 인코딩을 거친 경우에도 `Content-Type` 헤더는 여전히 인코딩 전의 엔터티 본문 유형을 명시할 것이다.

### 15.4.1 텍스트 매체를 위한 문자 인코딩

* `Content-Type` 헤더는 내용 유형을 더 자세히 지정하기 위한 선택적 매개변수도 지원한다.
* 엔터티의 비트 집합을 텍스트 파일의 글자로 변환하기 위한 `charset` 매개변수가 대표적이다.
  ```
  Content-Type: text/html; charset=iso-8859-4
  ```

### 15.4.2 멀티파트 미디어 타입

* MIME "멀티파트" 이메일 메시지는 서로 붙어있는 여러 개 메시지를 포함하며, 하나의 복합 메시지로 보내진다.
* 각 구성 요소는 자족적으로 자신에 관해 서술하는 헤더를 포함한다. 여러 구성요소가 이어져 있고 문자열 하나로 서로의 경계가 식별된다.
* HTTP는 멀티파트 본문도 지원한다. 그러나 일반적으로 폼을 채워 제출할 때와 문서 일부분을 실어 나르는 범위 응답을 할 때 두 가지 경우에만 사용된다.

### 15.4.3 멀티파트 폼 제출

* HTTP 폼을 채워 제출하면, 가변 길이 텍스트 필드와 업로드 될 객체는 각각 멀티파트 본문을 구성하는 하나의 파트가 되어 보내진다.
* 멀티파트 본문은 여러 다른 종류와 길이의 값으로 채워진 폼을 허용한다.
* HTTP는 다음과 같이 그런 요청을 `Content-Type: multipart/form-data`나 `Content-Type: multipart/mixed` 헤더에 멀티파트 본문을 함께 보낸다.
  ```
  Content-Type: multipart/form-data; boundary=[abcdefghijklmnopqrstuvwxyz]
  ```
  * 이때 boundary는 본문의 서로 다른 부분을 구분하기 위한 구분자로 쓰인다.

### 15.4.4 멀티파트 범위 응답

* 범위 요청에 대한 HTTP 응답 또한 멀티파트가 될 수도 있다. 그런 응답은 `Content-Type: multipart/byteranges` 헤더 및 각 다른 범위를 담고 있는 멀티파트 본문이 함께 온다.

## 15.5 콘텐츠 인코딩

* HTTP 애플리케이션은 때때로 콘텐츠를 보내기 전에 인코딩하려고 한다.
* 느린 속도로 연결된 클라이언트에게 큰 HTML 문서를 전송하기 전에 서버는 전송 시간을 줄이기 위해 합축할 수 있다.
* 서버는 허가받지 않은 제3자가 볼 수 없도록 콘텐츠를 암호화하거나 뒤섞어서 보낼 수도 있다.
* 이런 인코딩은 발송하는 쪽에서 콘텐츠에 적용한다. 콘텐츠 인코딩이 끝난 데이터는 엔터티 본문에 담아 수신자에게 보낸다.

### 15.5.1 콘텐츠 인코딩 과정

* 콘텐츠 인코딩 과정
  1. 웹 서버가 원본 `Content-Type`과 `Content-Length` 헤더를 수반한 원본 응답 메시지를 생성한다.
  2. 콘텐츠 인코딩 서버(원 서버이거나 다운스트림 프락시)가 인코딩된 메시지를 생성한다. 인코딩된 메시지는 `Content-Type`은 같지만(본문이 압축되었거나 했다면) `Content-Length`는 다르다. 콘텐츠 인코딩 서버는 `Content-Encoding` 헤더를 인코딩된 메시지에 추가하여, 수신 측 애플리케이션이 그를 디코딩할 수 있게 한다.
  3. 수신 측 프로그램은 인코딩된 메시지를 받아 디코딩하고 원본을 얻는다.
* 콘텐츠 인코딩의 예
  * 원본 콘텐츠
    ```
    Content-type: text/html
    Content-length: 12480
    ```
  * 인코딩된 콘텐츠
    ```
    Content-type: text/html
    Content-length: 3907
    Contnet-encoding: gzip
    ```
* 여전히 `Content-Type` 헤더가 메시지에 존재할 수 있고 또 그래야 한다는 것을 잊지 말자.
  * 이 헤더는 엔터티의 원래 포맷을 기술하며, 이는 디코딩된 엔터티를 보여주기 위해 필요한 정보다.  `Content-Type` 헤더는 인코딩된 본문의 길이를 나타낸다.

### 15.5.2 콘텐츠 인코딩 유형

* HTTP는 몇 가지 표준 콘텐츠 인코딩 유형을 정의하고 확장 인코딩으로 인코딩을 추가하는 것도 허용한다.
* 인코딩은 각 콘텐츠 인코딩 알고리즘에 고유한 토큰을 할당하는 IANA를 통해 표준화된다.  `Content-Encoding` 헤더는 이런 표준화된 토큰 값을 이용해 인코딩에 사용한 알고리즘에 관해 기술한다.
* 콘텐츠 인코딩 토큰들
  * `gzip`: 엔터티에 GNU zip 인코딩이 적용됨
  * `compress`: 엔터티에 관해 유닉스 파일 압축 프로그램인 'compress'가 실행됨
  * `defalte`: 엔터티가 zip 포맷으로 압축되었음
  * `identity`: 엔터티에 어떤 인코딩도 수행하지 않았음.  `Content-Encoding` 헤더가 존재하지 않는다면 이 값인 것으로 간주
* `gzip`, `compress`, `defalte` 인코딩은 전송되는 메시지의 크기를 정보의 손실 없이 줄이기 위한 무손실 압축 알고리즘이다.
  * 이 중 gzip은 보통 가장 효율적이고 널리 쓰이는 압축 알고리즘이다.

### 15.5.3 Accept-Encoding 헤더

* 서버에서 클라이언트가 지원하지 않는 인코딩을 사용하는 것을 막기 위해, 클라이언트는 자신이 지원하는 인코딩 목록을 `Accept-Encoding` 요청 헤더를 통해 전달한다.
* HTTP 요청에 `Accept-Encoding` 헤더를 포함하지 않으면, 서버는 클라이언트가 어떤 인코딩이든 받아들일 수 있다고 간주한다(`Accept-Encoding: *` 을 전달한 경우도 같다.)
* `Accept-Encoding` 사용 예
  * 요청 메시지
    ```
    GET /logo.gif HTTP/1.1
    Accept-encoding: gzip
    [...]
    ```
  * 응답 메시지
    ```
    HTTP/1.1 200 OK
    Content-type: image/gif
    Content-encoding: gzip
    [...]
    ```
  * 서버는 클라이언트와의 네트워크 연결에서 더 작은 파일을 전송하기 위해 이미지를 gzip으로 압축한다. 네트워크 대역폭을 절약하고 클라이언트가 전송이 완료되기를 기다리는 시간을 줄인다. 다만 클라이언트가 받은 이미지의 압축을 풀기 위해 시간을 들여야 한다.
* `Accept-Encoding` 필드는 지원되는 인코딩을 쉼표로 구분하는 목록을 담고 있다.
* 클라이언트는 각 인코딩에 Q(quality) 값을 매개변수로 더해 선호도를 나타낼 수 있다.
  * Q 값의 범위는 가장 원치 않았음을 의하는 `0.0`에서 가장 선호함을 나타내는 `1.0`까지 이다.
  * 토큰 `*`은 '그 외 모두'를 의미한다.
  * 어떤 콘텐츠 인코딩을 적용할 것인지 선택하는 과정은, 클라이언트에게 돌려줄 응답에 담길 콘텐츠를 결정하는 더 일반적 과정의 일부다. (17장 참고)
  * `identity` 인코딩 토큰은 오직 `Accept-Encoding` 헤더에만 존재할 수 있고 클라이언트에 의해 다른 콘텐츠 인코딩 알고리즘에 대한 상대적 선호도 정의에 이용할 수 있다.

## 15.6 전송 인코딩과 청크 인코딩

* 콘텐츠 인코딩은 콘텐츠 포맷과 긴밀하게 연관되어 있다. 텍스트 파일은 흔히 gzip으로 압축하지만 jpeg 파일은 gzip으로 잘 압축되지 않아 그렇게 하지 않는다.
* 전송 인코딩 또한 엔터티 본문에 적용되는 가역적 변환이지만, 그들은 구조적인 이유로 적용되는 것이며 콘텐츠의 포맷과는 독립적이다.
* 메시지 데이터가 네트워크를 통해 전송되는 방법을 바꾸기 위해 전송 인코딩을 메시지에 적용할 수 있다.
* 콘텐츠 인코딩된 메시지는 메시지의 엔터티 부분만 인코딩한다. 전송 인코딩된 메시지에서는 인코딩은 전체 메시지에 관해 적용되어 메시지 자체 구조를 바꾼다.
  * 콘텐츠 인코딩된 응답
    ```
    HTTP/1.0 200 OK             ---- 보통 헤더 블록
    Content-encoding: gzip
    Content-type: text/html
    [...]
    [encoded message]           ---- 보통 엔터티(여기만 인코딩함)
    ```
  * 전송 인코딩된 응답
    ```
    HTTP/1.1 200 OK             ---- 기본 헤더
    Transfer-encoding: chunked

    10                          ---- 인코딩된 블록
    abcdefghijk
    1
    a
    ```

### 15.6.1 안전한 전송

* 역사적으로 전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 '안전한 전송'을 위해 존재했다. 표준화 후 더 너그러운 전송 기반을 갖춘 HTTP는 '안전한 전송'의 초점을 다른 데 맞추고 있다.
* HTTP 메시지 본문이 문제를 일으킬 수 있는 이유 중 두 가지
  * 알 수 없는 크기
    * 몇몇 게이트웨이 애플리케이션과 콘텐츠 인코더는 콘텐츠를 먼저 생성하지 않고서는 메시지 본문의 최종 크기를 판단할 수 없다. 흔히 이 서버들은 그 사이즈를 알기 전에 데이터 전송을 시작하려 한다.
    * HTTP는 데이터에 앞서 `Content-Length` 헤더를 요구하기 때문에, 몇몇 서버는 데이터의 끝을 알리는 특별한 종결 꼬리말을 포함해 전송 인코딩으로 데이터를 보내려 시도한다.
      * 이를 '저렴한' 메시지 종결 신호로 간주하고 커넥션을 끊으면 지속 커넥션이 망가짐
  * 보안
    * 공용 전송 네트워크로 메시지 콘텐츠를 보내기 전에 전송 인코딩을 사용해 알아보기 어렵게 뒤섞는 방법도 있다. 이미 SSL과 같은 유명한 전송 계층 보안 방식이 있기 때문에 전송 인코딩 보안은 흔하지 않다.

### 15.6.2 Transfer-Encoding 헤더

* 전송 인코딩을 제어하고 서술하기 위해 정의된 헤더는 단 두 개 뿐이다.
* `Transfer-Encoding`
  * 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려준다.
* `TE`
  * 어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 사용한다.
  * 예) chunk-encoded 메시지와 메시지 끝에 트레일러가 오는 것을 받아들일 수 있음을 서버에게 알려주기 위해 TE 헤더를 사용하는 요청
    ```
    GET /new.html HTTP/1.1
    Host: www.xyz.com
    User-Agent: Mozilla/4.61 [en] (WinNT; I)
    TE: trailers, chunked
    ```
  * 예) 수신자에게 메시지가 청크 인코딩으로 전송 인코딩되었음을 알려주기 위해 `Transfer-encoding` 헤더를 포함
    ```
    HTTP/1.1 200 OK
    Transfer-encoding: chunked
    Server: Apache/3.0
    ...
    ```
    * 이 기초 헤더 뒤에 메시지 구조가 변한다.
  * 모든 전송 인코딩 값은 대소문자가 구별된다.
  * HTTP/1.1은 `Transfer-Encoding`과 `TE` 헤더 필드에 전송 인코딩 값을 사용한다.
  * 최신 HTTP 명세는 오직 하나의 전송 인코딩, 즉 청크 인코딩만을 정의했다.
  * `TE` 헤더는 `Accept-Encoding` 헤더와 마찬가지로 어떤 형태의 전송 인코딩을 선호하는지 표현하는 Q값을 가질 수 있다. 그러나 HTTP/1.1 명세는 청크 인코딩에 관해 Q값이 0.0을 갖는 것을 금지한다.
* 미래의 HTTP 확장은 아마 전송 인코딩을 추가해야 한다는 요구를 받아들일지도 모른다. 청크 전송 인코딩은 확장 전송 인코딩들의 최상위에서 적용되어야 할 것이다.
  * 이는 청크 인코딩 외에 다른 전송 인코딩을 이해하지 못하는 HTTP/1.1 애플리케이션에서도 터널링의 동작을 보장한다.

### 15.6.3 청크 인코딩

* 청크 인코딩은 메시지를 일정 크기의 청크 여럿으로 쪼갠다. 서버는 각 청크를 순차적으로 보낸다.
* 청크 인코딩을 이용하면 메시지를 보내기 전 전체 크기를 알 필요가 없다.
* 본문이 동적으로 생성됨에 따라 서버는 그중 일부를 버퍼에 담은 뒤, 그 한 청크를 그 크기와 함께 보낼 수 있다. 본문 전체를 모두 보낼 때까지 이 단계를 반복한다.
* 청크 인코딩은 전송 인코딩의 한 형태이며 본문이 아닌 메시지의 속성이다.
  * 멀티 파트 인코딩은 본문의 속성이며 청크 인코딩과는 완전 분리되어 있다.

#### 청크와 지속 커넥션

* 클라이언트와 서버 사이 커넥션이 지속적이지 않다면 클라이언트는 자신이 읽고 있는 본문의 크기를 알 필요가 없다. 클라이언트는 서버가 커넥션을 닫을 때까지를 본문으로 간주하고 읽는다.
* 지속 커넥션에서는 본문을 쓰기 전 반드시 `Content-Length` 헤더에 본문의 길이를 담아서 보내야 한다.
* 콘텐츠가 서버에서 동적으로 생성되는 경우, 보내기 전에 본문 길이를 알아내는 것이 불가능할 것이다.
  * 청크 인코딩은 서버가 본문을 여러 청크로 쪼개 보낼 수 있게 함으로써 이 문제의 해법을 제시한다.
  * 동적으로 본문이 생성되면, 서버는 그중 일부를 버퍼에 담은 뒤 그 한 덩어리를 그의 크기와 함께 보낼 수 있다. 본문을 모두 보낼 때까지 이 단계를 반복한다.
  * 서버는 크기가 0인 청크로 본문이 끝났음을 알리고 다음 응답을 위해 커넥션을 열린 채로 유지할 수 있다.
* 청크 인코딩은 상당히 단순하다. 청크 인코딩된 메시지는 HTTP 응답 헤더 블록으로 시작하여 이어서 청크 스트림이 오는 구조다. 각 청크는 길이 값과 각 청크에 대한 데이터를 담고 있다.
  * 길이 값은 16진수 형식으로 되어 있고 청크 데이터와 CRLF로 분리된다. 청크 데이터의 길이는 바이트 단위로 측정되고, 청크 끝 CRLF 문자열 뿐 아니라 길이 값과 데이터 사이의 CRLF 문자열도 길이에 포함하지 않는다.
  * 마지막 청크는 특별한데, '본문의 끝'을 의미하기 위해 길이가 0이다.
* 클라이언트는 청크 인코딩된 데이터를 서버로 전송한다. 클라이언트는 서버가 청크 인코딩을 받아들여 줄지 모르므로(서버는 클라이언트에게 응답에 `TE` 헤더를 포함해 보내지 않는다), 청크 요청이 `411 Length Required` 응답으로 거절당하는 데에 대비해야 한다.

#### 청크 인코딩된 메시지의 트레일러

* 다음 중 하나 이상 조건을 만족하면 청크 메시지에 트레일러를 추가할 수 있다.
  * 클라이언트의 `TE` 헤더가 트레일러를 받아들일 수 있음을 나타내는 경우
  * 트레일러가 응답을 만든 서버에 의해 추가되었으며, 그 트레일러는 콘텐츠는 클라이언트가 이해하고 사용할 필요 없는 선택적인 메타데이터이므로 클라이언트가 무시하고 버려도 되는 경우
* 트레일러에는 본문 콘텐츠가 먼저 생성되어야 한다는 등의 이유로 메시지 시작 시점에서는 그 값을 알 수 없는 추가적인 헤더 필드를 담을 수 있다.
* 트레일러로 보낼 수 있는 헤더의 예로 `Content-MD5` 헤더가 있다.(문서가 생성되기 전에 그 문서의 MD5를 계산하는 것은 어려움)
* 메시지 헤더는 청크 인코딩된 메시지 다음에 오게 될 헤더들을 나열하는 `Trailer` 헤더를 포함한다. 마지막 청크 다음에 `Trailer` 헤더에 나열했던 헤더들이 온다.
* `Transfer-Encoding`, `Trailer`, `Content-Length`를 제외한 HTTP 헤더를 트레일러로 보낼 수 있다.

### 15.6.4 콘텐츠와 전송 인코딩의 조합

* 콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다.
* 송신자가 콘텐츠 인코딩을 사용해서 HTML 파일을 압축하고 그 청크 데이터를 전송 인코딩을 사용해서 전송한다. 수신자는 이 절차를 반대로 수행하여 본문을 '재구축'한다.
  ```
  Content-type: text/html

  // 콘텐츠 인코딩

  Content-type: text/html
  Content-encoding: gzip

  // 전송 인코딩(청크 인코딩)

  Content-type: text/html
  Content-encoding: gzip
  Transfer-encoding: chunked
  ```

### 15.6.5 전송 인코딩 규칙

* 전송 인코딩이 메시지 본문에 적용될 때 다음 규칙이 반드시 적용되어야 한다. 이 규칙은 수신자가 메시지의 전송 길이를 알아낼 수 있게 한다.
  * 전송 인코딩의 집합은 반드시 `chunked` 를 포함해야 한다. 유일한 예외는 메시지가 커넥션의 종료로 끝나는 경우뿐이다.
  * 청크 전송 인코딩이 사용되었다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 한다.
  * 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 한다.
* 전송 인코딩은 HTTP/1.1에 소개된 비교적 새로운 기능이다. 전송 인코딩을 구현한 서버는 비 HTTP/1.1 애플리케이션에 전송 인코딩된 메시지를 보내지 않도록 주의해야 한다.
* 마찬가지로 서버가 이해할 수 없는 전송 인코딩된 메시지를 받았다면 서버는 `501 Unimplemented` 상태 코드로 응답해야 한다.
* 그러나 어떠한 HTTP/1.1 애플리케이션이라도 최소한 청크 인코딩만은 반드시 지원해야 한다.

## 15.7 시간에 따라 바뀌는 인스턴스

* 웹 객체는 정적이지 않아, 같은 URL이 시간에 따라 다른 버전의 객체를 가리킬 수 있다.
* 홈페이지를 하나의 객체로, 그의 각각 다른 버전을 객체의 각각 다른 인스턴스라고 생각하면,
  * 클라이언트가 같은 리소스(URL)을 여러 번 요청했으나, 시간 흐름에 따라 리소스의 다른 인스턴스를 받게 된다.
* HTTP 프로토콜은 어떤 특정 종류의 요청과 응답을 다루는 방법을 정의하는데, 이를 **인스턴스 조작(instance manipulation)** 이라 부르며 객체의 인스턴스에 작용한다.
  * 이 중 **범위 요청**과 **델타 인코딩**이 대표적인 두 가지다.
  * 이 둘 다, 클라이언트가 자신이 가진 리소스의 사본이 서버가 가진 것과 정확히 같은지 판단하고 상황에 따라 새 인스턴스를 요청할 수 있는 능력을 갖출 것을 요구한다.

## 15.8 검사기와 신선도

* 클라이언트는 처음에 리소스 사본을 갖고 있지 않으므로 서버에게 달라고 요청을 보낸다. 서버는 그 리소스의 버전 1로 응답하고 클라이언트는 이 사본을 캐시한다. 이것을 얼마나 오래 캐시해야 하는가?
* 문서가 클라이언트에서 '만료'되면(클라이언트가 그 문서 사본을 더 유효한 것으로 생각하지 않을 수 있음), 클라이언트는 반드시 서버에게 최신 사본을 요구해야 하고, 서버에서도 문서가 변경되지 않았다면 클라이언트는 다시 받을 필요가 없다. 클라이언트는 갖고 있던 캐시된 사본을 사용한다.
* **조건부 요청**은, 클라이언트가 서버에게 자신이 가진 버전을 알리고 검사기를 이용해 자신의 사본 버전이 더 유효하지 않을 때만 사본을 보내달라 요청하는 것이다.

### 15.8.1 신선도

* 서버는 `Expires`나 `Cache-Control` 헤더를 통해 클라이언트에게 얼마나 오래 콘텐츠를 캐시하고 그것이 신선하다 가정할 수 있는지 정보를 준다.
* `Expires` 헤더는 문서가 만료되어 더는 신선하지 않다고 간주하게 되는 정확한 날짜를 명시한다.
  * `Expires: Sun Mar 18 23:59:59 GMT 2021`
  * 이 헤더를 바르게 사용하는 클라이언트나 헤더는 그들의 시계를 반드시 동기화시켜야 한다.
  * 그러나 네트워크 시간 프로토콜(Network Time Protocol, NTP)과 같은 시계 동기화 프로토콜을 실행하지 않았을 가능성이 양쪽 모두에게 있기 때문에 동기화가 항상 쉽지는 않다.
  * 상대시간을 이용해 만료를 정의하는 메커니즘이 더 유용하다.
* `Cache-Control` 헤더는 문서의 최대 수명을 문서가 서버를 떠난 후로부터의 총 시간을 초 단위로 정한다. 수명은 시계 동기화에 의존하지 않으므로 더 정확한 결과를 말해준다.
  * `Cache-Control` 헤더는 실제로 굉장히 강력하다. 서버와 클라이언트 양쪽에서 더 많은 지시자들과 함께, 다시 수명이나 유효기간뿐 아니라 선도(신선도)를 서술하기 위해 사용된다.
* `Cache-Control` 헤더 지시자
  * 요청 메시지
    * `no-cache`: 서버와의 최초 재검사 없이는 문서의 캐시된 사본을 반환하지 마라.
    * `no-store`: 문서의 캐시된 사본을 반환하지 않는다. 서버로부터의 응답을 저장하지 마라.
    * `max-age`: 캐시의 문서는 명시한 나이보다 오래되어서는 절대로 안 된다.
    * `max-stale`: 문서는 서버가 정해준 만료일시가 지나면 더 신선하지 않게 되는데, 그래도 신선하지 않게 된 후 지난 시간이 이 지시자로 지정한 시간보다 크지 않다면 받아들인다.
    * `min-fresh`: 문서의 신선도 수명이 그 문서의 나이에 여기서 지정한 값을 더한 것보다 작아서는 안 된다. 응답은 반드시 적어도 지정한 시간만큼은 신선해야 한다.
    * `no-transform`: 문서는 보내기 전에 변형되어서는 안 된다.
    * `only-if-cached`: 서버에 접근하지 말고 캐시에 들어있는 경우에만 문서를 보내라.
  * 응답 메시지
    * `public`: 응답은 어떤 캐시로든 캐시된다.
    * `private`: 응답은 하나의 클라이언트만 접근할 수 있는 형태로 캐시된다.
    * `no-cache`: 지시자가 헤더 필드의 목록을 동반하고 있다면, 콘텐츠는 캐시되어 클라이언트에게 제공될 수 있으나 그 전에 헤더 필드들은 반드시 제거되어야 한다. 헤더 필드가 지정되지 않았다면, 캐시된 사본은 절대로 서버를 통한 재검사 없이 제공되어서는 안 된다.
    * `no-store`: 응답은 절대로 캐시되어서는 안 된다.
    * `no-transform`: 응답은 제공되기 전에는 어떤 식으로든 수정되어서는 안 된다.
    * `must-revalidate`: 응답은 반드시 제공되기 전에 서버를 통해 재검사되어야 한다.
    * `proxy-revalidate`: 공유된 캐시는 반드시 응답을 원 서버를 통해 재검사해야 한다. 이 지시자는 개인 캐시에 의해 무시될 수 있다.
    * `max-age`: 문서가 캐시될 수 있고 여전히 신선하다고 간주할 수 있는 시간의 최대 길이를 정의한다.
    * `s-max-age`: 공유된 캐시에 적용될 수 있는 문서의 최대 수명을 정의한다.(이 값이 정의되면 `max-age` 지시자를 덮어쓴다). 이 지시자는 개인 캐시에 의해 무시될 수 있다.

### 15.8.2 조건부 요청과 검사기

* 캐시의 사본이 요청되었을 때 그것이 더는 신선하지 않다면 캐시는 자신의 사본을 신선하게 만들 필요가 있다. 캐시는 원 서버에 현 시점의 사본을 가져올 수 있지만, 대개 서버에 있는 문서는 여전히 캐시에 들어있는 신선하지 못한 사본과 같을 것이다. 캐시된 사본은 만료될 수 있지만 서버 콘텐츠는 여전히 캐시 콘텐츠와 같다.
* 서버의 문서가 캐시가 가진 것과 같음에도 불구하고 항상 그 문서를 가져온다면 캐시는 네트워크 대역폭을 낭비하고 캐시와 서버에 불필요한 부하를 주고, 모든 것을 느려지게 만든다.
* HTTP는 클라이언트에게 리소스가 바뀐 경우에만 사본을 요청하는 조건부 요청이라 불리는 특별한 요청 방법을 제공한다. 조건부 요청은 평범한 HTTP 요청 메시지이지만, 특정 조건이 참일 때만 수행된다.
  * 예) 2002년 6월 29일 이후에 변경된 경우만 파일을 보내달라
    ```
    GET /announce.html HTTP/1.0
    If-Modified-Since: Sat, 29 Jun 2002, 14:30:00 GMT
    ```
  * 조건부 요청은 `If-`로 시작하는 조건부 헤더에 의해 구현된다. 조건이 참일 때만 수행되도록 한다. 조건이 참이 아니면 서버는 HTTP 에러 코드를 돌려보낸다.
* 각 조건부 요청은 특정 검사기 위에서 동작한다. 검사기는 문서의 테스트된 특정 속성이다. 개념적으로 일련번호나 버전 번호, 문서의 최종 변경일과 같은 검사기를 생각해 볼 수 있다.
* `If-Modified-Since` 상태 헤더는 문서 인스턴스의 마지막 수정된 날짜를 검사하므로 마지막 수정된 날짜를 검사기라고 말할 수 있다.
* `If-None-Match` 조건부 헤더는 문서의 ETag 값을 평가한다. ETag는 특별한 키워드이거나 엔터티와 관련된 버전 식별 태그이다.
* `Last-Modified`와 ETag는 HTTP에 의해 사용되는 두 개의 주요한 검사기다.

##### 조건부 요청 유형
| 요청 유형 | 검사기 | 설명 |
|:---|:---|:---|
| `If-Modified-Since` | Last-Modified | Last-Modified 응답 헤더에 들어있었던 시각에 마지막으로 수정된 버전이 최신이 아니라면, 그 리소스 사본을 보내라. |
| `If-Unmodified-Since` | Last-Modified | 지난번 Last-Modified 응답 헤더에 들어있었던 시각에 마지막으로 수정된 버전에서 변한 것이 없다면, 리소스 사본을 보내라. |
| `If-Match` | ETag | 지난번 ETag 응답 헤더에 들어있었던 것과 엔터티 태그가 같다면, 그 리소스의 사본을 보내라. |
| `If-None-Match` | ETag | ETag 응답 헤더에 들어있었던 것과 엔터티 태그가 다르다면, 그 리소스의 사본을 보내라. |

* HTTP는 검사기를 약한 검사기, 강한 검사기의 두 가지로 분류한다.
* 약한 검사기
  * 리소스의 인스턴스를 고유하게 식별하지(uniquely identify) 못하는 경우도 있다.
  * 약한 검사기의 예로 객체 바이트 단위 크기가 있다. 리소스 콘텐츠는 크기가 같더라도 내용이 다를 수 있으므로 바이트의 개수를 세는 방식으로 동작하는 가상 횟수 검사기는 변경이 발생했음을 약하게만 감지할 수 있다.
  * 최종 변경 시각은 리소스가 마지막으로 수정된 시각을 의미함에도 불구하고 약한 검사기로 간주되는데, 정확도가 최대 1초에 불과하기 때문이다.
  * 클라이언트와 서버가 때때로 엔터티 태그 검사를 통과하지 못한 버전을 채택하는 때가 있는데, 서버는 크고 자주 찾는 캐시 문서에 관해 캐시 재검사로 인한 대량 전송을 유발하지 않으면서 겉모양새만 약간 고치고 싶을 수 있다. 이때 서버는 태그 앞에 `W/`를 붙여 약한 엔터티 태그임을 알린다. 약한 엔터티 태그는 엔터티의 의미상 두드러진 변화에만 사용할 수 있다.
    * 예) 서버는 콘텐츠가 문서 버전 4.0 이후로 의미 있는 변경이 있을 때만 본문을 반환
    ```
    GET /announce.html HTTP/1.1
    If-None-Match: W/"v4.0"
    ```
* 강한 검사기
  * 언제나 고유하게 식별한다.
  * 리소스의 콘텐츠에 대한 암호 체크섬(MD5와 같은)은 강한 검사기다. 문서가 변경되면 함께 변경된다.
  * `ETag` 헤더는 강한 검사기로 간주되는데, 서버는 `ETag` 헤더에 변경마다 구분되는 값을 넣어두기 때문이다. 버전 번호와 요약 체크섬은 `ETag` 헤더의 좋은 후보이나, 그 외의 어떤 텍스트도 포함할 수 있다. `ETag`는 유연하다. 어떤 텍스트 값도 가질 수 있고('tags') 클라이언트와 서버의 다양한 검사를 창안하기 위해 사용될 수 있다.
  * 강한 엔터티 태그는 관련 엔터티 값이 아무리 사소하게 바뀌어도 함께 변경되어야 한다.

## 15.9 범위 요청

* HTTP는 클라이언트가 문서 일부분이나 특정 범위만 요청할 수 있도록 해준다.
* 범위 요청을 하면, HTTP 클라이언트는 받다가 실패한 엔터티를 일부 혹은 범위로 요청하여 다운로드가 중단된 시점에서 재개할 수 있다.(원 서버에서 객체가 처음 요청했을 때와 범위 요청을 했을 때 사이 아무 변경이 없다면)
  * 예) 클라이언트는 처음 4,000바이트 이후 부분을 요청함
    ```
    GET /bigfile.html HTTP/1.1
    Host: www.xyz.com
    Range: bytes=4000-
    User-Agent: Mozilla/4.61 [en] (WinNT; I)
    ```
* `Range` 헤더는 여러 범위로 요청하기 위해 사용할 수 있다.(각 범위는 순서 없이 정해지며 서로 겹칠 수 있다).
  * 예) 어떤 문서의 다운로드 시간을 줄이려고 동시에 여러 서버에 접속해 서로 다른 범위를 요청. 응답은 멀티파트 본문과 `Content-Type: multipart/byteranges` 헤더와 함께 하나의 엔터티로 돌아온다.
* 모든 서버가 범위 요청을 받아들일 수 있는 것은 아니지만 대부분 가능하다. 서버는 클라이언트에게 자신이 범위를 받아들일 수 있는지 응답에 `Accept-Range` 헤더를 포함해 알려줄 수 있다. 이 헤더 값은 측정 단위로 주로 바이트다.
  ```
  HTTP/1.1. 200 OK
  Date: Sun, 17 Jan 2021 20:00 GMT
  Server: Apache/1.2.4
  Accept-Ranges: bytes
  ```
* `Range` 헤더는 P2P 파일 공유 클라이언트가 멀티미디어 파일의 다른 부분을 여러 다른 피어로부터 동시에 다운로드 받을 때 널리 사용된다.
* 범위 요청은 객체의 특정 인스턴스를 클라이언트와 서버 사이에서 교환하는 것이라, 인스턴스 조작의 일종임을 주의해야 한다. 클라이언트의 범위 요청은 오직 클라이언트와 서버가 같은 버전의 문서를 갖고 있을 때만 의미가 있다.

## 15.10 델타 인코딩

* 델타 인코딩은 객체 전체가 아닌 변경된 부분에 관해서만 통신하여 전송량을 최적화하는 HTTP 프로토콜의 확장이다.
  * 새 페이지 전체를 보내는 대신, 페이지에 대한 클라이언트의 사본(변경량이 작은)에 관해 변경된 부분만을 서버가 보낸다면 클라이언트는 더 빨리 페이지를 얻을 수 있을 것이다.
  * 델타 인코딩은 일종의 인스턴스 조작으로, 어떤 객체의 특정 인스턴스들에 대한 클라이언트와 서버 사이의 정보 교환에 의존한다.
* 델타 인코딩의 메커니즘
  1. 클라이언트는 페이지 어떤 버전을 가졌는지 서버에게 말해줘야 하는데, 클라이언트가 페이지의 최신 버전에 대한 델타(변경 부분)를 받아들일 의사가 있음을 뜻한다.
  2. 클라이언트는 자신의 현재 버전에 델타 적용을 위해 어떤 알고리즘을 알고 있는지도 서버에게 말해야 한다.
  3. 서버는 자신이 클라이언트가 가진 버전을 가진지, 어떻게 최신 버전과 클라이언트 버전 사이의 델타를 계산할 것이지 체크해야 한다.
  4. 델타를 계산에서 클라이언트에게 보내주고, 서버가 델타를 보내고 있음을 클라이언트에게 알려주고, 페이지 최신 버전에 대한 새 식별자를 명시해야 한다.(이 식별자가 새 페이지의 버전이 됨)
  5. 클라이언트는 자신의 버전에 대한 유일한 식별자(지난번 응답의 ETag 헤더에 들어있던 것)를 If-None-Match 헤더에 담는다. 이는 서버에게 "네가 가진 최신 버전 페이지가 이와 같은 ETag를 갖고 있지 않으면, 최신 버전을 보내달라"라고 하는 것이다.
  6. 최신 버전이 클라이언트 버전과 다르다면, 이 If-None-Match 헤더에 의해 서버는 클라이언트에게 그 페이지 최신 버전 전체를 보낸다.
  7. 클라이언트는 서버에게 A-IM(Accept-Instance-Manipulation) 헤더를 보내, 자신이 페이지의 델타를 받아들일 수 있음을 알려줄 수도 있다. 클라이언트는 페이지 예전 버전과 델타를 이용해 최신 버전 문서를 생성하는 방법에 관해 자신이 아는 알고리즘을 A-IM 헤더에 명시한다.
  8. 서버는 클라이언트에게 요청한 객체에 해더 객체 자체가 아닌 인스턴스 조작을 보내고 있음을 말해주는 응답 코드(226 IM Used), 델타 계산을 위해 사용한 알고리즘을 명시한 IM(Instance-Manipulation) 헤더, 새 ETag 헤더, 델타 계산의 기반이 된 문서의 ETag를 지정한 Delta-Base 헤더를 되돌려준다.

##### 델타 인코딩 관련 헤더들
| 헤더 | 설명 |
|:---|:---|
| `Etag` | 문서의 각 인스턴스에 대한 유일한 식별자. 서버가 응답에 담아 보내주며 클라이언트는 이를 다음번 요청에서 If-Match, If-None-Match 헤더에 사용한다. |
| `If-None-Match` | 클라이언트가 보내는 요청 헤더. 서버와 클라이언트가 다른 버전의 문서를 가지고 있다면 그 문서에 한해 요청한다. |
| `A-IM` | 받아들일 수 있는 인스턴스 조작의 종류를 가리키는 클라이언트 요청 헤더 |
| `IM` | 요청에 적용된 인스턴스 조작의 종류를 명시하는 서버의 응답 헤더. 응답 코드가 226 IM Used 일때 이 헤더를 보낸다. |
| `Delta-Base` | 델타를 생성하기 위해 사용된 기저 문서의 Etag(클라이언트 요청의 If-None-Match 헤더의 ETag와 같아야 함)를 명시하는 서버 응답 헤더 |

### 15.10.1 인스턴스 조작, 델타 생성기 그리고 델타 적용기

* 클라이언트는 A-IM 헤더를 사용해 자신이 받아들일 수 있는 인스턴스 조작의 종류를 명시할 수 있다.
* 서버는 IM 헤더에 사용한 인스턴스 조작의 종류를 명시할 수 있다.
* IANA에 등록된 인스턴스 조작의 종류를
  * vcdiff: vcdiff 알고리즘을 이용한 델타
  * diffe: 유닉스 `diff -e` 명령을 이용한 델타
  * gdiff: gdiff 알고리즘을 이용한 델타
  * gzip: gzip 알고리즘을 이용한 압축
  * deflate: deflate 알고리즘을 이용한 압축
  * range: 현재 응답이 범위 선택에 대한 결과인 부분(partial) 콘텐츠임을 말해주기 위해 서버 응답에서 사용
  * identity: 클라이언트가 identity 인스턴스 조작을 받아들일 의사가 있음을 말해주기 위해 클라이언트 요청의 A-IM 헤더에서 사용
* 서버의 '델타 생성기'는 기저 문서와 그 문서의 최신 인스턴스를 취해 클라이언트의 A-IM 헤더에 지정된 알고리즘을 이용하여 둘 사이 델타를 계산한다.
* 클라이언트 측에서는 '델타 적용기'가 델타를 취하여 그를 기저 문서에 적용해 문서의 최신 인스턴스를 생성한다.
* 델타 인코딩 명세는 A-IM과 IM 헤더 포맷을 자세히 정의한다. 이 헤더들에서 복수 개의 인스턴스 조작을(각 품질 값들과 함께) 지정할 수 있다.
* 문서는 클라이언트에게 반환되기 전에 압축률을 극대화하기 위해 여러 번 인스턴스 조작을 거칠 수 있다.
* 델타 인코딩은 전송 시간을 줄일 수 있으나 구현하기 까다로울 수 있다.
  * 변경이 잦고 많은 사람이 접근하는 페이지의 경우, 델타 인코딩을 지원하는 서버는 자신이 제공하는 페이지가 변경되는 매 순간 사본을 유지하고 있어야 한다. 그래야 클라이언트 요청 시 클라이언트의 사본과 최신 사본간 차이를 알아낼 수 있다.
  * 문서를 제공하는 시간이 줄어드는 대신 서버는 문서의 과거 사본을 모두 유지하기 위해 디스크 공간이 더 필요하다.

## 15.11 추가 정보