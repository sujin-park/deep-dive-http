- HTTP는 메시지가 바르게 수송, 식별, 추출, 처리되는 것을 보장하기 위해 잘 라벨링 된 엔터티를 사용
    - 객체는 (`Content-Type` 미디어 포맷과, `Content-Language` 헤더를 이용해) 올바르게 식별되므로, 브라우저나 다른 클라이언트가 콘텐츠를 바르게 처리
    - 객체는 올바르게 압축이 풀림(`Content-Length`, `Content-Encoding` 헤더 이용)
    - 객체는 항상 최신(엔터티 검사기와 캐시 만료 제어 이용)
    - 사용자의 요구 만족(`Accept` 관련 헤더에 기반하여 내용 협상)
    - 네트워크 사이를 빠르고 효율적으로 이동(범위 요청, 델타 인코딩, 그 외 데이터 압축 이용)
    - 조작되지 않고 온전하게 도착(전송 인코딩 헤더와 `Content-MD5` 체크섬 이용)

## 15.1 메시지는 컨테이너, 엔터티는 화물

- HTTP 메시지 = 컨테이너, HTTP 엔터티 = 화물

```
HTTP/1.0 200 OK
Server: Netscape-Enterprise/3.6
Date: Sun, 17 Sep 2000 00:01:05 GMT
Content-type: text/plain
Content-length: 18

Hi! I'm a message!
```

- 엔터티 헤더 2개: `Content-Length: 18`,  `Content-Type: text/plain`
    - → 18자인 플레인 텍스트 문서를 의미
- 빈 줄 (CRLF)은 헤더 필드와 본문의 시작을 나눔

***엔터티 헤더***

- `Content-Type`: 엔터티에 의해 전달된 객체의 종류
- `Content-Length`: 전달된 메시지의 길이나 크기
- `Content-Language`: 전달된 객체와 가장 잘 대응되는 자연어
- `Content-Encoding`: 객체 데이터에 대해 행해진 변형(압축 등)
- `Content-Location`: 요청 시점을 기준으로, 객체의 또 다른 위치
- `Content-Range`: 만약 이 엔터티가 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의
- `Content-MD5`: 엔터티 본문의 콘텐츠에 대한 체크섬
- `Last-Modified`: 서버에서 이 콘텐츠가 생성/수정된 날
- `Expires`: 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작는 날짜와 시각
- `Allow`: 리소스에 대해 어떤 요청 메서드가 허용되는지(GET, HEAD 등)
- `ETag`: 인스턴스에 대한 고유한 검사기. 엄밀히 말하면 엔터티 헤더는 아니지만, 엔터티와 관련된 중요 헤더
- `Cache-Control`: 어떻게 이 문서가 캐시될 수 있는지에 대한 지시자. 위와 동일하게 엔터티 헤더는 아님.

### 15.1.1 엔터티 본문

- 엔터티 본문 = 가공되지 않은 데이터, 헤더 = 그 외 다른 정보
    - 엔터티 헤더는 본문의 날 데이터의 의미에 대해 설명할 필요가 있음
        - 예: `Content-Type` → 데이터 해석 방법, `Content-Encoding` → 압축 및 인코딩 여부
    - 엔터티 본문은 타입, 압축여부, 언어와 별개로 CRLF 바로 다음에 위치

## 15.2 Content-Length: 엔터티의 길이

- `Content-Length` 는 본문의 크기를 바이트 단위로 나타냄
    - 인코딩 종류 및 여부와 무관하며, 압축되었다면 압축 후 크기를 나타냄
    - 엔터티를 포함한 메시지에 필수(메세지를 청크 인코딩으로 전송하는 경우 제외)
    - 서버 충돌로 메시지가 잘렸는지 감지, 지속 커넥션을 공유하는 메시지를 바르게 분할 할 때 필요

### 15.2.1 잘림 검출

- 구 버전은 HTTP 커넥션을 닫힌 것으로 메시지가 끝났음을 인지.
    - 정상 닫힘과 서버 충돌을 구분 못함 → 즉 메시지 잘림 검출을 위해 `Content-Length` 필요
- 메시지 잘림은 캐싱 프락시서버에 특히 취약
    - 잘린 메시지를 수신했으나 잘린 것을 모른다면 결함이 있는 콘텐츠를 저장하고 계속해서 제공
    - 잘린 메시지를 캐싱하는 위험을 줄이기 위해, 명시적으로 `Content-Length` 가 없으면 캐싱하지 않음

### 15.2.2 잘못된 Content-Length

- `Content-Length` 가 잘못된 값을 담고 있으면 없는 것보다 큰 피해 유발
    - 몇 클라이언트/서버/프락시는 오동작 탐지하고 교정을 시도
    - 공식적으로 HTTP/1.1은 사용자 에이전트가 잘못된 길이를 받게된 것을 알았을 때 사용자에게 안내함

### 15.2.3 Content-Length와 지속 커넥션(Persistent Connection)

- `Content-Length` 는 지속 커넥션을 위해 필수
    - 지속 커넥션을 통해 응답이 온다면 다른 응답이 뒤따르므로, 메세지의 끝과 다음의 시작이 필요
    - 15.6절의 청크인코딩 사용 시에는 `Content-Length` 헤더가 없는 지속 커넥션이 발생

### 15.2.4 콘텐츠 인코딩

- HTTP는 보안 강화하거나 압축을 통해 공간을 절약하도록, 엔터티 본문 인코딩을 허용.
    - 본문 콘텐츠가 인코딩되어 있다면, `Content-Length` 는 인코딩된 본문 길이를 정의
    - 인코딩 전 크기를 보내면, 특히 지속 커넥션일 때 심각한 오류 발생.
    - HTTP/1.1 명세에는 인코딩 전 길이를 보내기 위한 스펙은 없고, 때문에 디코딩 중 문제 발생시 검증을 하기 어려움

### 15.2.5 엔터티 본문 길이 판별을 위한 규칙

- 엔터티 본문의 길이, 끝나는 위치 판별 규칙. 순서대로 적용 되어야 함
    1. 본문을 갖을 수 없는 특정 타입의 HTTP 메시지에서는(예: HEAD), `Content-Length` 헤더 무시
        - 이 경우 해당 헤더는 실제 본문길이를 서술하지 않는 부가 정보에 불과
        - 만약 해당 헤더가 있으면 ,언제나 본문이 있다고 가정해서 만들면 문제 발생
    2. 메시지가 `Transfer-Encoding` 헤더를 포함하고 있다면(기본 HTTP 인코딩, 'identity'이 아니라면), 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔터티는 '0 바이트 청크'라고 불리는 특별한 패턴으로 끝나야 함. 
    3. 1과 2에 해당하지 않고, 메시지에 `Content-Length` 가 있다면 이 헤더는 본문의 길이를 담음
        - 2에 해당한다면 `Content-Length` 헤더를 무시해야함.
    4. 위 규칙에 해당 되지 않는다면, 엔터티는 커넥션이 닫힐 때 끝남
        - 서버가 응답을 되돌려줘야하므로 커넥션은 서버만 닫을 수 있음
    5. 엔터티 본문이 있는 HTTP/1.1 요청은 유효한 `Content-Length` 를 가져야 함 

## 15.3 엔터티 요약

- 엔터티 본문에 대한 의도치 않은 변경을 감지 하기 위해, 최초 엔터티가 생성될 때 송신자는 데이터에 대한 체크섬을 생성할 수 있고, 수신자는 그 체크섬으로 검사 가능
- `Content-MD5` 헤더는 서버가 엔터티 본문에 MD5 알고리즘을 적용한 결과를 보내기 위해 사용
    - 콘텐츠 인코딩의 적용 후, 전송 인코딩 적용 전 엔터티 본문에 대한 MD5 값
    - 종단간 무결성 검증을 위해, 응답을 처음 만든 헤더만이 계산하여 헤더를 추가하고, 프락시/캐시는 건드리지 않음
    - 무결성 검증시, 클라이언트는 전송 인코딩 디코딩 후 엔터티 본문에 대한 MD5계산 하여 비교
- 실제로 `Content-MD5` 는 자주 사용되지 않으며, 여러 다른 요약 알고리즘이 있음
    - 클라이언트가 응답에 대해 기대하는 요약 유형을 정의할 수 있는 `Want-Digest` 를 제안하였음

## 15.4 미디어 타입과 차셋(Charset)

- `Content-Type` 헤더: 엔터티 본문의 MIME 타입을 기술. 클라이언트가 콘텐츠를 적절히 해석/처리하기 위해 사용.
    - 콘텐츠 인코딩 전의 엔터티 본문 유형 명시
    - HEAD 요청인 경우에는, GET이였을 때 발송할 타입을 알려줌
- [MIME 타입](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types): 전달되는 데이터 매체의 기저 형식의 표준화된 이름
    - `text/html`: HTML 문서
    - `text/plain`: 플레인 텍스트 문서
    - `image/gif`: GIF 이미지
    - `image/jpeg`: JPEG 이미지
    - `audio/x-wav`: WAV 음향 데이터
    - `application/vnd.ms-powerpoint`: 마이크로소프트 파워포인트 프레젠테이션

### 15.4.1 텍스트 매체를 위한 문자 인코딩

- `Content-Type` 헤더는 엔터티 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 선택적인 'charset' 매개변수를 지원

```
Content-Type:text/html; charset=iso-8859-4
```

### 15.4.2 멀티파트 미디어 타입

- MIME "멀티파트" 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함해 하나의 복합 메시지로 보내짐.
    - 각 구성요소는 자신에 대해 서술하는 헤더를 포함.
    - 여러 구성요소들이 이어져있고, 문자열 하나로 서로의 경계 식별
- HTTP는 멀티 파트본문도 지원. 일반적으로 폼을 채워서 제출시, 문서의 일부분을 실어나르는 범위 응답시 에만 사용됨

### 15.4.3 멀티 파트 폼 제출

- HTTP 폼을 채워 제출시, 가변 길이 텍스트 필드와 업로드 될 객체는 각각 멀티파트 본문을 구성하는 하나의 파트가 되어 전송됨.
    - 멀티파트 본문은 여러 다른 종류, 다른 길이의 값으로 채워진 폼 허용
    - [boundary:](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods/POST) 본문의 서로 다른 부분을 구분하기 위한 구분자.

```
Content-Type: multipart/form-data; boundary=AaB93x
--AaB93x
Content-Disposition: form-data; name="field1"
value1
--AaB93x
Content-Disposition: form-data; name="files"; filename="example.txt"
...contents of example.txt...
--AaB93x--
```

### 15.4.4 멀티파트 범위 응답

- 범위 요청에 대한 응답 또한 멀티파트가 될 수 있음.
    - `Content-Type: multipart/byteranges` 헤더 및 각각 다른 범위를 담고 있는 멀티 파트 본문 포함

## 15.5 콘텐츠 인코딩

- 압축, 암호화를 위해 콘텐츠 전송 전에 인코딩.
    - 발송하는 쪽에서 콘텐츠에 적용하며, 인코딩이 끝난 데이터는 엔터티 본문에 담아 수신자에게 전송

### 15.5.1 콘텐츠의 인코딩 과정

1. 웹 서버가 원본 `Content-Type` 과 `Content-Length` 헤더를 수반한 원본 응답 메시지 생성
2. 콘텐츠 인코딩 서버(원서버 혹은 다운스트림 프락시)가 인코딩 된 메시지 생성
    - `Content-Type` 은 같지만 압축되었다면 `Content-Length` 는 다름
    - `Contetnt-Encoding` 헤더를 인코딩된 메시지에 추가하여 수신에서 디코딩할 수 있도록 함
3. 수신 측 프로그램은 인코딩 된 메시지를 받아 디코딩 후 원본을 얻음 

### 15.5.2 콘텐츠 인코딩 유형

- HTTP는 표준 인코딩을 정의하고, 확장 인코딩으로 인코딩 추가도 허용
    - `Contetnt-Encoding` 헤더는 표준화된 인코딩 토큰 값을 이용해, 인코딩에 사용된 알고리즘 기술
- [콘텐츠 인코딩 토큰](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Content-Encoding) 목록
    - `gzip`: GNU zip 인코딩이 적용되었음
    - `compress`: 유닉스 파일 압축 프로그램인 'compress'가 실행되었음
    - `deflate`: zlib 포맷으로 압축되었음
    - `identity`: 어떤 인코딩도 수행되지 않았음. `Contetnt-Encoding` 가 없다면 이 값으로 간주.
- `gzip`, `compress`, `deflate` 는 무손실 압축 알고리즘이고, 이 중 `gzip` 이 일반적으로 효율적이고 가장 널리 쓰임

### 15.5.3 Accept-Encoding 헤더

- 서버에서 클라이언트 미지원 인코딩 사용하는 것을 방지하기 위해, 클라이언트는 `Accept-Encoding` 헤더를 이용하여 지원하는 인코딩 목록을 전달
    - 해당 헤더를 미포함 한다면, 어떤 인코딩도 받아드릴 수 있는 것으로 간주. = `Accept-Encoding: *`
    - 각 인코딩에 Q(quality) 값을 매개변수로 하여 선호도를 추가할 수 있음. 0.0(비선호)~1.0(선호)

```
Accept-Encoding: compress, gzip
Accept-Encoding:
Accept-Encoding: *
Accept-Encoding: compress;q=0.5, gzip;q=1.0
```

## 15.6 전송 인코딩과 청크 인코딩

- 콘텐츠 인코딩
    - 메시지의 엔터티 부분만 인코딩
    - 콘텐츠 포맷은 긴밀하게 연관되어있음
        - 예: 텍스트파일은 gzip 압축을 하지만, JPEG는 gzip으로 잘 압축되지 않으므로 하지 않음
- 전송 인코딩
    - 전체 메시지에 대해 적용되어 메시지 구조 자체를 변경.
    - 콘텐츠 포맷과 독립적

### 15.6.1 안전한 전송

- 전송 인코딩은 다른 프로토콜에서도 '안전한 전송'을 위해 존재했지만, HTTP는 '안전한 전송'의 초점을 다른 데 맞추고 있음
- HTTP에서 전송된 메시지 본문이 문제를 일으키는 이유
    1. 알 수 없는 크기
        - 몇 게이트웨이 애플리케이션, 콘텐츠 인코더는 콘텐츠 생성 전에 최종 크기 판단 불가하며 사이즈 알기 전에 데이터 전송을 시작
        - HTTP는 데이터에 앞서 `Content-Length` 헤더를 요구하므로, 몇 서버는 데이터의 끝을 알리는 종결 꼬리말을 포함시켜 전송 인코딩으로 보내려 시도함
    2. 보안
        - 이미 SSL과 같은 유명한 전송 계층 보안 방식이 있어 전송 인코딩 보안은 흔하지 않음

### 15.6.2 Transfer-Encoding 헤더

- 전송 인코딩 제어, 서술을 위해 정의 된 헤더
    - `Transfer-Encoding`: 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 응답 헤더에 사용
    - `TE`: 어떤 확장된 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 사용

```
GET /new_product.html HTTP/1.1
Host: www.joes-hardware.com
User-Agent: Mozilla/4.61 [en] (WinNT; I)
TE: trailers, chunked
...

HTTP/1.1 200 OK
Trasfer-Encoding: chunked
Server: Apache/3.0
...
```

### 15.6.3 청크 인코딩

- 청크 인코딩은 메시지를 일정 크기의 청크 여럿으로 쪼개, 순차적으로 보냄
    - 청크 인코딩을 사용하면 메시지 전송 전에 전체 크기를 알 필요가 없어짐
    - 본문이 동적으로 생성됨에 따라, 서버는 그 중 일부를 버퍼에 담은 뒤 그 청크를 그것의 크기와 함께 전송
    - 본문 전체를 모두 보낼 때까지 반복
- 청크 인코딩은 전송 인코딩의 한 형태이며, 즉 본문이 아닌 메시지의 속성임
    - 멀티파트 인코딩은 본문의 속성이므로 청크 인코딩과 완전히 분리되어있음

***청크와 지속 커넥션***

- 커넥션이 지속적이지 않다면, 클라언트는 서버가 커넥션을 닫을 때까지 본문으로 간주하므로, 본문의 크기를 알 필요가 없음
- 청크 인코딩은 서버가 본문을 여러 청크로 쪼개서 보낼 수 있게 해줌으로써, 동적으로 콘텐츠를 생성해 본문 크기를 알아내지 못하는 상황에 대한 해법 제공
    - 본문 전체를 모두 보낼 때까지 청크를 보내고, 마지막으로 크기가 0인 청크로 본문이 끝났음을 알림
- 클라이언트도 청크 인코딩된 데이터를 서버로 전송할 수 있으며, 해당 인코딩을 받아들일지 모르기때문에 `411 Length Required` 응답으로 거절당하는 것을 대비해야 함

***청크 인코딩된 메시지의 트레일러***

- 하나 이상의 조건을 만족하면 청크 메시지에 트레일러 추가 가능
    - 클라이언트의 `TE` 헤더가 트레일러를 받아들일 수 있음을 나타내는 경우
    - 트레일러가 응답을 만든 서버에 의해 추가되었고, 그 트레일러의 콘텐츠는 클라이언트가 이해하고 사용할 필요가 없는 선택적 메타데이터이므로 클라이언트가 버려도 되는 경우.
- 트레일러에는 본문의 콘텐츠가 먼저 생성되어야하는 등의 이유로 메시지 시작 시점에서 값을 알 수 없는 추가적인 헤더 필드를 담을 수 있음
    - `Transfer-Encoding`, `Trailer`, `Content-Length` 를 제외한 모든 헤더가 가능하며, 대표적으로 `Content-MD5` 헤더가 있음

### 15.6.4 콘텐츠와 전송 인코딩의 조합

- 콘텐츠 인코딩, 전송 인코딩은 동시에 사용 가능
    - 콘텐츠 인코딩 → 전송 인코딩(청크 인코딩) → 전송

### 15.6.5 전송 인코딩 규칙

- 전송 인코딩 집합은 반드시 'chunked'를 포함. 유일한 예외는 메시지가 커넥션의 종료로 끝나는 경우
- 청크 인코딩이 사용되었다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 함
- 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 함

## 15.7 시간에 따라 바뀌는 인스턴스

- 웹 객체는 동적이며, URL은 시간에 따라 다른 버전의 객체를 가리킬 수 있음
- 인스턴트 조작(instance manipulatiton):
    - HTTP 프로토콜은 어떤 특정 종류의 요청, 응답을 다루는 방법을 정의
    - 대표적인 것은 범위 요청과 델타 인코딩으로, 클라이언트가 자신이 갖고 있는 리소스 사본이 서버와 정확히 같은지 판단하고, 상황에 따라 새 인스턴트를 요청하는 능력을 가질 것을 요구.

## 15.8 검사기와 신선도

- 조건부 요청이라고 불리는 특별한 요청은, 클라이언트가 서버에게 자신이 갖고 있는 버전을 말해주고, 검사기를 통해 자신의 사본 버전이 더 이상 유효하지 않을 때만 사본을 보내달라고 요청.

### 15.8.1 신선도

- 서버는 `Expires` 나 `Cache-Control` 헤더를 통해 캐시 신선도 정보 제공
    - `Expires`: 문서가 만료되어 신선하다고 간주할 수 없게 되는 정확한 날짜
    - `Cache-Control`: 문서의 최대 수명을 문서가 서버를 떠난 후로부터의 총 시간(초 단위
- `Cache-Control` 헤더에 동반될 수 있는 지시자. [참고 링크](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Cache-Control)
    - `no-cache`: [요청] 서버와의 최초 재검사 없이는 문서의 캐시된 사본을 반환 하지 않음
    - `no-store` : [요청] 문서의 캐시된 사본을 반환하지 않음. 서버로부터의 응답을 저장 하지 않음
    - `max-age`: [요청] 캐시의 문서는 명시한 나이보다 오래되어서는 안 됨
    - `max-state`: [요청] 신선하지 않게 된 뒤로, 이 지시자로 지정한 시간보다 크지 않다면 받아들임
    - `min-fresh`: [요청] 응답은 지정한 값만큼은 신선해야 함.
    - `no-transform`: [요청] 문서는 보내기 전에 변형되어서는 안됨
    - `only-if-cached`: [요청] 서버에 접근하지말고, 캐시에 들어있는 경우에만 문서 전송 요청
    - `public`: [응답] 응답은 어떤 캐시로든 캐시됨
    - `private`: [응답] 하나의 클라이언트만 접근할 수 있는 형태로 캐시됨
    - `no-cache`: [응답] 지시자가 헤더 필드의 목록을 동반하고 있다면, 콘텐츠는 캐시될 수 있지만 그 전에 헤더 필드가 반드시 제거 되어야 함
    - `no-store`: [응답] 절대로 캐시되어서는 안됨
    - `no-transform`: [응답] 제공되기 전에 어떤 식으로든 수정되어서는 안됨
    - `must-revalidate`: [응답] 제공되기 전에 반드시 서버를 통해 재검사
    - `proxy-revalidate` : [응답] 공유된 캐시는 반드시 응답을 원 서버를 통해 재검사해야 함. 개인 캐시에 의해 무시될 수 있음
    - `max-age`: [응답] 문서가 캐시될 수 있고 신선하다고 간주되는 시간의 최대 길이
    - `s-max-age`  [응답] 공유된 캐시에 적용될 수 있는 문서의 최대 수명을 정의. `max-age` 값을 덮어씀.  개인 캐시에 의해 무시될 수 있음

### 15.8.2 조건부 요청과 검사기

- HTTP 클라이언트에게 리소스가 바뀐 경우에만 사본을 요청하는 조건부 요청이라는 특별한 요청을 할 수 있는 방법 제공
    - `If-` 로 시작하는 조건부 헤더에 의해 구현되며, 참일 때 수행되고 아니면 서버는 HTPT 에러 코드 반환
- 각 조건부 요청은 특정 검사기 위에 동작하며, 검사기는 문서의 테스트된 특정 속성임
    - 예) 일련번호, 버전번호, 문서의 최종 변경일 등
    - `If-Modified-Since` 상태 헤더는 문서의 인스턴스의 마지막 수정된 날짜를 검사하므로, 마지막 수정된 날짜를 검사기라고 할 수 있음.
- 조건부 헤더와 검사기 유형
    - `If-Modified-Since` ⇒ `Last-Modified`: Last-Modified 응답 헤더의 시간 이후로 변한 것이 있다면, 리소스 사본을 반환
    - `If-Unmodified-Since` ⇒ `Last-Modified`: Last-Modified 응답 헤더의 시간 이후로 변한 것이 없다면, 리소스 사본을 반환
    - `If-Match` ⇒ `Etag`: Etag 응답 헤더와 엔터티 태그가 같다면 그 리소스의 사본 반환
    - `If-None-Match` ⇒ `Etag`: Etag 응답 헤더와 엔터티 태그가 다르다면 그 리소스의 사본 반환
- 검사기에는 강한 검사기와 약한 검사기가 있음
    - 약한 검사기: 리소스의 인스턴트를 고유하게 식별하지(uniquely identify) 못하는 경우도 있음
        - 예: 객체의 바이트 단위 크기, 최정 변경 시각(정확도가 최대 1초라서)
    - 강한 검사기: 언제나 고유하게 식별
        - 예: 콘텐츠에 대한 암호 체크섬, ETag
- 클라이언트와 서버는 필요에 따라 엔터티 태그 검사를 통과하지 못한 버전을 채택하기도 함
    - 태그 앞에 'W/'를 붙임으로써 약한 엔터티 태그임을 알려 사소한 변화는 통과하지 않아도 사용할 수 있음
    - 강한 엔터티 태그라면 아무리 사소하게 바뀌었더라도 변경됨

## 15.9 범위 요청

- HTTP는 더 나아가, 클라이언트가 문서의 일부분이나 특정 범위만 요청할 수 있도록 해줌
    - 예: 소프트웨어의 3/4를 다운로드 완료후 실패했을 떄, 엔터티 일부를 요청함으로써 다운로드 재개

```
GET /bigfile.html HTTP/1.1 
Host: www.joes-hardware.com
Range: bytes=4000-  //← 4000바이트 이후 부분 요청
...
```

- `Range` 헤더는 여러 범위로 요청하기 위해 사용 될 수 있음
    - 각 범위는 순서 없이 정해지며, 겹칠 수 있음
- 서버는 클라이언트에게 범위를 받아들일 수 있는지 응답에 `Accept-Range` 헤더를 포함시켜 안내
    - 모든 서버가 범위 요청을 받아들일 수 있는 것은 아니지만 많은 경우 가능

```
HTTP/1.1 200 OK
Date: Fri, 05 Nov 1999 22:35:15 GMT
Server: Apache/1.2.4
Accept-Ranges: bytes
```

- 범위 요청은 어떤 객체의 특정 인스턴스들에 대한 클라이언트↔서버 사이의 정보 교환이므로 일종의 인스턴트 조작
- 엔터티 범위 요청
    1. 클라이언트 요청 메시지
    2. 서버 응답메시지 (`Accept-Range` 헤더 포함)
    3. 범위 요청 메시지(`Range` 헤더 포함)
    4. 범위 응답 메시지(`Content-Range`, `Accept-Range` 헤더 포함)

## 15.10 델타 인코딩

- 웹 페이지의 각기 다른 버전은 그 페이지에 대한 각기 다른 인스턴트
    - 어떤 페이지의 만료된 사본을 갖고 있으면, 새 인스턴트를 요청하는데 일부분만 변경되었더라도 전체 인스턴트를 받아야 함
    - 페이지에 대한 클라이언트 사본에 대해 변경된 부분을 보내 페이지를 더 빨리 얻게 할 수 있음
- 델타 인코딩: 객체 전체가 아닌 변경된 부분에 대해서만 통신하여 전송량을 최적화하는 HTTP 프로토콜 확장. [RFC 3329](https://tools.ietf.org/html/rfc3329)에서 기술.
    - 어떤 객체의 특정 인스턴스들에 대한 클라이언트↔서버 사이의 정보 교환에 의존하므로 일종의 인스턴트 조작
- 델타 인코딩의 메커니즘
    - 클라이언트는 페이지의 어떤 버전을 가지고 있는지 서버에게 전송. 이는 델타를 받아들일 의사가 있음을 의미. 현재 버전에 델타를 적용하기 위해 어떤 알고리즘을 알고 있는지 같이 전송
        - 클라이언트는 갖고 있는 버전에 대한 유일 식별자를 담아 `If-None-Match` 헤더만 보내면, 전체 버전을 받게 되므로 `A-IM` (Accept-Instance-Manipulation) 헤더를 보내 델타를 받아들일 수 있음을 알려줄 수 있음.
    - 서버는 자신이 클라이언트가 갖고 있는 버전을 가지고 있는지, 그리고 어떻게 최신 버전과 클라이언트 버전 사이의 델타를 계산할 것인지(여러 알고리즘 존재) 체크
    - 서버는 계산한 델타, 계산시 사용한 알고리즘, 델타를 계산한 기반 문서의 ETag를 클라이언트에 `226 IM Used` 상태 코드와 전송. 페이지 최신 버전에 대한 새 식별자(`ETag`) 명시
        - `IM` 헤더에 델타 계산 알고리즘 명시
        - `Delta-Base` 헤더에 델타를 계산한 기반 문서(이상적으로는 클라이언트의 `If-None-Match` 값)
        - 새 식별자는 클라이언트가 오래된 버전에 델타를 적용하여 새로 만들 페이지의 버전이 됨
- 델타 인코딩에 사용된 헤더들
    - `ETag`: 문서의 각 인스턴스에 대한 유일 식별자. 클라이언트는 이 값을 `If-Match`, `If-None-Match` 에 사용
    - `If-None-Match`: 클라이언트가 보내는 요청 헤더로, 서버가 클라이언트와 다른 버전의 문서를 갖고 있는 경우에만 문서 요청
    - `A-IM`: 받아들일 수 있는 인스턴스 조작의 종류를 가리키는 클라이언트 요청 헤더
    - `IM`: 요청에 적용된 인스턴스 조작의 종류를 명시하는 서버 응답 헤더. `226 IM Used` 일 때 이 헤더를 보냄
    - `Delta-Base`: 델타를 생성하기 위해 사용된 기저 문서의 ETag를 명시하는 서버 응답 헤더

### 15.10.1 인스턴스 조작, 델타 생성기 그리고 델타 적용기

- 클라이언트/서버의 인스턴트 조작의 종류
    - `vcdiff`: vcdiff 알고리즘을 이용한 델타
    - `diffe`: 유닉스 diff -e 명령을 이용한 델타
    - `gdiff`: gdiff 알고리즘을 이용한 델타
    - `gzip`: gzip 알고리즘을 이용한 압축
    - `deflate`: deflate 알고리즘을 이용한 압축
    - `range`: 현재 응답이 범위 선택에 대한 결과인 부분(partial) 콘텐츠임을 말해주기 위해 서버 응답에서 사용
    - `identity`: 클라이언트가 identity 인스턴스 조작을 받아들일 의사가 있음을 말해주기 위해 클라이언트 요청의 A-IM 헤더에서 사용
- 델타 생성기: 기저 문서와 그 문서의 최신 인스턴스를 취하여 클라이언트의 `A-IM` 헤더에 지정된 알고리즘을 이용해 델타 계산
- 델타 적용기: 델타를 취득하여 기저 문서에 적용하여 문서의 최신 인스턴스 생성
- 델타 인코딩은 전송 시간을 줄일 수 있지만 구현하기 까다로움.