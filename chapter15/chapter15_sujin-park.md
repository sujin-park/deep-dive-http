# 15장 엔터티와 인코딩

HTTP는 콘텐츠를 나르기 위한 잘 라벨링된 엔터티를 사용합니다. 엔터티는 아래와 같은 것을 가능하게 합니다.

- 객체가 올바르게 식별되므로 브라우저나 다른 클라이언트는 콘텐츠를 바르게 처리 가능
- 객체는 올바르게 압축이 풀릴 것
- 객체는 항상 최신
- 사용자의 요구를 만족
- 네트워크 사이를 빠르고 효율적으로 이동
- 조작되지 않고 온전하게 도착

## 15.1 메시지는 컨테이너, 엔터티는 화물

`HTTP 메시지`를 인터넷 운송 시스템의 컨테이너라고 한다면, HTTP 엔터티는 메시지의 실질적인 화물입니다.

**엔터티 헤더**
- 18자에 불과한(Content-Length: 18) 플레인 텍스트 문서(Content-Type: text/plain)를 의미
- 빈 줄 (CRLF)은 헤더 필드와 본문의 시작을 나눔

- Content-Type: 엔터티에 의해 전달된 객체의 종류
- Content-Length: 전달되는 메시지의 길이나 크기
- Content-Language: 전달되는 객체와 가장 잘 대응되는 자연어
- Content-Encoding: 객체 데이터에 대해 행해진 변형(압축 등)
- Content-Location: 요청 시점을 기준으로, 객체의 또 다른 위치
- Content-Range: 만약 이 엔터티가 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의
- Content-MD5: 엔터티 본문의 콘텐츠에 대한 체크섬
- Last-Modified: 서버에서 이 콘텐츠가 생성 혹은 수정된 날
- Expires: 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작는 날짜와 시각
- Allow: 리소스에 대해 어떤 요청 메서드가 허용되는지
- ETag: 인스턴스에 대한 고유한 검사기
- Cache-Control: 어떻게 이 문서가 캐시될 수 있는지에 대한 지시자

### 15.1.1 엔터티 본문

다른 정보들은 모두 헤더에 담겨 있고, `엔터티 본문`은 가공되지 않은 데이터만을 담고 있습니다. 엔터티 본문은 가공되지 않은 날 데이터에 불과하기 때문에 엔터티 헤더는 데이터의 의미에 대해 설명할 필요가 있습니다.

`엔터티 본문`은 헤더 필드의 끝을 의미하는 CRLF 다음부터 시작하고, 콘텐츠가 텍스트든 바이너리든 상관없이 항상 CRLF 바로 다음에 위치합니다. 


## 15.2 Content-Length: 엔터티의 길이

`Content-Length`헤더는 메시지의 엔터티 본문의 크기를 바이트 단위로 나타냅니다.

메시지를 청크 인코딩으로 전송하지 않는 이상, 엔터티 본문을 포함한 메시지는 필수적으로 있어야 합니다.

### 15.2.1 잘림 검출

- 메시지 잘림은 캐싱 프락시 서버에서 특히 취약합니다.
- 잘린 메시지를 캐시하는 위험을 줄이기 위해, 캐싱 프락시 서버는 명시적으로 Content-Length 헤더를 갖고 있찌 않은 HTTP 본문은 캐시하지 않습니다.

### 15.2.2 잘못된 Content-Length

HTTP/1.1 사용자 에이전트는 잘못된 길이를 받고 사실을 인지했을 때 사용자에게 알려주게 되어있습니다.

### 15.2.3 Content-Length 와 지속 커넥션 (Persistent Connection)

`Content-Length`는 지속 커넥션을 위해 필수입니다.

지속 커넥션을 통해서 응답이 온다면 Content-Length 가 있어야 어디까지가 엔터티 본문이고 어디부터가 다음 메시지인지 알 수 있습니다.

Content-Length 헤더가 없는 지속 커넥션을 만날 수 있는 상황은 **청크 인코딩**입니다. 데이터를 특정한 크기를 갖는 일련의 청크들로 쪼개어 보내면 엔터티 전체의 크기를 알 수 없다하더라도 서버는 청크 인코딩을 이용해 엔터티를 잘 정의된 크기의 조각들로 전송할 수 있습니다.

### 15.2.4 콘텐츠 인코딩

보안을 강화하거나 압축을 통해 공간을 절약할 수 있도록, `엔터티 본문을 인코딩` 할 수 있게 해줍니다.

Content-Length 헤더 또한 인코딩된 본문의 길이를 바이트 단위로 정의합니다.a

### 15.2.5 엔터티 본문 길이 판별을 위한 규칙

다음은 엔터티 본문의 길이와 끝나는 위치를 바르게 판별하는 상황별 규칙들입니다.

1. 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP 메시지는 본문 계산을 위한 Content-Length 헤더가 무시됩니다.
    
    e.g) HEAD 응답은 본문을 갖지 않기 때문에 엔터티 본문을 금하는 메시지는 어떤 엔터티 헤더 필드가 존재하느냐와 상관없이 헤더 이후의 빈 줄에서 끝나야 합니다.

2. 메시지가 `Transfer-Encoding` 헤더를 포함하고 있다면, 메시지가 커넥션이 닫혀서 끝나지 않는 이상 엔터티는 `0바이트 청크`라 불리는 특별한 패턴으로 끝나야 합니다.

3. Content-Length 값은 Transfer-Encoding 헤더가 존재하지 않는 이상 본문의 길이를 담게 됩니다. 만약 Transfer-Encoding 헤더 필드를 갖고 있는 메시지를 받았다면, 반드시 Content-Length 헤더를 무시해야 합니다.

4. 메시지가 multipart/byteranges 미디어 타입을 사용하고 엔터티 길이가 별도로 정의되지 않았다면, 멀티파트 메시지의 각 부분은 각자가 스스로의 크기를 정의할 것입니다. 

    > 멀티파트 유형은 자신의 크기를 스스로 결정할 수 있는 유일한 엔터티 본문 유형

5. 위의 어떤 규칙에도 해당되지 않는다면, 엔터티는 커넥션이 닫힐 때 끝납니다.

6. HTTP/1.0 애플리케이션과의 호환을 위해, 엔터티 본문을 갖고 있는 HTTP/1.1 요청은 반드시 유효한 Content-Length 헤더도 갖고 있어야 합니다.

## 15.3 엔터티 요약

엔터티 본문 데이터에 대한 의도하지 않은 변경을 감지하기 위해, 최초 엔터티가 생성될 때 송신자는 데이터에 대한 체크섬을 생성할 수 있으며, 수신자는 모든 의도하지 않은 엔터티의 변경을 잡아내기 위해 체크섬으로 기본적인 검사를 할 수 있습니다.

## 15.4 미디어 타입과 차셋(Charset)

Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술합니다.

> MIME Type

전달되는 데이터 매체의 기저 형식의 표준화된 이름, 클라이언트는 콘텐츠를 적절히 해옥하고 처리하기 위해 MIME 타입을 이용합니다.

Content-Type의 값은 인터넷 할당 번호 관리기관에 등록된 표준화된 MIME 타입입니다.

```
주 미디어 타입(텍스트, 이미지, 오디오 등)/미디어 타입을 구체적으로 서술하는 부 타입
e.g) text/html
```

| 미디어 타입 | 설명 |
|---|:---:|
| `text/html` | 엔터티 본문은 HTML 문서 |
| `text/plain` | 엔터티 본문은 플레인 텍스트 문서 |
| `image/gif` | 엔터티 본문은 GIF 이미지 |
| `image/jpeg` | 엔터티 본문은 JPEG 이미지 |
| `audio/x-wav` | 엔터티 본문은 WAV 음향 데이터를 포함 |
| `model/vrml` | 삼차원 VRML 모델 |
| `application/vnd.ms-powerpoint` | 마이크로소프트 파워포인트 프레젠테이션 |
| `multipart/byteranges` | 각 부분은 전체 문서의 특정 범위(바이트 단위)를 담고 있다. |
| `message/http ` | 엔터티 본문은 완전한 HTTP 메시지 |

### 15.4.1 텍스트 매체를 위한 문자 인코딩

Content-Type 헤더는 내용 유형을 더 자세히 지정하기 위한 선택적인 매개변수도 지원합니다.

엔터티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 `charset`매개변수

```
Content-Type: text/html; charset=iso-8859-4
```

### 15.4.2 멀티파트 미디어 타입

- MIME 멀티파트 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 전송
- 각 구성 요소는 자신에 대해 서술하는 헤더를 포함
- HTTP는 멀티파트 본문도 지원

### 15.4.3 멀티파트 폼 제출

- HTTP 폼을 채워서 제출하면, 가변 길이 텍스트 필드와 업로드 될 객체는 각각이 멀티파트 본문응ㄹ 구성하는 하나의 파트가 되어 보내집니다.
- 멀티 파트 본문은 다른 종류와 길이의 값으로 채워진 폼을 허용

```
Content-Type: multipart/form-data; boundary=[asfsdfsdfsdfsfs]
```

boundary 는 본문의 서로 다른 부분을 구분하기 위한 구분자로 쓰입니다.


### 15.4.4 멀티파트 범위 응답

범위 요청에 대한 HTTP 응답 또한 멀티파트가 될 수 있습니다.

응답은 `Content-Type: multipart/byteranges` 헤더 및 각각 다른 범위를 담고 있는 멀티파트 본문이 옵니다.

## 15.5 콘텐츠 인코딩

HTTP 애플리케이션은 때때로 콘텐츠를 보내기 전에 인코딩을 하려고 합니다.

인쾽은 발송하는 쪽에서 콘텐츠를 적용합니다. 콘텐츠 인코딩이 끝난 데이터는 늘 그렇듯 엔터티 본문에 담아 수신자에게 보냅니다.

### 15.5.1 콘텐츠 인코딩 과정

1. 웹 서버가 원본 Content-Type 과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성
2. 콘텐츠 인코딩 서버가 인코딩된 메시지를 생성, 인코딩된 메시지는 Content-Type 은 같지만 Content-Length 는 다름. Content-Encoding 헤더를 인코딩된 메시지에 추가하여, 애플리케이션이 디코딩할 수 있도록 함
3. 수신 측 프로그램은 인코딩된 메시지를 받아서 디코딩하고 원본을 얻음

`Content-Length` 헤더는 인코딩된 본문의 길이를 나타낸다는 것을 기억해야 합니다.

### 15.5.2 콘텐츠 인코딩 유형

인코딩은 각 콘텐츠 인코딩 알고리즘에 고유한 토큰을 할당하는 IANA 를 통해 표준화됩니다.
Content-Encoding 헤더는 이러한 표준화된 토큰 값을 이용해서, 인코딩에 사용된 알고리즘에 대해 기술합니다.

`gzip`은 일반적으로 가장 효율적이고 가장 널리 쓰이는 압축 알고리즘입니다.

| 콘텐츠 인코딩 값 | 설명 |
|---|:---:|
| `gzip` | 엔터티에 GNU zip 인코딩이 적용되었음을 의미 |
| `compress` | 엔터티에 대해 유닉스 파일 압축 프로그램인 `compress 가 실행되었음을 의미 |
| `deflate` | 엔터티가 zlib 포맷으로 압축되었음을 의미 |
| `identity` | 엔터티에 어떤 인코딩도 수행되지 않았음을 의미, Content-Encoding 헤더가 존재하지 않는다면 이 값인 것으로 간주 |

### 15.5.3 Accept-Encoding 헤더

클라이언트는 `자신이 지원하는 인코딩의 목록을 Accept-Encoding 요청 헤더를 통해 전달`합니다. HTTP 요청에 Accept-Encoding 헤더를 포함하지 않는다면, 서버는 클라이언트가 어떤 인코딩이든 받아들일 수 있다고 간주합니다. (Accept-Encoding: * 과 같음)

```
Accept-Encoding: compress, gzip
Accept-Encoding: 
Accept-Encoding: *
Accept-Encoding: compress;q=0.5, gzip;q=1.0
Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
```

> identity 인코딩 토큰
- 오직 Accept-Encoding 헤더에만 존재
- 클라이언트에 의해 다른 콘텐츠 인코딩 알고리즘에 대한 상대적 선호도 정의하는데 사용


## 15.6 전송 인코딩과 청크 인코딩

`전송 인코딩`은 엔터티 본문에 적용되는 가역적 변환이지만, 그들은 구조적인 이유 때문에 적용되는 것이며 콘텐츠의 포맷과는 독립적입니다.

```
콘텐츠 인코딩된 응답
HTTP/1.0 200 OK
Content-encoding: gzip // 보통 헤더 블럭
Content-Type: text/html
[...]
[encoded message] // 보통 엔터티 (여기만 인코딩)
__________________________

전송 인코딩된 응답
HTTP/1.1 200 OK // 기본 헤더
Transfer-encoding: chunked

10
dsfafasdfasf // 인코딩된 블록
sdf
d
```

### 15.6.1 안전한 전송

`전송 인코딩`은 안전한 전송을 위해 존재했습니다. HTTP 에서 전송된 메시지의 본문이 문제를 일으킬 수 있는 이유는 아래와 같습니다. 

**알 수 없는 크기**

- 콘텐츠를 먼저 생성하지 않고서는 콘텐츠 인코더는 메시지 본문의 최종 크기를 알 수 없습니다.
- HTTP 는 Content-Length 헤더를 요구하기 때문에, 데이터 끝을 알리는 문자를 포함시켜 전송 인코딩으로 데이터를 보내려 시도합니다.

**보안**

SSL 과 같은 유명한 전송 계층 보안 방식이 있기 때문에 전송 인코딩 보안은 흔하지 않습니다.

### 15.6.2 Transfer-Encoding 헤더

전송 인코딩을 제어하고 서술하기 위해 정의된 헤더는 아래와 같습니다.

**Transfer-Encoding**

안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려줍니다.

**TE**

가능한 확장된 전송 인코딩을 서버에게 알려주기 위해 요청 헤더에 사용합니다.

- 전송 인코딩 값은 대소문자 구별
- HTTP/1.1 은 Transfer-Encoding 과 TE 헤더 필드에 전송 인코딩 값 사용
- 최신 명세는 하나의 전송 인코딩, 청크 인코딩만을 정의

### 15.6.3 청크 인코딩

`청크 인코딩`은 메시지를 일정 크기의 청크 여럿으로 쪼갭니다.

서버는 각 청크를 순차적으로 보내고, 청크 인코딩을 이용하면 메시지를 보내기 전에 전체 크기를 알 필요가 없어집니다. 본문이 동적으로 생성됨에 따라, 서버는 그중 일부를 버퍼에 담은 뒤 그 한 청크를 그것의 크기와 함께 보낼 수 있고 본문 전체를 모두 보낼 때까지 이 단계를 반복합니다.

> 청크와 지속 커넥션

지속 커넥션에서는 본문을 쓰기 전에 반드시 Content-Length 헤더에 본문의 길이를 담아서 보내줘야 합니다. 콘텐츠가 서버에서 동적으로 생성되는 경우에는 보내기 전에 본문의 길이를 알아내는 것이 불가능합니다.

`청크 인코딩`은 서버가 본문을 여러 청크로 쪼개 보낼 수 있게 해줌으로써 딜레마에 대한 해법을 제공합니다.

> 청크 인코딩된 메시지 트레일러

다음 중 하나 이상의 조건을 만족하면 청크 메시지에 트레일러를 추가할 수 있습니다.

- 클라이언트의 TE 헤더가 트레일러를 받아들일 수 있음을 나타내고 있는 경우
- 트레일러가 응답을 만든 서버에 의해 추가되었으며, 트레일러의 콘텐츠는 클라이언트가 이해하고 사용할 필요가 없는 선텍적인 메타데이터이므로 클라이언트가 무시하고 버려도 되는 경우

Transfer-Encoding, Trailer, Content-Length 를 제외한 어떤 HTTP 헤더도 트레일러로 보낼 수 있습니다.

### 15.6.4 콘텐츠와 전송 인코딩의 조합

콘텐츠 인코딩과 전송 인코딩을 동시에 사용할 수 있습니다.

송신자가 콘텐츠 인코딩을 사용해서 HTML 파일을 압축하고 그 청크 데이터를 전송 인코딩을 사용해서 전송합니다.

### 15.6.5 전송 인코딩 규칙

**전송 인코딩이 메시지 본문에 적용 될 때 적용되어야 하는 규칙**

- 집합은 반드시 `chunked`를 포함해야 합니다. 예외는 메시지가 커넥션의 종료로 끝나는 경우
- 청크 전송 인코딩이 사용되었다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 함
- 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 함

`전송 인코딩`은 비교적 새로운 기능으로 비 HTTP/1.1 애플리케이션에 전송 인코딩된 메시지를 보내지 않도록 특별히 주의해야 합니다. 그러나 어떠한 HTTP/1.1 애플리케이션이라도 최소한 청크 인코딩만은 반드시 지원해야 합니다.

## 15.7 시간에 따라 바뀌는 인스턴스

클라이언트는 같은 리소스를 여러 번 요청해도 시간이 흐름에 따라 리소스의 다른 인스턴스를 받게 됩니다.

HTTP 프로토콜은 특정한 종류의 요청이나 응답을 다루는 방법들을 정의하는 것을 `인스턴스 조작`이라고 하며 객체의 인스턴스에 작용합니다.
- 대표적인 두 가지는 범위 요청과 델타 인코딩
    - 클라이언트가 갖고 있는 리소스의 사본이 서버와 같은지 판단하고, 상황에 따라서 새 인스턴스를 요청할 수 있는 능력을 요구

## 15.8 검사기와 신선도

**조건부 요청**

클라이언트가 서버에게 갖고 있는 버전을 말해주고 검사기를 사용해 자신의 사본 버전이 더 이상 유효하지 않을 때만 사본을 보내달라고 요청하는 것

세 가지 주요 개념 : 신선도, 검사기, 조건

### 15.8.1 신선도

- Expires 헤더
    - 문서가 만료되어 신선하다고 간주할 수 없게 되는 정확한 날짜
    ```
        Expires: Sun Mar 18 23:59:59 GMT 2001
    ```
- Cache-Control 헤더
    - 문서의 최대 수명을 문서가 서버를 떠난 후로부터의 총 시간을 초 단위로 정한 것
    - 유효기간뿐 아니라 신선도를 서술하기 위해 사용

| 지시자 | 메시지 타입 | 설명 |
|---|:---:|:---:|
| `no-cache` | 요청 | 서버와의 최초 재검사 없이는 문서의 캐시된 사본을 반환 X | 
| `no-store` | 요청 | 문서의 캐시된 사본을 반환하지 않음 / 서버로부터의 응답을 저장 X | 
| `max-age` | 요청 | 캐시의 문서는 명시한 나이보다 오래되어서는 절대로 안됨 | 
| `max-state` | 요청 | 신선하지 않게 되더라도 지난 시간이 이 지시자로 지정한 시간보다 크지 않다면 받아들임 | 
| `min-fresh` | 요청 | 문서의 신선도 수명이 문서의 나이 + 지정한 값보다 작아서는 안됨 | 
| `no-transform` | 요청 | 문서는 보내기 전에 변형 X | 
| `only-if-cached` | 요청 | 서버에 접근하지말고, 캐시에 들어있는 경우에만 문서 제공 | 
| `public` | 요청 | 응답은 어떤 캐시로든 캐시 됨 | 
| `private` | 요청 | 하나의 클라이언트만 접근할 수 있는 형태로 캐시 | 
| `no-cache` | 응답 | 지시자가 헤더 필드의 목록을 동반하고 있다면, 콘텐츠는 캐시될 수 있지만 그 전에 헤더 필드가 반드시 제거 되어야 함 | 
| `no-store` | 응답 | 절대로 캐시되어서는 안됨 | 
| `no-transform` | 응답 | 제공되기 전에는 어떤 식으로든 수정 X | 
| `must-revalidate` | 응답 | 반드시 제공되기 전에 서버를 통해 재검사 | 
| `proxy-revalidate` | 응답 | 공유된 캐시는 반드시 응답을 원 서버를 통해 재검사해야 함 (개인 캐시에 의해 무시 가능)| 
| `max-age` | 응답 | 문서가 캐시될 수 있고 신선하다고 간주될 수 있는 시간의 최대 길이 | 
| `s-max-age` | 응답 | 공유된 캐시에 적용될 수 있는 문서의 최대 수명을 정의 (개인 캐시에 의해 무시 가능) | 

### 15.8.2 조건부 요청과 검사기

**조건부 요청**은 평범한 요청 메시지이지만, 특정 조건이 참일때만 수행됩니다.

예를 들어 캐시는 다음의 조건부 GET 메시지를 서버에 보내서, /announce.html 파일이 2021년 01월 19일(캐시된 문서가 작성자에 의해 마지막으로 변경된 날짜) 이후에 변경된 경우에만 한해서 파일을 보내달라고 할 수 있습니다.

조건부 요청은 **If-** 로 시작하는 조건부 헤더에 의해 구현됩니다. 조건이 참이 아니면 서버는 HTTP 에러 코드를 돌려보냅니다.
```
GET /announce.html HTTP/1.0
If-Modified-Since: Tue, 19 Jan 2021, 14:30:00 GMT
```

**조건부 요청 유형**

| 요청 유형 | 검사기 | 설명 |
|---|:---:|:---:|
| `If-Modified-Since` | Last-Modified | Last-Modified 응답 헤더에 들어있었던 시각에 마지막으로 수정된 버전에서 변한 것이 있다면, 리소스 사본을 보내라. | 
| `If-Unmodified-Since` | Last-Modified | Last-Modified 응답 헤더에 들어있었던 시각에 마지막으로 수정된 버전에서 변한 것이 없다면, 리소스 사본을 보내라. | 
| `If-Match` | Etag | Etag 응답 헤더에 들어있었던 것과 엔터티 태그가 같다면, 그 리소스의 사본을 보내라. | 
| `If-None-Match` | Etag | Etag 응답 헤더에 들어있었던 것과 엔터티 태그가 다르다면, 그 리소스의 사본을 보내라. |

### 15.9 범위 요청

`범위 요청`을 이용하면, HTTP 클라이언트는 받다가 실패한 엔터티를 일부 혹은 범위로 요청함으로써 다운로드를 중단된 시점에서 재개할 수 있습니다.

```
GET /bigfile.html HTTP/1.1
Host: www.github.io
Range: bytes=4000-
User-Agent: Mozilla/4.61 [en] (WinNT; I)
```

클라이언트는 처음 4,000바이트 이후의 부분을 요청하고 있습니다. 클라이언트가 처음 4,000바이트만 받고 실패했을 때 사용할 수 있습니다.

자신이 범위를 받아들일 수 있는지 응답에 `Accept-Range` 헤더를 포함시키는 방법으로 알려줄 수 있습니다.

```
HTTP/1.1 200 OK
Date: Fri, 05 Nov 2000 22:30:00 GMT
Server: Apache/1.2.4
Accept-Ranges: bytes
```

### 15.10 델타 인코딩

`델타 인코딩`이란 객체 전체가 아닌 변경된 부분에 대해서만 통신하여 전송량을 최적화하는, HTTP 프로토콜의 확장

> 델타 인코딩의 매커니즘

1. 클라이언트가 페이지의 최신 버전에 대한 델타를 받아들일 의사가 있으면 클라이언트는 페이지의 어떤 버전과 알고리즘을 갖고 있는지 서버에게 말해줍니다.

2. 서버는 자신이 클라이언트가 갖고 있는 버전을 갖고 있는지, 어떻게 최신 버전과 클라이언트의 버전 사이의 델타를 계산할 것인지 체크해야 합니다.

3. 델타를 계산해서 클라이언트에게 보내주고, 서버가 델타를 보내고 있음을 클라이언트에게 알려주고, 페이지의 최신 버전에 대한 새 식별자를 명시해야 합니다.


> 델타 인코딩 관련 헤더들

| 헤더 | 설명 |
|---|:---:|
| `Etag` | 문서의 각 인스턴스에 대한 유일한 식별자. If-Match, If-None-Match 헤더에 사용 | 
| `If-None-Match` | Last-Modified | 클라이언트가 보내는 요청 헤더. 서버와 클라이언트가 다른 버전의 문서를 가지고 있다면 그 문서에 한해 요청 | 
| `A-IM` | 받아들일 수 있는 인스턴스 조작의 종류를 가리키는 클라이언트 요청 헤더 | 
| `IM` | 요청에 적용된 인스턴스 조작의 종류를 명시하는 서버의 응답 헤더 |
| `Delta-Base` | Etag | 델타를 생성하기 위해 사용된 기저 문서의 Etag 를 명시하는 서버 응답 헤더 |

### 15.10.1 인스턴스 조작, 델타 생성기 그리고 델타 적용기

- 클라이언트는 A-IM 헤더를 사용해서 자신이 받아들일 수 있는 인스턴스 조작의 종류를 명시할 수 있습니다.
- 서버는 IM 헤더에 사용한 인스턴스 조작의 종류를 명시할 수 있습니다.

**아래는 IANA에 등록된 인스턴스 조작의 종류를 몇 가지 나열하고 있습니다.**

| 종류 | 설명 |
|---|:---:|
| `vcdiff` | vcdiff 알고리즘을 이용한 델타
| `diffe` | 유닉스 diff -e 명령을 이용한 델타
| `gdiff` | gdiff 알고리즘을 이용한 델타
| `gzip` | gzip 알고리즘을 이용한 압축
| `deflate` | deflate 알고리즘을 이용한 압축
| `range` | 현재 응답이 범위 선택에 대한 결과인 부분 콘텐츠임을 말해주기 위해 서버 응답에서 사용
| `identit` | 클라이언트가 identity 인스턴스 조작을 받아들일 의사가 있음을 말해주기 위해 클라이언트 요청의 A-IM 헤더에서 사용
